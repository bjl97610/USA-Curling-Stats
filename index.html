<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <meta name="theme-color" content="#c41e3a">
  <meta name="description" content="USA Curling Shot Tracker - Track shots offline during games">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Shot Tracker">
  <link rel="manifest" href="manifest.json">
  <link rel="icon" type="image/x-icon" href="icons/favicon.ico">
  <link rel="icon" type="image/png" sizes="32x32" href="icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="icons/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
  <title>USA Curling Shot Tracker</title>
  
  <!-- Fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Bebas+Neue&family=Source+Sans+3:wght@400;500;600;700&display=swap" rel="stylesheet">
  
  <style>
    :root {
      --primary: #c41e3a;
      --primary-dark: #a01830;
      --secondary: #1a1a2e;
      --accent: #0f3460;
      --ice: #e8f4f8;
      --ice-dark: #b8d4dc;
      --gold: #d4af37;
      --success: #2d6a4f;
      --warning: #e9c46a;
      --text: #1a1a2e;
      --text-light: #6b7280;
      --white: #ffffff;
      --shadow: 0 4px 20px rgba(0,0,0,0.1);
      --shadow-lg: 0 10px 40px rgba(0,0,0,0.15);
      --radius: 12px;
      --radius-sm: 8px;
    }
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Source Sans 3', -apple-system, BlinkMacSystemFont, sans-serif;
      background: linear-gradient(135deg, var(--ice) 0%, var(--ice-dark) 100%);
      min-height: 100vh;
      color: var(--text);
      -webkit-font-smoothing: antialiased;
    }
    
    #root {
      min-height: 100vh;
    }
    
    /* Loading state */
    .loading-screen {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      min-height: 100vh;
      gap: 24px;
      position: relative;
      overflow: hidden;
    }
    
    .loading-logo {
      font-family: 'Bebas Neue', sans-serif;
      font-size: 48px;
      color: var(--primary);
      letter-spacing: 2px;
    }
    
    .loading-spinner {
      width: 40px;
      height: 40px;
      border: 4px solid var(--ice-dark);
      border-top-color: var(--primary);
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }
    
    .loading-curling-logo {
      width: 120px;
      height: 120px;
      opacity: 0;
      transform: scale(0.5) translateY(100px);
      transition: none;
    }
    
    .loading-screen.ready .loading-spinner {
      opacity: 0;
      transform: scale(0);
      transition: all 0.3s ease-out;
    }
    
    .loading-screen.ready .loading-logo {
      transform: translateY(-20px);
      transition: transform 0.5s ease-out;
    }
    
    .loading-screen.ready .loading-curling-logo {
      opacity: 1;
      transform: scale(1) translateY(0);
      animation: logoPushThrough 0.8s cubic-bezier(0.34, 1.56, 0.64, 1) forwards;
    }
    
    .loading-screen.fade-out {
      opacity: 0;
      transform: scale(1.1);
      transition: all 0.4s ease-in;
    }
    
    @keyframes spin {
      to { transform: rotate(360deg); }
    }
    
    @keyframes logoPushThrough {
      0% {
        opacity: 0;
        transform: scale(0.3) translateY(80px);
      }
      50% {
        opacity: 1;
        transform: scale(1.2) translateY(-10px);
      }
      75% {
        transform: scale(0.95) translateY(5px);
      }
      100% {
        opacity: 1;
        transform: scale(1) translateY(0);
      }
    }
  </style>
</head>
<body>
  <div id="root">
    <div class="loading-screen" id="loading-screen">
      <div class="loading-logo">USA CURLING</div>
      <img class="loading-curling-logo" src="usa_curling_logo.png" alt="USA Curling Logo" />
      <div class="loading-spinner"></div>
    </div>
  </div>
  
  <!-- Loading Animation Script -->
  <script>
    // Trigger the ready animation when the app is about to render
    window.triggerLoadingComplete = function() {
      const loadingScreen = document.getElementById('loading-screen');
      if (loadingScreen) {
        loadingScreen.classList.add('ready');
        setTimeout(() => {
          loadingScreen.classList.add('fade-out');
        }, 1000);
      }
    };
  </script>
  
  <!-- Service Worker Registration -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('/sw.js')
          .then((registration) => {
            console.log('SW registered:', registration.scope);
          })
          .catch((error) => {
            console.log('SW registration failed:', error);
          });
      });
    }
  </script>
  
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>
  <script src="https://unpkg.com/jspdf@2.5.1/dist/jspdf.umd.min.js"></script>
  <script src="https://unpkg.com/jspdf-autotable@3.8.2/dist/jspdf.plugin.autotable.min.js"></script>
  
  <script type="text/babel" data-type="module">
    const { useState, useEffect, useReducer, useCallback, useMemo, createContext, useContext } = React;

    // ============================================
    // DATA & CONSTANTS
    // ============================================
    
    const PLAYER_DATA = [
      { name: "Danny Casper", team: "Casper", position: "Fourth", userId: 2807 },
      { name: "Luc Violette", team: "Casper", position: "Third", userId: 2809 },
      { name: "Ben Richardson", team: "Casper", position: "Second", userId: 2806 },
      { name: "Aidan Oldenburg", team: "Casper", position: "Lead", userId: 2810 },
      { name: "Rich Ruohonen", team: "Casper", position: "Fifth", userId: 10505 },
      { name: "Korey Dropkin", team: "Dropkin", position: "Fourth", userId: 3250, mdTeam: "Dropkin/Thiesse" },
      { name: "Thomas Howell", team: "Dropkin", position: "Third", userId: 3262 },
      { name: "Andrew Stopera", team: "Dropkin", position: "Second", userId: 3237 },
      { name: "Mark Fenner", team: "Dropkin", position: "Lead", userId: 3254 },
      { name: "Caden Hebert", team: "Hebert", position: "Fourth", userId: 10514 },
      { name: "Jackson Bestland", team: "Hebert", position: "Third", userId: 10513 },
      { name: "Benji Paral", team: "Hebert", position: "Second", userId: 10512 },
      { name: "Jack Wendtland", team: "Hebert", position: "Lead", userId: 10511 },
      { name: "Daniel Laufer", team: "Hebert", position: "Fifth", userId: 5795 },
      { name: "Allory Johnson", team: "Johnson", position: "Fourth", userId: 10507 },
      { name: "Gianna Johnson", team: "Johnson", position: "Third", userId: 10508 },
      { name: "Morgan Zacher", team: "Johnson", position: "Second", userId: 10509 },
      { name: "Bailey Vaydich", team: "Johnson", position: "Lead", userId: 10510 },
      { name: "Ella Wendling", team: "Johnson", position: "Fifth", userId: 10736 },
      { name: "John Shuster", team: "Shuster", position: "Fourth", userId: 3249 },
      { name: "Chris Plys", team: "Shuster", position: "Third", userId: 3239 },
      { name: "Colin Hufman", team: "Shuster", position: "Second", userId: 3240 },
      { name: "Matt Hamilton", team: "Shuster", position: "Lead", userId: 3246 },
      { name: "Tabitha Peterson", team: "Peterson", position: "Fourth", userId: 3263 },
      { name: "Cory Thiesse", team: "Peterson", position: "Third", userId: 3242, mdTeam: "Dropkin/Thiesse" },
      { name: "Taylor Anderson", team: "Peterson", position: "Second", userId: 3261 },
      { name: "Tara Peterson", team: "Peterson", position: "Lead", userId: 3257 },
      { name: "Aileen Gerving", team: "Peterson", position: "Fifth", userId: 3235 },
      { name: "Delaney Strouse", team: "Strouse", position: "Fourth", userId: 2815 },
      { name: "Anne O'Hara", team: "Strouse", position: "Third", userId: 3236 },
      { name: "Sydney Mullaney", team: "Strouse", position: "Second", userId: 2817 },
      { name: "Maddie Bear", team: "Strouse", position: "Lead", userId: 10506 },
      { name: "Matthew Thums", team: "Wheelchair", position: "Fourth", userId: 3255 },
      { name: "Oyuna Uranchimeg", team: "Wheelchair", position: "Third", userId: 3238 },
      { name: "Sean O'Neill", team: "Wheelchair", position: "Second", userId: 6555 },
      { name: "Dan Rose", team: "Wheelchair", position: "Lead", userId: 3244 },
      { name: "Steve Emt", team: null, position: null, userId: 3245, mdTeam: "Emt/Dwyer" },
      { name: "Laura Dwyer", team: null, position: null, userId: 3252, mdTeam: "Emt/Dwyer" },
    ];

    const TEAMS = [...new Set(PLAYER_DATA.filter(p => p.team).map(p => p.team))].sort();
    const MD_TEAMS = [...new Set(PLAYER_DATA.filter(p => p.mdTeam).map(p => p.mdTeam))].sort();

    const SHOT_TYPES = [
      "Center Guard", "Corner Guard", "Draw", "Freeze", "Tap", "Dig",
      "Peel", "Double Peel", "Takeout", "Double Takeout", "Hit and Roll",
      "Runback", "Center Tick", "Corner Tick", "Trick Shot", "Throw Through"
    ];

    const MISS_TYPES = [
      "Over Swept", "Under Swept", "Light", "Heavy",
      "Line - Wide", "Line - Narrow", "Line Call", "Broom Placement",
      "Pick", "Burnt"
    ];

    const ICE_CONDITIONS = ["13.5", "14", "14.5", "15", "15.5"];
    const SHOT_WEIGHTS = ["Guard", "Draw", "12.5", "11.5", "10.5", "9.5", "8.5", "7.5", "6.5"];
    const COMP_ROUNDS = ["Pool Play", "Quarter-Final", "Semi-Final", "Final"];

    const POSITION_MAP = {
      "4 Person": { positions: ["Lead", "Second", "Third", "Fourth"], maxShots: 8 },
      "3 Person": { positions: ["Lead", "Second", "Third"], maxShots: 8 },
      "Mixed Doubles": { positions: ["First/Last", "Middle"], maxShots: 5 }
    };

    // ============================================
    // STORAGE UTILITIES
    // ============================================
    
    const Storage = {
      save: (key, data) => {
        try {
          localStorage.setItem(key, JSON.stringify(data));
        } catch (e) {
          console.error('Storage save failed:', e);
        }
      },
      load: (key, defaultValue = null) => {
        try {
          const data = localStorage.getItem(key);
          return data ? JSON.parse(data) : defaultValue;
        } catch (e) {
          console.error('Storage load failed:', e);
          return defaultValue;
        }
      },
      remove: (key) => {
        try {
          localStorage.removeItem(key);
        } catch (e) {
          console.error('Storage remove failed:', e);
        }
      }
    };

    // ============================================
    // INDEXED DB FOR COMPETITION ARCHIVE
    // ============================================
    
    const CompetitionDB = {
      dbName: 'CurlingTrackerDB',
      dbVersion: 1,
      storeName: 'competitions',
      
      async init() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.dbVersion);
          
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
          
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(this.storeName)) {
              const store = db.createObjectStore(this.storeName, { keyPath: 'id' });
              store.createIndex('name', 'name', { unique: false });
              store.createIndex('dateCreated', 'dateCreated', { unique: false });
            }
          };
        });
      },
      
      async getAll() {
        const db = await this.init();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(this.storeName, 'readonly');
          const store = transaction.objectStore(this.storeName);
          const request = store.getAll();
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result || []);
        });
      },
      
      async get(id) {
        const db = await this.init();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(this.storeName, 'readonly');
          const store = transaction.objectStore(this.storeName);
          const request = store.get(id);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
        });
      },
      
      async save(competition) {
        const db = await this.init();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(this.storeName, 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.put(competition);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve(request.result);
        });
      },
      
      async delete(id) {
        const db = await this.init();
        return new Promise((resolve, reject) => {
          const transaction = db.transaction(this.storeName, 'readwrite');
          const store = transaction.objectStore(this.storeName);
          const request = store.delete(id);
          request.onerror = () => reject(request.error);
          request.onsuccess = () => resolve();
        });
      },
      
      async createCompetition(name) {
        const competition = {
          id: `comp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          name: name,
          dateCreated: new Date().toISOString(),
          games: []
        };
        await this.save(competition);
        return competition;
      },
      
      async archiveGame(competitionId, gameState) {
        const competition = await this.get(competitionId);
        if (!competition) throw new Error('Competition not found');
        
        const archivedGame = {
          id: `game_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          archivedAt: new Date().toISOString(),
          teamName: gameState.teamName,
          opponent: gameState.opponent,
          gameDate: gameState.gameDate,
          gameType: gameState.gameType,
          totalEnds: gameState.totalEnds,
          statOptions: gameState.statOptions,
          statMode: gameState.statMode,
          competition: gameState.competition,
          compRound: gameState.compRound,
          lineup: gameState.lineup,
          shots: gameState.shots,
          firstEndHammer: gameState.firstEndHammer,
          gameEnded: true,
          finalScore: (() => {
            const lastShot = gameState.shots.filter(s => !s.isLSD).slice(-1)[0];
            return lastShot?.score || '0-0';
          })()
        };
        
        competition.games.push(archivedGame);
        await this.save(competition);
        return archivedGame;
      },
      
      async deleteGame(competitionId, gameId) {
        const competition = await this.get(competitionId);
        if (!competition) throw new Error('Competition not found');
        
        competition.games = competition.games.filter(g => g.id !== gameId);
        await this.save(competition);
      }
    };

    // ============================================
    // GAME STATE REDUCER
    // ============================================
    
    const initialGameState = {
      gameType: "4 Person",
      totalEnds: 10,  // 8 or 10 ends
      statOptions: "Single Team",  // "Single Team" or "Both Teams" (tracking options)
      statMode: "Simple",  // "Simple" or "Advanced" (stat detail level)
      teamName: "",
      opponent: "",
      firstEndHammer: "",
      numLSDs: 0,  // Number of Last Stone Draws (0, 1, or 2)
      currentLSD: 0,  // Current LSD being thrown (0 = not in LSD phase)
      lsdPhase: false,  // Whether we're in LSD phase
      competitionId: "",  // ID of selected competition for archiving
      competition: "",
      compRound: "Pool Play",
      gameDate: new Date().toISOString().split('T')[0],
      lineup: {},
      pendingLineup: null,  // Stores pending lineup changes awaiting confirmation
      pendingGameType: null, // Stores pending game type change
      currentEnd: 1,
      currentShot: 1,
      currentTeamShot: 1,  // Track shot number for current team (1-8 for team, 1-8 for opponent)
      currentThrower: "",  // Which team is currently throwing (teamName or opponent)
      currentHammer: "",
      lastIceCondition: "",
      shots: [],
      gameEnded: false,
      activeTab: "setup"
    };

    function gameReducer(state, action) {
      switch (action.type) {
        case 'SET_GAME_TYPE':
          // If game has started (shots exist), set as pending change
          if (state.shots.length > 0) {
            // Build new lineup for the new game type using same team
            const teamPlayers = PLAYER_DATA.filter(p => 
              action.payload === "Mixed Doubles" 
                ? p.mdTeam === state.teamName
                : p.team === state.teamName
            );
            const newLineup = {};
            const positions = POSITION_MAP[action.payload].positions;
            positions.forEach(pos => {
              // Try to keep existing player if position exists, otherwise use default
              if (state.lineup[pos]) {
                newLineup[pos] = state.lineup[pos];
              } else {
                const player = teamPlayers.find(p => p.position === pos);
                if (player) newLineup[pos] = player.name;
              }
            });
            return { 
              ...state, 
              pendingGameType: action.payload,
              pendingLineup: newLineup
            };
          }
          return { 
            ...state, 
            gameType: action.payload,
            teamName: "",
            lineup: {},
            pendingLineup: null,
            pendingGameType: null,
            currentHammer: "",
            firstEndHammer: ""
          };
        
        case 'SET_TEAM':
          const teamPlayers = PLAYER_DATA.filter(p => 
            action.payload.gameType === "Mixed Doubles" 
              ? p.mdTeam === action.payload.team
              : p.team === action.payload.team
          );
          const newLineup = {};
          const positions = POSITION_MAP[action.payload.gameType].positions;
          positions.forEach(pos => {
            const player = teamPlayers.find(p => p.position === pos);
            if (player) newLineup[pos] = player.name;
          });
          return { 
            ...state, 
            teamName: action.payload.team,
            lineup: newLineup,
            pendingLineup: null,
            pendingGameType: null
          };
        
        case 'SET_LINEUP':
          // If game has started (shots exist), set as pending change
          if (state.shots.length > 0) {
            return { 
              ...state, 
              pendingLineup: { 
                ...(state.pendingLineup || state.lineup), 
                [action.payload.position]: action.payload.player 
              } 
            };
          }
          return { ...state, lineup: { ...state.lineup, [action.payload.position]: action.payload.player } };
        
        case 'APPLY_LINEUP_CHANGES':
          return { 
            ...state, 
            gameType: state.pendingGameType || state.gameType,
            lineup: state.pendingLineup || state.lineup,
            pendingLineup: null,
            pendingGameType: null
          };
        
        case 'CANCEL_LINEUP_CHANGES':
          return { ...state, pendingLineup: null, pendingGameType: null };
        
        case 'SET_FIELD':
          return { ...state, [action.payload.field]: action.payload.value };
        
        case 'START_GAME':
          // If numLSDs > 0, go to LSD phase first
          if (state.numLSDs > 0) {
            return {
              ...state,
              activeTab: "tracking",
              lsdPhase: true,
              currentLSD: 1,
              currentThrower: state.teamName,
              currentTeamShot: 1
            };
          }
          // For Both Teams mode, first thrower is the team WITHOUT hammer
          const firstThrower = state.statOptions === "Both Teams" 
            ? (state.firstEndHammer === state.teamName ? state.opponent : state.teamName)
            : state.teamName;
          return { 
            ...state, 
            activeTab: "tracking", 
            currentHammer: state.firstEndHammer,
            currentThrower: firstThrower,
            currentTeamShot: 1
          };
        
        case 'SET_FIRST_END_HAMMER':
          // Set hammer after LSD phase or from popup
          const hammerTeam = action.payload;
          const startThrower = state.statOptions === "Both Teams" 
            ? (hammerTeam === state.teamName ? state.opponent : state.teamName)
            : state.teamName;
          return {
            ...state,
            firstEndHammer: hammerTeam,
            currentHammer: hammerTeam,
            currentThrower: startThrower,
            lsdPhase: false,
            currentLSD: 0
          };
        
        case 'LOG_LSD':
          // Log an LSD shot
          const lsdShot = {
            ...action.payload,
            isLSD: true,
            lsdNumber: state.currentLSD
          };
          const shotsWithLSD = [...state.shots, lsdShot];
          
          // Check if we need another LSD
          if (state.currentLSD < state.numLSDs) {
            return {
              ...state,
              shots: shotsWithLSD,
              currentLSD: state.currentLSD + 1,
              lastIceCondition: action.payload.drawWeight || state.lastIceCondition
            };
          }
          
          // LSD phase complete but hammer not yet set - stay in phase waiting for hammer selection
          return {
            ...state,
            shots: shotsWithLSD,
            lastIceCondition: action.payload.drawWeight || state.lastIceCondition
          };
        
        case 'LOG_SHOT':
          const newShots = [...state.shots, action.payload];
          const teamMaxShots = POSITION_MAP[state.gameType].maxShots;
          // Opponent is always 4 Person (8 shots) unless Mixed Doubles
          const oppGameType = state.gameType === "Mixed Doubles" ? "Mixed Doubles" : "4 Person";
          const opponentMaxShots = POSITION_MAP[oppGameType].maxShots;
          
          let nextEnd = state.currentEnd;
          let nextShot = state.currentShot + 1;
          let nextHammer = state.currentHammer;
          let nextThrower = state.currentThrower;
          let nextTeamShot = state.currentTeamShot;
          
          if (state.statOptions === "Both Teams") {
            // In Both Teams mode, total shots per end combines both teams' shots
            const totalShotsPerEnd = teamMaxShots + opponentMaxShots;
            
            if (state.currentShot === totalShotsPerEnd) {
              // End completed
              if (action.payload.score) {
                const [teamScore, oppScore] = action.payload.score.split('-').map(Number);
                if (teamScore > oppScore) {
                  nextHammer = state.opponent;
                } else if (oppScore > teamScore) {
                  nextHammer = state.teamName;
                }
              }
              nextEnd = state.currentEnd + 1;
              nextShot = 1;
              nextTeamShot = 1;
              // First thrower of new end is team WITHOUT hammer
              nextThrower = nextHammer === state.teamName ? state.opponent : state.teamName;
            } else {
              // Alternate between teams after each shot
              nextThrower = state.currentThrower === state.teamName ? state.opponent : state.teamName;
              // Increment team shot number when switching back to a team
              if (nextThrower === action.payload.throwingTeam) {
                // Same team throwing again means we incremented wrongly, keep same
              } else if (state.currentShot % 2 === 0) {
                // After every 2 shots (one from each team), increment team shot counters
                nextTeamShot = Math.floor(state.currentShot / 2) + 1;
              } else {
                nextTeamShot = Math.floor(state.currentShot / 2) + 1;
              }
            }
          } else {
            // Single Team mode - original logic
            if (state.currentShot === teamMaxShots) {
              // End completed
              if (action.payload.score) {
                const [teamScore, oppScore] = action.payload.score.split('-').map(Number);
                if (teamScore > oppScore) {
                  nextHammer = state.opponent;
                } else if (oppScore > teamScore) {
                  nextHammer = state.teamName;
                }
              }
              nextEnd = state.currentEnd + 1;
              nextShot = 1;
            }
          }
          
          return {
            ...state,
            shots: newShots,
            currentEnd: nextEnd,
            currentShot: nextShot,
            currentHammer: nextHammer,
            currentThrower: nextThrower,
            currentTeamShot: nextTeamShot,
            lastIceCondition: action.payload.drawWeight || state.lastIceCondition
          };
        
        case 'UNDO_SHOT':
          if (state.shots.length === 0) return state;
          const prevShots = state.shots.slice(0, -1);
          const lastShot = state.shots[state.shots.length - 1];
          return {
            ...state,
            shots: prevShots,
            currentEnd: lastShot.end,
            currentShot: lastShot.shotNumber,
            currentHammer: lastShot.hammer,
            currentThrower: lastShot.throwingTeam || state.teamName,
            currentTeamShot: lastShot.teamShotNumber || lastShot.shotNumber
          };
        
        case 'UPDATE_SCORE':
          // Update score for a specific end
          return {
            ...state,
            shots: state.shots.map(shot => {
              if (shot.end === action.payload.end && shot.shotNumber === POSITION_MAP[state.gameType].maxShots) {
                return { ...shot, score: action.payload.score };
              }
              return shot;
            })
          };
        
        case 'UPDATE_SHOT':
          // Update a specific shot by index
          return {
            ...state,
            shots: state.shots.map((shot, idx) => 
              idx === action.payload.index ? { ...shot, ...action.payload.updates } : shot
            )
          };
        
        case 'END_GAME':
          return { ...state, gameEnded: true, activeTab: "analytics" };
        
        case 'NEW_GAME':
          return { ...initialGameState };
        
        case 'SET_TAB':
          return { ...state, activeTab: action.payload };
        
        case 'LOAD_STATE':
          return { ...state, ...action.payload };
        
        default:
          return state;
      }
    }

    // ============================================
    // CONTEXT
    // ============================================
    
    const GameContext = createContext();

    // ============================================
    // STYLES (CSS-in-JS)
    // ============================================
    
    const styles = {
      app: {
        minHeight: '100vh',
        display: 'flex',
        flexDirection: 'column'
      },
      header: {
        background: 'linear-gradient(135deg, var(--secondary) 0%, var(--accent) 100%)',
        color: 'white',
        padding: '16px 24px',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'space-between',
        boxShadow: 'var(--shadow-lg)',
        position: 'sticky',
        top: 0,
        zIndex: 100
      },
      logo: {
        fontFamily: "'Bebas Neue', sans-serif",
        fontSize: '28px',
        letterSpacing: '2px',
        display: 'flex',
        alignItems: 'center',
        gap: '12px'
      },
      logoIcon: {
        height: '40px',
        width: 'auto'
      },
      tabs: {
        display: 'flex',
        gap: '4px',
        background: 'rgba(255,255,255,0.1)',
        padding: '4px',
        borderRadius: 'var(--radius)'
      },
      tab: {
        padding: '8px 20px',
        border: 'none',
        background: 'transparent',
        color: 'rgba(255,255,255,0.7)',
        cursor: 'pointer',
        borderRadius: 'var(--radius-sm)',
        fontWeight: '600',
        fontSize: '14px',
        transition: 'all 0.2s'
      },
      tabActive: {
        background: 'white',
        color: 'var(--secondary)'
      },
      main: {
        flex: 1,
        padding: '24px',
        maxWidth: '1200px',
        margin: '0 auto',
        width: '100%'
      },
      card: {
        background: 'white',
        borderRadius: 'var(--radius)',
        boxShadow: 'var(--shadow)',
        padding: '24px',
        marginBottom: '20px'
      },
      cardTitle: {
        fontFamily: "'Bebas Neue', sans-serif",
        fontSize: '22px',
        letterSpacing: '1px',
        color: 'var(--secondary)',
        marginBottom: '20px',
        paddingBottom: '12px',
        borderBottom: '2px solid var(--ice)'
      },
      grid: {
        display: 'grid',
        gap: '16px'
      },
      grid2: {
        gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))'
      },
      grid3: {
        gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))'
      },
      grid4: {
        gridTemplateColumns: 'repeat(auto-fit, minmax(140px, 1fr))'
      },
      formGroup: {
        display: 'flex',
        flexDirection: 'column',
        gap: '6px'
      },
      label: {
        fontSize: '13px',
        fontWeight: '600',
        color: 'var(--text-light)',
        textTransform: 'uppercase',
        letterSpacing: '0.5px'
      },
      input: {
        padding: '12px 14px',
        border: '2px solid var(--ice)',
        borderRadius: 'var(--radius-sm)',
        fontSize: '15px',
        transition: 'all 0.2s',
        outline: 'none',
        width: '100%'
      },
      select: {
        padding: '12px 14px',
        border: '2px solid var(--ice)',
        borderRadius: 'var(--radius-sm)',
        fontSize: '15px',
        background: 'white',
        cursor: 'pointer',
        outline: 'none',
        width: '100%'
      },
      button: {
        padding: '14px 28px',
        border: 'none',
        borderRadius: 'var(--radius-sm)',
        fontSize: '15px',
        fontWeight: '600',
        cursor: 'pointer',
        transition: 'all 0.2s',
        display: 'inline-flex',
        alignItems: 'center',
        justifyContent: 'center',
        gap: '8px'
      },
      buttonPrimary: {
        background: 'var(--primary)',
        color: 'white'
      },
      buttonSecondary: {
        background: 'var(--secondary)',
        color: 'white'
      },
      buttonSuccess: {
        background: 'var(--success)',
        color: 'white'
      },
      buttonWarning: {
        background: 'var(--warning)',
        color: 'var(--text)'
      },
      buttonOutline: {
        background: 'transparent',
        border: '2px solid var(--ice-dark)',
        color: 'var(--text)'
      },
      radioGroup: {
        display: 'flex',
        gap: '8px',
        flexWrap: 'wrap'
      },
      radioButton: {
        padding: '10px 18px',
        border: '2px solid var(--ice)',
        borderRadius: 'var(--radius-sm)',
        background: 'white',
        cursor: 'pointer',
        fontSize: '14px',
        fontWeight: '500',
        transition: 'all 0.2s'
      },
      radioButtonActive: {
        borderColor: 'var(--primary)',
        background: 'var(--primary)',
        color: 'white'
      },
      shotCounter: {
        background: 'linear-gradient(135deg, var(--secondary) 0%, var(--accent) 100%)',
        color: 'white',
        padding: '16px 24px',
        borderRadius: 'var(--radius)',
        display: 'flex',
        justifyContent: 'space-between',
        alignItems: 'center',
        marginBottom: '20px'
      },
      shotCounterText: {
        fontFamily: "'Bebas Neue', sans-serif",
        fontSize: '24px',
        letterSpacing: '1px'
      },
      hammerBadge: {
        background: 'var(--gold)',
        color: 'var(--text)',
        padding: '6px 14px',
        borderRadius: '20px',
        fontSize: '13px',
        fontWeight: '600'
      },
      scoreInputs: {
        background: 'var(--ice)',
        padding: '20px',
        borderRadius: 'var(--radius)',
        marginTop: '20px'
      },
      table: {
        width: '100%',
        borderCollapse: 'collapse',
        fontSize: '14px'
      },
      th: {
        background: 'var(--secondary)',
        color: 'white',
        padding: '12px',
        textAlign: 'left',
        fontWeight: '600'
      },
      td: {
        padding: '12px',
        borderBottom: '1px solid var(--ice)'
      },
      notification: {
        position: 'fixed',
        bottom: '24px',
        right: '24px',
        padding: '16px 24px',
        borderRadius: 'var(--radius)',
        color: 'white',
        fontWeight: '500',
        boxShadow: 'var(--shadow-lg)',
        animation: 'slideIn 0.3s ease',
        zIndex: 1000
      },
      modal: {
        position: 'fixed',
        top: 0,
        left: 0,
        right: 0,
        bottom: 0,
        background: 'rgba(0,0,0,0.5)',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
        zIndex: 1000,
        padding: '20px'
      },
      modalContent: {
        background: 'white',
        borderRadius: 'var(--radius)',
        padding: '32px',
        maxWidth: '400px',
        width: '100%',
        textAlign: 'center'
      }
    };

    // ============================================
    // COMPONENTS
    // ============================================

    // Notification Component
    function Notification({ message, type, onClose }) {
      useEffect(() => {
        const timer = setTimeout(onClose, 3000);
        return () => clearTimeout(timer);
      }, [onClose]);

      const bgColor = type === 'success' ? 'var(--success)' : 
                      type === 'error' ? 'var(--primary)' : 'var(--secondary)';

      return (
        <div style={{ ...styles.notification, background: bgColor }}>
          {message}
        </div>
      );
    }

    // Confirmation Modal
    function ConfirmModal({ title, message, onConfirm, onCancel }) {
      return (
        <div style={styles.modal}>
          <div style={styles.modalContent}>
            <h3 style={{ marginBottom: '12px', color: 'var(--secondary)' }}>{title}</h3>
            <p style={{ marginBottom: '24px', color: 'var(--text-light)' }}>{message}</p>
            <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
              <button 
                style={{ ...styles.button, ...styles.buttonOutline }}
                onClick={onCancel}
              >
                Cancel
              </button>
              <button 
                style={{ ...styles.button, ...styles.buttonPrimary }}
                onClick={onConfirm}
              >
                Confirm
              </button>
            </div>
          </div>
        </div>
      );
    }

    // Header Component
    function Header({ activeTab, onTabChange, gameStarted, gameEnded, onHome }) {
      const tabs = gameStarted 
        ? (gameEnded 
            ? [
                { id: 'analytics', label: 'Analytics' },
                { id: 'editor', label: 'Editor' }
              ]
            : [
                { id: 'tracking', label: 'Tracking' },
                { id: 'analytics', label: 'Analytics' },
                { id: 'editor', label: 'Editor' }
              ]
          )
        : [{ id: 'setup', label: 'Setup' }];

      return (
        <header style={styles.header}>
          <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
            {onHome && (
              <button
                onClick={onHome}
                style={{
                  background: 'rgba(255,255,255,0.2)',
                  border: 'none',
                  borderRadius: 'var(--radius-sm)',
                  padding: '8px 12px',
                  cursor: 'pointer',
                  fontSize: '18px',
                  display: 'flex',
                  alignItems: 'center',
                  color: 'white'
                }}
                title="Back to Home"
              >
                üè†
              </button>
            )}
            <div style={styles.logo}>
              <img src="usa_curling_logo.png" alt="USA Curling" style={styles.logoIcon} />
              USA CURLING SHOT TRACKER
            </div>
          </div>
          <div style={styles.tabs}>
            {tabs.map(tab => (
              <button
                key={tab.id}
                style={{
                  ...styles.tab,
                  ...(activeTab === tab.id ? styles.tabActive : {})
                }}
                onClick={() => onTabChange(tab.id)}
              >
                {tab.label}
              </button>
            ))}
          </div>
        </header>
      );
    }

    // Setup Panel Component (for initial game setup before game starts)
    function SetupPanel({ state, dispatch, onStartGame, onNotify }) {
      const { gameType, totalEnds, statOptions, statMode, teamName, opponent, firstEndHammer, numLSDs, competitionId, competition, compRound, gameDate, lineup } = state;
      const [showHammerPopup, setShowHammerPopup] = useState(false);
      const [competitions, setCompetitions] = useState([]);
      const [showNewCompModal, setShowNewCompModal] = useState(false);
      const [newCompName, setNewCompName] = useState('');
      
      const teams = gameType === "Mixed Doubles" ? MD_TEAMS : TEAMS;
      const positions = POSITION_MAP[gameType].positions;
      
      // Load competitions on mount
      useEffect(() => {
        const loadComps = async () => {
          try {
            const comps = await CompetitionDB.getAll();
            setCompetitions(comps.sort((a, b) => new Date(b.dateCreated) - new Date(a.dateCreated)));
            
            // Auto-select last used competition if not already set
            if (!competitionId) {
              const lastCompId = Storage.get('lastCompetitionId');
              if (lastCompId) {
                const lastComp = comps.find(c => c.id === lastCompId);
                if (lastComp) {
                  dispatch({ type: 'SET_FIELD', payload: { field: 'competitionId', value: lastComp.id } });
                  dispatch({ type: 'SET_FIELD', payload: { field: 'competition', value: lastComp.name } });
                }
              }
            }
          } catch (e) {
            console.error('Failed to load competitions:', e);
          }
        };
        loadComps();
      }, []);

      const handleCreateCompetition = async () => {
        if (!newCompName.trim()) return;
        try {
          const newComp = await CompetitionDB.createCompetition(newCompName.trim());
          setCompetitions(prev => [newComp, ...prev]);
          dispatch({ type: 'SET_FIELD', payload: { field: 'competitionId', value: newComp.id } });
          dispatch({ type: 'SET_FIELD', payload: { field: 'competition', value: newComp.name } });
          Storage.set('lastCompetitionId', newComp.id);
          setNewCompName('');
          setShowNewCompModal(false);
          onNotify(`Competition "${newComp.name}" created!`, 'success');
        } catch (e) {
          console.error('Failed to create competition:', e);
          onNotify('Failed to create competition', 'error');
        }
      };

      const handleCompetitionChange = (compId) => {
        const comp = competitions.find(c => c.id === compId);
        dispatch({ type: 'SET_FIELD', payload: { field: 'competitionId', value: compId } });
        dispatch({ type: 'SET_FIELD', payload: { field: 'competition', value: comp?.name || '' } });
        if (compId) Storage.set('lastCompetitionId', compId);
      };
      
      const teamPlayers = useMemo(() => {
        if (!teamName) return [];
        return PLAYER_DATA.filter(p => 
          gameType === "Mixed Doubles" ? p.mdTeam === teamName : p.team === teamName
        ).map(p => p.name).sort();
      }, [teamName, gameType]);

      // Hammer options depend on team and opponent being filled
      const hammerOptions = useMemo(() => {
        const options = [];
        if (teamName) options.push(teamName);
        if (opponent) options.push(opponent);
        return options;
      }, [teamName, opponent]);

      const canStart = teamName && opponent && competitionId &&
                       positions.every(pos => lineup[pos]);

      const handleStartGame = () => {
        if (numLSDs === 0) {
          // Show popup to select hammer
          setShowHammerPopup(true);
        } else {
          // Go to LSD phase
          onStartGame();
        }
      };

      const handleHammerSelect = (team) => {
        dispatch({ type: 'SET_FIRST_END_HAMMER', payload: team });
        setShowHammerPopup(false);
        onStartGame();
      };

      return (
        <div>
          {/* Game Type, Ends, Tracking Options, and Stat Options - Side by Side */}
          <div style={{ display: 'flex', gap: '20px', flexWrap: 'wrap' }}>
            <div style={{ ...styles.card, flex: '1 1 30%', minWidth: '240px' }}>
              <h2 style={styles.cardTitle}>GAME TYPE</h2>
              <div style={styles.radioGroup}>
                {["4 Person", "3 Person", "Mixed Doubles"].map(type => (
                  <button
                    key={type}
                    style={{
                      ...styles.radioButton,
                      ...(gameType === type ? styles.radioButtonActive : {})
                    }}
                    onClick={() => dispatch({ type: 'SET_GAME_TYPE', payload: type })}
                  >
                    {type}
                  </button>
                ))}
              </div>
            </div>

            <div style={{ ...styles.card, flex: '0 1 auto', minWidth: '100px' }}>
              <h2 style={styles.cardTitle}>ENDS</h2>
              <div style={styles.radioGroup}>
                {[8, 10].map(ends => (
                  <button
                    key={ends}
                    style={{
                      ...styles.radioButton,
                      ...(totalEnds === ends ? styles.radioButtonActive : {})
                    }}
                    onClick={() => dispatch({ type: 'SET_FIELD', payload: { field: 'totalEnds', value: ends } })}
                  >
                    {ends}
                  </button>
                ))}
              </div>
            </div>

            <div style={{ ...styles.card, flex: '1 1 20%', minWidth: '160px' }}>
              <h2 style={styles.cardTitle}>TRACKING OPTIONS</h2>
              <div style={styles.radioGroup}>
                {["Single Team", "Both Teams"].map(option => (
                  <button
                    key={option}
                    style={{
                      ...styles.radioButton,
                      ...(statOptions === option ? styles.radioButtonActive : {})
                    }}
                    onClick={() => dispatch({ type: 'SET_FIELD', payload: { field: 'statOptions', value: option } })}
                  >
                    {option}
                  </button>
                ))}
              </div>
            </div>

            <div style={{ ...styles.card, flex: '1 1 20%', minWidth: '140px' }}>
              <h2 style={styles.cardTitle}>STAT OPTIONS</h2>
              <div style={styles.radioGroup}>
                {["Simple", "Advanced"].map(option => (
                  <button
                    key={option}
                    style={{
                      ...styles.radioButton,
                      ...(statMode === option ? styles.radioButtonActive : {})
                    }}
                    onClick={() => dispatch({ type: 'SET_FIELD', payload: { field: 'statMode', value: option } })}
                  >
                    {option}
                  </button>
                ))}
              </div>
            </div>
          </div>

          <div style={styles.card}>
            <h2 style={styles.cardTitle}>TEAM SETUP</h2>
            <div style={{ ...styles.grid, ...styles.grid2 }}>
              <div style={styles.formGroup}>
                <label style={styles.label}>Team</label>
                <select
                  style={styles.select}
                  value={teamName}
                  onChange={(e) => dispatch({ 
                    type: 'SET_TEAM', 
                    payload: { team: e.target.value, gameType } 
                  })}
                >
                  <option value="">Select Team...</option>
                  {teams.map(t => <option key={t} value={t}>{t}</option>)}
                </select>
              </div>
              
              {positions.map(pos => (
                <div key={pos} style={styles.formGroup}>
                  <label style={styles.label}>{pos}</label>
                  <select
                    style={styles.select}
                    value={lineup[pos] || ""}
                    onChange={(e) => dispatch({ 
                      type: 'SET_LINEUP', 
                      payload: { position: pos, player: e.target.value } 
                    })}
                    disabled={!teamName}
                  >
                    <option value="">Select Player...</option>
                    {teamPlayers.map(p => <option key={p} value={p}>{p}</option>)}
                  </select>
                </div>
              ))}
            </div>
          </div>

          <div style={styles.card}>
            <h2 style={styles.cardTitle}>GAME DETAILS</h2>
            <div style={{ ...styles.grid, ...styles.grid2 }}>
              <div style={styles.formGroup}>
                <label style={styles.label}>Opponent</label>
                <input
                  style={styles.input}
                  type="text"
                  value={opponent}
                  onChange={(e) => dispatch({ 
                    type: 'SET_FIELD', 
                    payload: { field: 'opponent', value: e.target.value } 
                  })}
                  placeholder="Enter opponent name..."
                />
              </div>

              <div style={styles.formGroup}>
                <label style={styles.label}>Number of LSD's</label>
                <select
                  style={styles.select}
                  value={numLSDs}
                  onChange={(e) => dispatch({ 
                    type: 'SET_FIELD', 
                    payload: { field: 'numLSDs', value: parseInt(e.target.value) } 
                  })}
                >
                  <option value={0}>0</option>
                  <option value={1}>1</option>
                  <option value={2}>2</option>
                </select>
              </div>
              
              <div style={styles.formGroup}>
                <label style={styles.label}>Competition</label>
                <div style={{ display: 'flex', gap: '8px' }}>
                  <select
                    style={{ ...styles.select, flex: 1 }}
                    value={competitionId}
                    onChange={(e) => handleCompetitionChange(e.target.value)}
                  >
                    <option value="">Select Competition...</option>
                    {competitions.map(c => (
                      <option key={c.id} value={c.id}>{c.name}</option>
                    ))}
                  </select>
                  <button
                    onClick={() => setShowNewCompModal(true)}
                    style={{ ...styles.button, ...styles.buttonPrimary, padding: '8px 12px', fontSize: '14px' }}
                    title="Create new competition"
                  >
                    +
                  </button>
                </div>
              </div>
              
              <div style={styles.formGroup}>
                <label style={styles.label}>Round</label>
                <select
                  style={styles.select}
                  value={compRound}
                  onChange={(e) => dispatch({ 
                    type: 'SET_FIELD', 
                    payload: { field: 'compRound', value: e.target.value } 
                  })}
                >
                  {COMP_ROUNDS.map(r => <option key={r} value={r}>{r}</option>)}
                </select>
              </div>
              
              <div style={styles.formGroup}>
                <label style={styles.label}>Date</label>
                <input
                  style={styles.input}
                  type="date"
                  value={gameDate}
                  onChange={(e) => dispatch({ 
                    type: 'SET_FIELD', 
                    payload: { field: 'gameDate', value: e.target.value } 
                  })}
                />
              </div>
            </div>
          </div>

          <div style={{ textAlign: 'center', marginTop: '24px' }}>
            <button
              style={{ 
                ...styles.button, 
                ...styles.buttonSuccess,
                padding: '16px 48px',
                fontSize: '18px',
                opacity: canStart ? 1 : 0.5
              }}
              onClick={handleStartGame}
              disabled={!canStart}
            >
              ü•å Start Game
            </button>
          </div>

          {/* Hammer Selection Popup (for 0 LSDs) */}
          {showHammerPopup && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.5)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1000
            }}>
              <div style={{
                background: 'white',
                padding: '32px',
                borderRadius: 'var(--radius)',
                maxWidth: '400px',
                width: '90%',
                boxShadow: '0 10px 40px rgba(0,0,0,0.2)'
              }}>
                <h3 style={{ marginTop: 0, color: 'var(--secondary)', textAlign: 'center' }}>
                  Who has hammer in the First End?
                </h3>
                <div style={{ display: 'flex', gap: '12px', marginTop: '24px' }}>
                  <button
                    onClick={() => handleHammerSelect(teamName)}
                    style={{
                      ...styles.button,
                      ...styles.buttonPrimary,
                      flex: 1,
                      padding: '16px'
                    }}
                  >
                    {teamName}
                  </button>
                  <button
                    onClick={() => handleHammerSelect(opponent)}
                    style={{
                      ...styles.button,
                      ...styles.buttonSecondary,
                      flex: 1,
                      padding: '16px'
                    }}
                  >
                    {opponent}
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* New Competition Modal */}
          {showNewCompModal && (
            <div style={{
              position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
              background: 'rgba(0,0,0,0.5)', display: 'flex',
              alignItems: 'center', justifyContent: 'center', zIndex: 1000
            }}>
              <div style={{
                background: 'white', padding: '32px', borderRadius: 'var(--radius)',
                maxWidth: '400px', width: '90%'
              }}>
                <h3 style={{ marginTop: 0 }}>Create New Competition</h3>
                <div style={styles.formGroup}>
                  <label style={styles.label}>Competition Name</label>
                  <input
                    style={styles.input}
                    value={newCompName}
                    onChange={(e) => setNewCompName(e.target.value)}
                    placeholder="e.g., 2025 US Nationals"
                    autoFocus
                  />
                </div>
                <div style={{ display: 'flex', gap: '12px', marginTop: '24px' }}>
                  <button
                    onClick={() => { setShowNewCompModal(false); setNewCompName(''); }}
                    style={{ ...styles.button, background: '#d1d5db', color: 'var(--text)', flex: 1 }}
                  >
                    Cancel
                  </button>
                  <button
                    onClick={handleCreateCompetition}
                    style={{ ...styles.button, ...styles.buttonPrimary, flex: 1 }}
                  >
                    Create
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    // Editor Panel Component (after game has started)
    function EditorPanel({ state, dispatch, onNotify }) {
      const [activeSubTab, setActiveSubTab] = useState('gameSettings');
      
      const subTabStyle = (isActive) => ({
        padding: '10px 20px',
        border: 'none',
        background: isActive ? 'var(--primary)' : 'var(--ice)',
        color: isActive ? 'white' : 'var(--text)',
        cursor: 'pointer',
        borderRadius: 'var(--radius-sm)',
        fontWeight: '600',
        fontSize: '14px',
        transition: 'all 0.2s'
      });

      return (
        <div>
          {/* Sub-tab navigation */}
          <div style={{ 
            display: 'flex', 
            gap: '8px', 
            marginBottom: '24px',
            background: 'white',
            padding: '8px',
            borderRadius: 'var(--radius)',
            boxShadow: 'var(--shadow)'
          }}>
            <button 
              style={subTabStyle(activeSubTab === 'gameSettings')}
              onClick={() => setActiveSubTab('gameSettings')}
            >
              Game Settings
            </button>
            <button 
              style={subTabStyle(activeSubTab === 'score')}
              onClick={() => setActiveSubTab('score')}
            >
              Score
            </button>
            <button 
              style={subTabStyle(activeSubTab === 'shots')}
              onClick={() => setActiveSubTab('shots')}
            >
              Shots
            </button>
          </div>

          {activeSubTab === 'gameSettings' && (
            <GameSettingsSubTab state={state} dispatch={dispatch} onNotify={onNotify} />
          )}
          {activeSubTab === 'score' && (
            <ScoreEditorSubTab state={state} dispatch={dispatch} onNotify={onNotify} />
          )}
          {activeSubTab === 'shots' && (
            <ShotsEditorSubTab state={state} dispatch={dispatch} onNotify={onNotify} />
          )}
        </div>
      );
    }

    // Game Settings Sub-Tab
    function GameSettingsSubTab({ state, dispatch, onNotify }) {
      const { gameType, teamName, opponent, firstEndHammer, numLSDs, competition, compRound, gameDate, lineup, pendingLineup, pendingGameType, shots } = state;
      
      // Only show 4/3 Person options if current game is one of those (not Mixed Doubles)
      const availableGameTypes = gameType === "Mixed Doubles" 
        ? ["Mixed Doubles"] 
        : ["4 Person", "3 Person"];
      
      // Use pending values if they exist
      const displayGameType = pendingGameType || gameType;
      const teams = displayGameType === "Mixed Doubles" ? MD_TEAMS : TEAMS;
      const positions = POSITION_MAP[displayGameType].positions;
      
      const teamPlayers = useMemo(() => {
        if (!teamName) return [];
        return PLAYER_DATA.filter(p => 
          displayGameType === "Mixed Doubles" ? p.mdTeam === teamName : p.team === teamName
        ).map(p => p.name).sort();
      }, [teamName, displayGameType]);

      const hammerOptions = useMemo(() => {
        const options = [];
        if (teamName) options.push(teamName);
        if (opponent) options.push(opponent);
        return options;
      }, [teamName, opponent]);

      const hasPendingChanges = pendingLineup !== null || pendingGameType !== null;
      const displayLineup = pendingLineup || lineup;

      const handleGameTypeChange = (newType) => {
        if (newType !== gameType) {
          dispatch({ type: 'SET_GAME_TYPE', payload: newType });
        }
      };

      const handleApplyChanges = () => {
        dispatch({ type: 'APPLY_LINEUP_CHANGES' });
        onNotify("Changes applied!", "success");
      };

      const handleCancelChanges = () => {
        dispatch({ type: 'CANCEL_LINEUP_CHANGES' });
        onNotify("Changes cancelled", "info");
      };

      return (
        <div>
          <div style={styles.card}>
            <h2 style={styles.cardTitle}>GAME TYPE</h2>
            {hasPendingChanges && pendingGameType && (
              <div style={{ 
                background: 'var(--warning)', 
                padding: '12px', 
                borderRadius: 'var(--radius-sm)',
                marginBottom: '16px',
                color: 'var(--text)'
              }}>
                ‚ö†Ô∏è Game type change pending. Click "Apply Changes" to confirm or "Cancel" to revert.
              </div>
            )}
            <div style={styles.radioGroup}>
              {availableGameTypes.map(type => (
                <button
                  key={type}
                  style={{
                    ...styles.radioButton,
                    ...(displayGameType === type ? styles.radioButtonActive : {}),
                    ...(pendingGameType === type && type !== gameType 
                      ? { borderColor: 'var(--warning)', borderWidth: '2px' } 
                      : {})
                  }}
                  onClick={() => handleGameTypeChange(type)}
                >
                  {type}
                </button>
              ))}
            </div>
            {gameType !== "Mixed Doubles" && (
              <p style={{ fontSize: '12px', color: 'var(--text-light)', marginTop: '8px' }}>
                Switch between 4 Person and 3 Person if team composition changes during game.
              </p>
            )}
          </div>

          <div style={styles.card}>
            <h2 style={styles.cardTitle}>TEAM LINEUP</h2>
            {hasPendingChanges && !pendingGameType && (
              <div style={{ 
                background: 'var(--warning)', 
                padding: '12px', 
                borderRadius: 'var(--radius-sm)',
                marginBottom: '16px',
                color: 'var(--text)'
              }}>
                ‚ö†Ô∏è You have pending lineup changes. Click "Apply Changes" to confirm or "Cancel" to revert.
              </div>
            )}
            <div style={{ ...styles.grid, ...styles.grid2 }}>
              <div style={styles.formGroup}>
                <label style={styles.label}>Team</label>
                <select
                  style={{ ...styles.select, opacity: 0.7 }}
                  value={teamName}
                  disabled={true}
                >
                  <option value={teamName}>{teamName}</option>
                </select>
              </div>
              
              {positions.map(pos => (
                <div key={pos} style={styles.formGroup}>
                  <label style={styles.label}>{pos}</label>
                  <select
                    style={{
                      ...styles.select,
                      ...(hasPendingChanges && displayLineup[pos] !== lineup[pos] 
                        ? { borderColor: 'var(--warning)', borderWidth: '2px' } 
                        : {})
                    }}
                    value={displayLineup[pos] || ""}
                    onChange={(e) => dispatch({ 
                      type: 'SET_LINEUP', 
                      payload: { position: pos, player: e.target.value } 
                    })}
                  >
                    <option value="">Select Player...</option>
                    {teamPlayers.map(p => <option key={p} value={p}>{p}</option>)}
                  </select>
                </div>
              ))}
            </div>

            {hasPendingChanges && (
              <div style={{ display: 'flex', gap: '12px', marginTop: '20px', justifyContent: 'center' }}>
                <button
                  style={{ ...styles.button, ...styles.buttonSuccess }}
                  onClick={handleApplyChanges}
                >
                  Apply Changes
                </button>
                <button
                  style={{ ...styles.button, ...styles.buttonOutline }}
                  onClick={handleCancelChanges}
                >
                  Cancel
                </button>
              </div>
            )}
          </div>

          <div style={styles.card}>
            <h2 style={styles.cardTitle}>GAME DETAILS</h2>
            <div style={{ ...styles.grid, ...styles.grid2 }}>
              <div style={styles.formGroup}>
                <label style={styles.label}>Opponent</label>
                <input
                  style={styles.input}
                  type="text"
                  value={opponent}
                  onChange={(e) => dispatch({ 
                    type: 'SET_FIELD', 
                    payload: { field: 'opponent', value: e.target.value } 
                  })}
                />
              </div>

              <div style={styles.formGroup}>
                <label style={styles.label}>Number of LSD's</label>
                <select
                  style={{ ...styles.select, ...(shots.length > 0 ? { opacity: 0.6, cursor: 'not-allowed' } : {}) }}
                  value={numLSDs}
                  onChange={(e) => dispatch({ 
                    type: 'SET_FIELD', 
                    payload: { field: 'numLSDs', value: parseInt(e.target.value) } 
                  })}
                  disabled={shots.length > 0}
                >
                  <option value={0}>0</option>
                  <option value={1}>1</option>
                  <option value={2}>2</option>
                </select>
                {shots.length > 0 && (
                  <div style={{ fontSize: '11px', color: 'var(--text-light)', marginTop: '4px' }}>
                    Cannot change after game started
                  </div>
                )}
              </div>
              
              <div style={styles.formGroup}>
                <label style={styles.label}>Competition</label>
                <input
                  style={styles.input}
                  type="text"
                  value={competition}
                  onChange={(e) => dispatch({ 
                    type: 'SET_FIELD', 
                    payload: { field: 'competition', value: e.target.value } 
                  })}
                />
              </div>
              
              <div style={styles.formGroup}>
                <label style={styles.label}>Round</label>
                <select
                  style={styles.select}
                  value={compRound}
                  onChange={(e) => dispatch({ 
                    type: 'SET_FIELD', 
                    payload: { field: 'compRound', value: e.target.value } 
                  })}
                >
                  {COMP_ROUNDS.map(r => <option key={r} value={r}>{r}</option>)}
                </select>
              </div>
              
              <div style={styles.formGroup}>
                <label style={styles.label}>Date</label>
                <input
                  style={styles.input}
                  type="date"
                  value={gameDate}
                  onChange={(e) => dispatch({ 
                    type: 'SET_FIELD', 
                    payload: { field: 'gameDate', value: e.target.value } 
                  })}
                />
              </div>
            </div>
          </div>
        </div>
      );
    }

    // Score Editor Sub-Tab
    function ScoreEditorSubTab({ state, dispatch, onNotify }) {
      const { shots, teamName, opponent, gameType } = state;
      const maxShots = POSITION_MAP[gameType].maxShots;
      
      const [editEnd, setEditEnd] = useState(1);
      const [editScore, setEditScore] = useState("");

      // Get unique ends with scores
      const endScores = useMemo(() => {
        const scores = {};
        shots.forEach(shot => {
          if (shot.score && shot.shotNumber === maxShots) {
            scores[shot.end] = shot.score;
          }
        });
        return Object.entries(scores)
          .map(([end, score]) => ({ end: parseInt(end), score }))
          .sort((a, b) => a.end - b.end);
      }, [shots, maxShots]);

      const handleUpdateScore = () => {
        if (!editScore.match(/^\d+-\d+$/)) {
          onNotify("Score must be in format: number-number (e.g., 2-0)", "error");
          return;
        }
        dispatch({ type: 'UPDATE_SCORE', payload: { end: editEnd, score: editScore } });
        onNotify(`Score for End ${editEnd} updated!`, "success");
        setEditScore("");
      };

      if (endScores.length === 0) {
        return (
          <div style={styles.card}>
            <p style={{ textAlign: 'center', color: 'var(--text-light)' }}>
              No completed ends yet. Scores will appear here after each end is finished.
            </p>
          </div>
        );
      }

      return (
        <div>
          <div style={styles.card}>
            <h2 style={styles.cardTitle}>CURRENT SCORES</h2>
            <div style={{ overflowX: 'auto' }}>
              <table style={styles.table}>
                <thead>
                  <tr>
                    <th style={styles.th}>End</th>
                    <th style={styles.th}>{teamName}</th>
                    <th style={styles.th}>{opponent}</th>
                  </tr>
                </thead>
                <tbody>
                  {endScores.map(({ end, score }) => {
                    const [teamScore, oppScore] = score.split('-');
                    return (
                      <tr key={end}>
                        <td style={styles.td}>{end}</td>
                        <td style={styles.td}>{teamScore}</td>
                        <td style={styles.td}>{oppScore}</td>
                      </tr>
                    );
                  })}
                  <tr style={{ fontWeight: 'bold', background: 'var(--ice)' }}>
                    <td style={styles.td}>Total</td>
                    <td style={styles.td}>
                      {endScores.reduce((sum, { score }) => sum + parseInt(score.split('-')[0]), 0)}
                    </td>
                    <td style={styles.td}>
                      {endScores.reduce((sum, { score }) => sum + parseInt(score.split('-')[1]), 0)}
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>

          <div style={styles.card}>
            <h2 style={styles.cardTitle}>EDIT SCORE</h2>
            <div style={{ ...styles.grid, gridTemplateColumns: '1fr 1fr auto' }}>
              <div style={styles.formGroup}>
                <label style={styles.label}>End</label>
                <select
                  style={styles.select}
                  value={editEnd}
                  onChange={(e) => setEditEnd(parseInt(e.target.value))}
                >
                  {endScores.map(({ end }) => (
                    <option key={end} value={end}>End {end}</option>
                  ))}
                </select>
              </div>
              <div style={styles.formGroup}>
                <label style={styles.label}>New Score (e.g., 2-0)</label>
                <input
                  style={styles.input}
                  type="text"
                  value={editScore}
                  onChange={(e) => setEditScore(e.target.value)}
                  placeholder="0-0"
                />
              </div>
              <div style={{ ...styles.formGroup, justifyContent: 'flex-end' }}>
                <button
                  style={{ ...styles.button, ...styles.buttonPrimary }}
                  onClick={handleUpdateScore}
                >
                  Update Score
                </button>
              </div>
            </div>
          </div>
        </div>
      );
    }

    // Shots Editor Sub-Tab
    function ShotsEditorSubTab({ state, dispatch, onNotify }) {
      const { shots, gameType, statMode } = state;
      const [editingIndex, setEditingIndex] = useState(null);
      const [editForm, setEditForm] = useState({});
      const [selectedEnd, setSelectedEnd] = useState("all");
      const isAdvancedMode = statMode === "Advanced";

      if (shots.length === 0) {
        return (
          <div style={styles.card}>
            <p style={{ textAlign: 'center', color: 'var(--text-light)' }}>
              No shots recorded yet.
            </p>
          </div>
        );
      }

      // Get unique ends from shots (include LSD as a separate option)
      const hasLSDs = shots.some(s => s.isLSD);
      const gameOnlyShots = shots.filter(s => !s.isLSD);
      const uniqueEnds = [...new Set(gameOnlyShots.map(s => s.end))].sort((a, b) => a - b);

      // Filter shots by selected end
      const filteredShots = selectedEnd === "all" 
        ? shots 
        : selectedEnd === "lsd"
        ? shots.filter(s => s.isLSD)
        : shots.filter(s => !s.isLSD && s.end === parseInt(selectedEnd));

      // Get the actual index in the full shots array for a filtered shot
      const getActualIndex = (filteredIndex) => {
        const shot = filteredShots[filteredIndex];
        return shots.findIndex(s => 
          s.isLSD === shot.isLSD &&
          (s.isLSD ? s.lsdNumber === shot.lsdNumber : (s.end === shot.end && s.shotNumber === shot.shotNumber && s.name === shot.name))
        );
      };

      const startEditing = (filteredIndex) => {
        const actualIndex = getActualIndex(filteredIndex);
        setEditingIndex(actualIndex);
        setEditForm({ ...shots[actualIndex] });
      };

      const cancelEditing = () => {
        setEditingIndex(null);
        setEditForm({});
      };

      const saveEdit = () => {
        dispatch({ type: 'UPDATE_SHOT', payload: { index: editingIndex, updates: editForm } });
        onNotify("Shot updated!", "success");
        setEditingIndex(null);
        setEditForm({});
      };

      const cellStyle = {
        ...styles.td,
        padding: '8px',
        fontSize: '13px',
        whiteSpace: 'nowrap'
      };

      const commentCellStyle = {
        ...styles.td,
        padding: '8px',
        fontSize: '13px',
        maxWidth: '150px',
        overflow: 'hidden',
        textOverflow: 'ellipsis',
        whiteSpace: 'nowrap'
      };

      const inputCellStyle = {
        padding: '4px',
        border: '1px solid var(--ice-dark)',
        borderRadius: '4px',
        fontSize: '12px',
        width: '100%',
        minWidth: '60px'
      };

      const TARGET_DIRECTIONS = ['Left', 'Center', 'Right'];
      const TARGET_DEPTHS = ['High Guard', 'Mid Guard', 'Tight Guard', 'Top 12', 'Top 8', 'Top 4', 'T-Line', 'Back 4', 'Back 8', 'Back 12'];

      return (
        <div style={styles.card}>
          <h2 style={styles.cardTitle}>SHOT LOG</h2>
          
          {/* End Filter */}
          <div style={{ marginBottom: '16px', display: 'flex', alignItems: 'center', gap: '12px' }}>
            <label style={{ ...styles.label, marginBottom: 0 }}>Filter by End:</label>
            <select
              style={{ ...styles.select, width: 'auto', minWidth: '120px' }}
              value={selectedEnd}
              onChange={(e) => setSelectedEnd(e.target.value)}
            >
              <option value="all">All</option>
              {hasLSDs && <option value="lsd">LSD</option>}
              {uniqueEnds.map(end => (
                <option key={end} value={end}>End {end}</option>
              ))}
            </select>
            <span style={{ fontSize: '13px', color: 'var(--text-light)' }}>
              Showing {filteredShots.length} shot{filteredShots.length !== 1 ? 's' : ''}
            </span>
          </div>

          <div style={{ overflowX: 'auto' }}>
            <table style={{ ...styles.table, fontSize: '13px' }}>
              <thead>
                <tr>
                  <th style={{ ...styles.th, padding: '8px' }}>End</th>
                  <th style={{ ...styles.th, padding: '8px' }}>Shot</th>
                  <th style={{ ...styles.th, padding: '8px' }}>Athlete</th>
                  <th style={{ ...styles.th, padding: '8px' }}>Turn</th>
                  <th style={{ ...styles.th, padding: '8px' }}>Shot Type</th>
                  <th style={{ ...styles.th, padding: '8px' }}>Outcome</th>
                  <th style={{ ...styles.th, padding: '8px' }}>Primary Miss</th>
                  <th style={{ ...styles.th, padding: '8px' }}>Secondary Miss</th>
                  {isAdvancedMode && (
                    <>
                      <th style={{ ...styles.th, padding: '8px' }}>Draw Wt</th>
                      <th style={{ ...styles.th, padding: '8px' }}>Direction</th>
                      <th style={{ ...styles.th, padding: '8px' }}>Depth</th>
                    </>
                  )}
                  <th style={{ ...styles.th, padding: '8px' }}>Weight</th>
                  <th style={{ ...styles.th, padding: '8px' }}>Key</th>
                  <th style={{ ...styles.th, padding: '8px' }}>Comments</th>
                  <th style={{ ...styles.th, padding: '8px' }}>Actions</th>
                </tr>
              </thead>
              <tbody>
                {filteredShots.map((shot, filteredIndex) => {
                  const actualIndex = getActualIndex(filteredIndex);
                  const isEditing = editingIndex === actualIndex;
                  const isLSD = shot.isLSD;
                  
                  return (
                    <tr key={isLSD ? `lsd-${shot.lsdNumber}` : `${shot.end}-${shot.shotNumber}`} style={{ background: filteredIndex % 2 === 0 ? 'white' : 'var(--ice)' }}>
                      {isEditing ? (
                        <>
                          <td style={cellStyle}>{isLSD ? 'LSD' : shot.end}</td>
                          <td style={cellStyle}>{isLSD ? shot.lsdNumber : shot.shotNumber}</td>
                          <td style={cellStyle}>
                            <input
                              style={{ ...inputCellStyle, minWidth: '80px' }}
                              type="text"
                              value={editForm.name || ""}
                              onChange={(e) => setEditForm({ ...editForm, name: e.target.value })}
                            />
                          </td>
                          <td style={cellStyle}>
                            <select
                              style={inputCellStyle}
                              value={editForm.turn || ''}
                              onChange={(e) => setEditForm({ ...editForm, turn: e.target.value })}
                            >
                              <option value="">---</option>
                              <option value="In-Turn">Clockwise</option>
                              <option value="Out-Turn">Counter Clockwise</option>
                            </select>
                          </td>
                          <td style={cellStyle}>
                            {isLSD ? 'LSD' : (
                              <select
                                style={inputCellStyle}
                                value={editForm.shotType || ''}
                                onChange={(e) => setEditForm({ ...editForm, shotType: e.target.value })}
                              >
                                <option value="">---</option>
                                {SHOT_TYPES.map(st => <option key={st} value={st}>{st}</option>)}
                              </select>
                            )}
                          </td>
                          <td style={cellStyle}>
                            <select
                              style={inputCellStyle}
                              value={editForm.outcome === null ? "" : editForm.outcome}
                              onChange={(e) => setEditForm({ ...editForm, outcome: e.target.value === "" ? null : parseInt(e.target.value) })}
                            >
                              <option value="">---</option>
                              <option value="0">0</option>
                              <option value="1">1</option>
                              <option value="2">2</option>
                              <option value="3">3</option>
                              <option value="4">4</option>
                            </select>
                          </td>
                          <td style={cellStyle}>
                            <select
                              style={inputCellStyle}
                              value={editForm.miss || ''}
                              onChange={(e) => setEditForm({ ...editForm, miss: e.target.value })}
                            >
                              <option value="">---</option>
                              {MISS_TYPES.map(mt => <option key={mt} value={mt}>{mt}</option>)}
                            </select>
                          </td>
                          <td style={cellStyle}>
                            <select
                              style={inputCellStyle}
                              value={editForm.secondaryMiss || ''}
                              onChange={(e) => setEditForm({ ...editForm, secondaryMiss: e.target.value })}
                            >
                              <option value="">---</option>
                              {MISS_TYPES.map(mt => <option key={mt} value={mt}>{mt}</option>)}
                            </select>
                          </td>
                          {isAdvancedMode && (
                            <>
                              <td style={cellStyle}>
                                <input
                                  style={{ ...inputCellStyle, minWidth: '50px' }}
                                  type="text"
                                  value={editForm.drawWeight || ""}
                                  onChange={(e) => setEditForm({ ...editForm, drawWeight: e.target.value })}
                                />
                              </td>
                              <td style={cellStyle}>
                                <select
                                  style={inputCellStyle}
                                  value={editForm.targetDirection || ''}
                                  onChange={(e) => setEditForm({ ...editForm, targetDirection: e.target.value })}
                                >
                                  <option value="">---</option>
                                  {TARGET_DIRECTIONS.map(d => <option key={d} value={d}>{d}</option>)}
                                </select>
                              </td>
                              <td style={cellStyle}>
                                <select
                                  style={inputCellStyle}
                                  value={editForm.targetDepth || ''}
                                  onChange={(e) => setEditForm({ ...editForm, targetDepth: e.target.value })}
                                >
                                  <option value="">---</option>
                                  {TARGET_DEPTHS.map(d => <option key={d} value={d}>{d}</option>)}
                                </select>
                              </td>
                            </>
                          )}
                          <td style={cellStyle}>
                            <select
                              style={inputCellStyle}
                              value={editForm.weight || ''}
                              onChange={(e) => setEditForm({ ...editForm, weight: e.target.value })}
                            >
                              <option value="">---</option>
                              {SHOT_WEIGHTS.map(sw => <option key={sw} value={sw}>{sw}</option>)}
                            </select>
                          </td>
                          <td style={cellStyle}>
                            <select
                              style={inputCellStyle}
                              value={editForm.keyShot || ''}
                              onChange={(e) => setEditForm({ ...editForm, keyShot: e.target.value })}
                            >
                              <option value="">---</option>
                              <option value="No">No</option>
                              <option value="Yes">Yes</option>
                            </select>
                          </td>
                          <td style={cellStyle}>
                            <input
                              style={{ ...inputCellStyle, minWidth: '100px' }}
                              type="text"
                              value={editForm.comments || ""}
                              onChange={(e) => setEditForm({ ...editForm, comments: e.target.value })}
                              placeholder="Comments..."
                            />
                          </td>
                          <td style={cellStyle}>
                            <div style={{ display: 'flex', gap: '4px' }}>
                              <button
                                style={{ 
                                  padding: '4px 8px', 
                                  fontSize: '11px', 
                                  background: 'var(--success)', 
                                  color: 'white',
                                  border: 'none',
                                  borderRadius: '4px',
                                  cursor: 'pointer'
                                }}
                                onClick={saveEdit}
                              >
                                Save
                              </button>
                              <button
                                style={{ 
                                  padding: '4px 8px', 
                                  fontSize: '11px', 
                                  background: 'var(--text-light)', 
                                  color: 'white',
                                  border: 'none',
                                  borderRadius: '4px',
                                  cursor: 'pointer'
                                }}
                                onClick={cancelEditing}
                              >
                                Cancel
                              </button>
                            </div>
                          </td>
                        </>
                      ) : (
                        <>
                          <td style={cellStyle}>{isLSD ? 'LSD' : shot.end}</td>
                          <td style={cellStyle}>{isLSD ? shot.lsdNumber : shot.shotNumber}</td>
                          <td style={cellStyle}>{shot.name || '---'}</td>
                          <td style={cellStyle}>{shot.turn === 'In-Turn' ? 'CW' : shot.turn === 'Out-Turn' ? 'CCW' : (shot.turn || '---')}</td>
                          <td style={cellStyle}>{isLSD ? 'LSD' : (shot.shotType || '---')}</td>
                          <td style={cellStyle}>{shot.outcome === null ? '---' : shot.outcome}</td>
                          <td style={cellStyle}>{shot.miss || '---'}</td>
                          <td style={cellStyle}>{shot.secondaryMiss || '---'}</td>
                          {isAdvancedMode && (
                            <>
                              <td style={cellStyle}>{shot.drawWeight || '---'}</td>
                              <td style={cellStyle}>{shot.targetDirection || '---'}</td>
                              <td style={cellStyle}>{shot.targetDepth || '---'}</td>
                            </>
                          )}
                          <td style={cellStyle}>{shot.weight || '---'}</td>
                          <td style={cellStyle}>{shot.keyShot || '---'}</td>
                          <td style={commentCellStyle} title={shot.comments || ''}>
                            {shot.comments || '---'}
                          </td>
                          <td style={cellStyle}>
                            <button
                              style={{ 
                                padding: '4px 12px', 
                                fontSize: '11px', 
                                background: 'var(--accent)', 
                                color: 'white',
                                border: 'none',
                                borderRadius: '4px',
                                cursor: 'pointer'
                              }}
                              onClick={() => startEditing(filteredIndex)}
                            >
                              Edit
                            </button>
                          </td>
                        </>
                      )}
                    </tr>
                  );
                })}
              </tbody>
            </table>
          </div>
        </div>
      );
    }

    // Tracking Panel Component
    function TrackingPanel({ state, dispatch, onNotify }) {
      const { gameType, statOptions, statMode, teamName, opponent, currentEnd, currentShot, currentHammer, 
              currentThrower, currentTeamShot, lastIceCondition, lineup, shots, lsdPhase, currentLSD, numLSDs, firstEndHammer } = state;
      
      const [lsdHammerSelection, setLsdHammerSelection] = useState(null);
      const [lsdAthleteName, setLsdAthleteName] = useState("");
      
      const teamMaxShots = POSITION_MAP[gameType].maxShots;
      const isBothTeams = statOptions === "Both Teams";
      const isOpponentThrowing = isBothTeams && currentThrower === opponent;
      const isAdvancedMode = statMode === "Advanced";
      
      // Get team players for LSD athlete dropdown
      const teamPlayers = useMemo(() => {
        if (!teamName) return [];
        return PLAYER_DATA.filter(p => 
          gameType === "Mixed Doubles" ? p.mdTeam === teamName : p.team === teamName
        ).map(p => p.name).sort();
      }, [teamName, gameType]);
      
      // Opponent game type: 4 Person (8 shots) unless Mixed Doubles
      const opponentGameType = gameType === "Mixed Doubles" ? "Mixed Doubles" : "4 Person";
      const opponentMaxShots = POSITION_MAP[opponentGameType].maxShots;
      
      // For display purposes, use the appropriate max shots based on who's throwing
      const maxShots = isOpponentThrowing ? opponentMaxShots : teamMaxShots;
      
      // For Both Teams mode, total shots per end combines both teams' shots
      const totalShotsInEnd = isBothTeams ? teamMaxShots + opponentMaxShots : teamMaxShots;
      
      // Calculate team-specific shot number based on alternating pattern
      // Shots alternate: team1, team2, team1, team2...
      const displayShotNumber = isBothTeams ? Math.ceil(currentShot / 2) : currentShot;
      
      // Track the current end for power play reset
      const [lastTrackedEnd, setLastTrackedEnd] = useState(currentEnd);
      
      // Check if we're waiting for hammer selection after last LSD
      const lsdNeedsHammerSelection = lsdPhase && currentLSD === numLSDs && 
        shots.filter(s => s.isLSD).length >= numLSDs;
      
      // Shot form state
      const [shotForm, setShotForm] = useState({
        drawWeight: lastIceCondition,
        turn: "---",
        shotType: "---",
        outcome: "",
        miss: "",
        secondaryMiss: "",
        weight: "---",
        keyShot: "No",
        powerPlay: "No",
        targetDirection: "---",
        targetDepth: "---",
        comments: "",
        teamScore: 0,
        oppScore: 0
      });
      
      // Auto-set shot weight and target based on shot type
      React.useEffect(() => {
        const shotType = shotForm.shotType;
        if (shotType === "Center Guard") {
          setShotForm(prev => ({ 
            ...prev, 
            weight: "Guard",
            targetDirection: "Center",
            targetDepth: "High Guard"
          }));
        } else if (shotType === "Corner Guard") {
          setShotForm(prev => ({ 
            ...prev, 
            weight: "Guard",
            targetDepth: "High Guard"
          }));
        } else if (["Draw", "Tap", "Freeze", "Trick Shot"].includes(shotType)) {
          setShotForm(prev => ({ ...prev, weight: "Draw" }));
        } else if (shotType !== "---") {
          // Takeout shots - reset to ---
          setShotForm(prev => ({ ...prev, weight: "---" }));
        }
      }, [shotForm.shotType]);
      
      // Reset powerPlay to "No" when end changes
      React.useEffect(() => {
        if (currentEnd !== lastTrackedEnd) {
          setShotForm(prev => ({ ...prev, powerPlay: "No" }));
          setLastTrackedEnd(currentEnd);
        }
      }, [currentEnd, lastTrackedEnd]);
      
      const [showEndGame, setShowEndGame] = useState(false);
      
      // Auto-calculate current position based on shot number (use displayShotNumber for Both Teams mode)
      const currentPosition = useMemo(() => {
        const shotNum = displayShotNumber;
        // Use opponent game type when opponent is throwing in Both Teams mode
        const effectiveGameType = (isBothTeams && isOpponentThrowing) ? opponentGameType : gameType;
        
        if (effectiveGameType === "4 Person") {
          if (shotNum <= 2) return "Lead";
          else if (shotNum <= 4) return "Second";
          else if (shotNum <= 6) return "Third";
          else return "Fourth";
        } else if (effectiveGameType === "3 Person") {
          if (shotNum <= 3) return "Lead";
          else if (shotNum <= 6) return "Second";
          else return "Third";
        } else {
          return (shotNum === 1 || shotNum === 5) ? "First/Last" : "Middle";
        }
      }, [displayShotNumber, gameType, opponentGameType, isBothTeams, isOpponentThrowing]);

      const handleLogShot = () => {
        // Validate outcome (required unless shot type is Throw Through or miss is Burnt)
        if (shotForm.outcome === "" && shotForm.shotType !== "Throw Through" && shotForm.miss !== "Burnt") {
          onNotify("Please select an outcome before logging the shot", "error");
          return;
        }

        // For Both Teams mode, use "Opponent" as name when opponent is throwing
        const playerName = isOpponentThrowing ? "Opponent" : lineup[currentPosition];
        const player = isOpponentThrowing ? null : PLAYER_DATA.find(p => p.name === playerName);
        
        // Score only on last shot of end (different logic for Both Teams)
        const isEndLastShot = isBothTeams 
          ? currentShot === totalShotsInEnd 
          : currentShot === maxShots;
        const score = isEndLastShot 
          ? `${shotForm.teamScore}-${shotForm.oppScore}` 
          : null;

        dispatch({
          type: 'LOG_SHOT',
          payload: {
            name: playerName,
            throwingTeam: currentThrower,  // Track which team threw this shot
            teamShotNumber: displayShotNumber,  // The shot number for this team (1-8)
            date: state.gameDate,
            opponent,
            competition: state.competition,
            compRound: state.compRound,
            drawWeight: isAdvancedMode ? shotForm.drawWeight : null,
            end: currentEnd,
            hammer: currentHammer,
            powerPlay: gameType === "Mixed Doubles" ? shotForm.powerPlay : null,
            shotNumber: currentShot,
            position: isOpponentThrowing ? currentPosition : currentPosition,
            turn: shotForm.turn === "---" ? null : shotForm.turn,
            shotType: shotForm.shotType === "---" ? null : shotForm.shotType,
            outcome: shotForm.outcome === "" ? null : parseInt(shotForm.outcome),
            miss: shotForm.miss,
            secondaryMiss: shotForm.secondaryMiss,
            weight: isAdvancedMode ? (shotForm.weight === "---" ? null : shotForm.weight) : null,
            keyShot: isAdvancedMode ? shotForm.keyShot : null,
            targetDirection: isAdvancedMode ? (shotForm.targetDirection === "---" ? null : shotForm.targetDirection) : null,
            targetDepth: isAdvancedMode ? (shotForm.targetDepth === "---" ? null : shotForm.targetDepth) : null,
            score,
            comments: shotForm.comments,
            userId: player?.userId
          }
        });

        // Reset form - reset selectors to --- for Advanced mode fields
        setShotForm(prev => ({
          ...prev,
          turn: "---",
          shotType: "---",
          outcome: "",
          miss: "",
          secondaryMiss: "",
          weight: "---",
          keyShot: "No",
          targetDirection: "---",
          targetDepth: "---",
          comments: "",
          teamScore: 0,
          oppScore: 0
        }));
        
        onNotify("Shot logged!", "success");
      };

      const handleUndo = () => {
        if (shots.length === 0) {
          onNotify("No shots to undo", "error");
          return;
        }
        
        // Get the last shot to restore its values
        const lastShot = shots[shots.length - 1];
        
        // Restore form values from the last shot
        setShotForm({
          drawWeight: lastShot.drawWeight || lastIceCondition,
          turn: lastShot.turn || "---",
          shotType: lastShot.shotType || "---",
          outcome: lastShot.outcome === null ? "" : String(lastShot.outcome),
          miss: lastShot.miss || "",
          secondaryMiss: lastShot.secondaryMiss || "",
          weight: lastShot.weight || "---",
          keyShot: lastShot.keyShot || "No",
          powerPlay: lastShot.powerPlay || "No",
          targetDirection: lastShot.targetDirection || "---",
          targetDepth: lastShot.targetDepth || "---",
          comments: lastShot.comments || "",
          teamScore: lastShot.score ? parseInt(lastShot.score.split('-')[0]) : 0,
          oppScore: lastShot.score ? parseInt(lastShot.score.split('-')[1]) : 0
        });
        
        dispatch({ type: 'UNDO_SHOT' });
        onNotify("Last shot removed", "info");
      };

      const handleEndGame = () => {
        dispatch({ type: 'END_GAME' });
        setShowEndGame(false);
      };

      const isLastShot = isBothTeams 
        ? currentShot === totalShotsInEnd 
        : currentShot === maxShots;

      // Dynamic colors based on which team is throwing
      const headerBgColor = isOpponentThrowing ? 'var(--primary)' : 'var(--secondary)';
      const headerGradient = isOpponentThrowing 
        ? 'linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%)'
        : 'linear-gradient(135deg, var(--accent) 0%, var(--secondary) 100%)';

      // Handle LSD shot logging
      const handleLogLSD = () => {
        if (!lsdNeedsHammerSelection && !lsdHammerSelection && currentLSD === numLSDs) {
          onNotify("Please select who has hammer first", "error");
          return;
        }

        dispatch({
          type: 'LOG_LSD',
          payload: {
            name: lsdAthleteName || teamName,
            date: state.gameDate,
            opponent: opponent,
            competition: state.competition,
            compRound: state.compRound,
            drawWeight: shotForm.drawWeight,
            turn: shotForm.turn === "---" ? null : shotForm.turn,
            outcome: shotForm.outcome === "" ? null : parseInt(shotForm.outcome),
            miss: shotForm.miss || null,
            secondaryMiss: shotForm.secondaryMiss || null,
            comments: shotForm.comments
          }
        });

        // Reset form but keep draw weight
        setShotForm(prev => ({
          ...prev,
          turn: "---",
          outcome: "",
          miss: "",
          secondaryMiss: "",
          comments: ""
        }));
        setLsdAthleteName("");

        // If this was the last LSD and hammer was selected, transition to game
        if (currentLSD === numLSDs && lsdHammerSelection) {
          dispatch({ type: 'SET_FIRST_END_HAMMER', payload: lsdHammerSelection });
        }

        onNotify("LSD logged!", "success");
      };

      // LSD Phase UI
      if (lsdPhase) {
        const lsdCount = shots.filter(s => s.isLSD).length;
        const showHammerSelection = lsdCount >= numLSDs || (numLSDs === 1 && lsdCount === 0);
        
        return (
          <div>
            {/* LSD Header */}
            <div style={{
              ...styles.shotCounter,
              background: 'var(--accent)'
            }}>
              <div style={styles.shotCounterText}>
                LSD {currentLSD}
              </div>
            </div>

            {/* LSD Form */}
            <div style={styles.card}>
              <div style={{ display: 'grid', gridTemplateColumns: 'repeat(6, 1fr)', gap: '16px' }}>
                {/* Athlete Name */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Athlete Name</label>
                  <select
                    style={styles.select}
                    value={lsdAthleteName}
                    onChange={(e) => setLsdAthleteName(e.target.value)}
                  >
                    <option value="">Select...</option>
                    {teamPlayers.map(p => <option key={p} value={p}>{p}</option>)}
                  </select>
                </div>

                {/* Turn */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Turn</label>
                  <select
                    style={styles.select}
                    value={shotForm.turn}
                    onChange={(e) => setShotForm(prev => ({ ...prev, turn: e.target.value }))}
                  >
                    <option value="---">---</option>
                    <option value="In-Turn">Clockwise</option>
                    <option value="Out-Turn">Counter Clockwise</option>
                  </select>
                </div>

                {/* Outcome (distance) */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Outcome</label>
                  <select
                    style={styles.select}
                    value={shotForm.outcome}
                    onChange={(e) => setShotForm(prev => ({ ...prev, outcome: e.target.value }))}
                  >
                    <option value="">---</option>
                    <option value="0">0</option>
                    <option value="1">1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                  </select>
                </div>

                {/* Primary Miss */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Primary Miss</label>
                  <select
                    style={styles.select}
                    value={shotForm.miss}
                    onChange={(e) => setShotForm(prev => ({ ...prev, miss: e.target.value }))}
                  >
                    <option value="">---</option>
                    {MISS_TYPES.map(mt => <option key={mt} value={mt}>{mt}</option>)}
                  </select>
                </div>

                {/* Secondary Miss */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Secondary Miss</label>
                  <select
                    style={styles.select}
                    value={shotForm.secondaryMiss}
                    onChange={(e) => setShotForm(prev => ({ ...prev, secondaryMiss: e.target.value }))}
                  >
                    <option value="">---</option>
                    {MISS_TYPES.map(mt => <option key={mt} value={mt}>{mt}</option>)}
                  </select>
                </div>

                {/* Draw Weight */}
                <div style={styles.formGroup}>
                  <label style={styles.label}>Draw Weight</label>
                  <input
                    type="text"
                    style={styles.input}
                    value={shotForm.drawWeight}
                    onChange={(e) => setShotForm(prev => ({ ...prev, drawWeight: e.target.value }))}
                    placeholder="e.g., 14.5"
                  />
                </div>
              </div>

              {/* Comments */}
              <div style={{ marginTop: '16px' }}>
                <div style={styles.formGroup}>
                  <label style={styles.label}>Comments</label>
                  <textarea
                    style={{ ...styles.input, minHeight: '60px', resize: 'vertical' }}
                    value={shotForm.comments}
                    onChange={(e) => setShotForm(prev => ({ ...prev, comments: e.target.value }))}
                    placeholder="Optional notes about this LSD..."
                  />
                </div>
              </div>

              {/* Hammer Selection - shown for last LSD */}
              {(currentLSD === numLSDs || (numLSDs === 1)) && (
                <div style={{ 
                  marginTop: '24px', 
                  padding: '20px', 
                  background: 'var(--ice)', 
                  borderRadius: 'var(--radius-sm)',
                  textAlign: 'center'
                }}>
                  <label style={{ 
                    display: 'block', 
                    fontWeight: '600', 
                    marginBottom: '12px',
                    color: 'var(--secondary)'
                  }}>
                    Who has hammer in the First End?
                  </label>
                  <div style={{ display: 'flex', gap: '12px', justifyContent: 'center' }}>
                    <button
                      onClick={() => setLsdHammerSelection(teamName)}
                      style={{
                        ...styles.button,
                        background: lsdHammerSelection === teamName ? 'var(--primary)' : 'white',
                        color: lsdHammerSelection === teamName ? 'white' : 'var(--text)',
                        border: '2px solid var(--primary)',
                        padding: '12px 24px'
                      }}
                    >
                      {teamName}
                    </button>
                    <button
                      onClick={() => setLsdHammerSelection(opponent)}
                      style={{
                        ...styles.button,
                        background: lsdHammerSelection === opponent ? 'var(--secondary)' : 'white',
                        color: lsdHammerSelection === opponent ? 'white' : 'var(--text)',
                        border: '2px solid var(--secondary)',
                        padding: '12px 24px'
                      }}
                    >
                      {opponent}
                    </button>
                  </div>
                </div>
              )}

              {/* Log LSD Button */}
              <div style={{ marginTop: '24px' }}>
                <button
                  style={{
                    ...styles.button,
                    ...styles.buttonSuccess,
                    width: '100%',
                    padding: '16px',
                    fontSize: '18px',
                    opacity: (currentLSD === numLSDs && !lsdHammerSelection) ? 0.5 : 1
                  }}
                  onClick={handleLogLSD}
                  disabled={currentLSD === numLSDs && !lsdHammerSelection}
                >
                  ‚úì Log LSD {currentLSD}
                </button>
              </div>
            </div>
          </div>
        );
      }

      // Regular game tracking UI
      return (
        <div>
          {/* Shot Counter */}
          <div style={{
            ...styles.shotCounter,
            background: headerBgColor
          }}>
            <div style={styles.shotCounterText}>
              END {currentEnd} ‚Ä¢ SHOT {displayShotNumber} OF {maxShots}
              {isBothTeams && <span style={{ marginLeft: '10px', opacity: 0.8 }}>({currentThrower})</span>}
            </div>
            <div style={styles.hammerBadge}>
              üî® {currentHammer}
            </div>
          </div>

          {/* Shot Form */}
          <div style={styles.card}>
            <div style={{ ...styles.grid, ...styles.grid4 }}>
              {/* Turn */}
              <div style={styles.formGroup}>
                <label style={styles.label}>Turn</label>
                <select
                  style={styles.select}
                  value={shotForm.turn}
                  onChange={(e) => setShotForm(prev => ({ ...prev, turn: e.target.value }))}
                >
                  <option value="---">---</option>
                  <option value="In-Turn">Clockwise</option>
                  <option value="Out-Turn">Counter Clockwise</option>
                </select>
              </div>

              {/* Shot Type */}
              <div style={styles.formGroup}>
                <label style={styles.label}>Shot Type</label>
                <select
                  style={styles.select}
                  value={shotForm.shotType}
                  onChange={(e) => setShotForm(prev => ({ ...prev, shotType: e.target.value }))}
                >
                  <option value="---">---</option>
                  {SHOT_TYPES.map(st => <option key={st} value={st}>{st}</option>)}
                </select>
              </div>

              {/* Outcome */}
              <div style={styles.formGroup}>
                <label style={styles.label}>Outcome</label>
                <select
                  style={styles.select}
                  value={shotForm.outcome}
                  onChange={(e) => setShotForm(prev => ({ ...prev, outcome: e.target.value }))}
                >
                  <option value="">---</option>
                  <option value="0">0</option>
                  <option value="1">1</option>
                  <option value="2">2</option>
                  <option value="3">3</option>
                  <option value="4">4</option>
                </select>
              </div>

              {/* Primary Miss */}
              <div style={styles.formGroup}>
                <label style={styles.label}>Primary Miss</label>
                <select
                  style={styles.select}
                  value={shotForm.miss}
                  onChange={(e) => setShotForm(prev => ({ ...prev, miss: e.target.value }))}
                >
                  <option value="">---</option>
                  {MISS_TYPES.map(mt => <option key={mt} value={mt}>{mt}</option>)}
                </select>
              </div>

              {/* Secondary Miss */}
              <div style={styles.formGroup}>
                <label style={styles.label}>Secondary Miss</label>
                <select
                  style={styles.select}
                  value={shotForm.secondaryMiss}
                  onChange={(e) => setShotForm(prev => ({ ...prev, secondaryMiss: e.target.value }))}
                >
                  <option value="">---</option>
                  {MISS_TYPES.map(mt => <option key={mt} value={mt}>{mt}</option>)}
                </select>
              </div>

              {isAdvancedMode && (
              <>
              {/* Target Direction */}
              <div style={styles.formGroup}>
                <label style={styles.label}>Target Direction</label>
                <select
                  style={styles.select}
                  value={shotForm.targetDirection}
                  onChange={(e) => setShotForm(prev => ({ ...prev, targetDirection: e.target.value }))}
                >
                  <option value="---">---</option>
                  <option value="Left">Left</option>
                  <option value="Center">Center</option>
                  <option value="Right">Right</option>
                </select>
              </div>

              {/* Target Depth */}
              <div style={styles.formGroup}>
                <label style={styles.label}>Target Depth</label>
                <select
                  style={styles.select}
                  value={shotForm.targetDepth}
                  onChange={(e) => setShotForm(prev => ({ ...prev, targetDepth: e.target.value }))}
                >
                  <option value="---">---</option>
                  <option value="High Guard">High Guard</option>
                  <option value="Mid Guard">Mid Guard</option>
                  <option value="Tight Guard">Tight Guard</option>
                  <option value="Top 12">Top 12</option>
                  <option value="Top 8">Top 8</option>
                  <option value="Top 4">Top 4</option>
                  <option value="T-Line">T-Line</option>
                  <option value="Back 4">Back 4</option>
                  <option value="Back 8">Back 8</option>
                  <option value="Back 12">Back 12</option>
                </select>
              </div>
              </>
              )}
            </div>

            {/* Shot Weight, Draw Weight, Key Shot, (Power Play for MD), and Comments row for Advanced mode */}
            {isAdvancedMode && (
              gameType === "Mixed Doubles" ? (
                <div style={{ marginTop: '16px', display: 'grid', gridTemplateColumns: '1fr 1fr 1fr 1fr 2fr', gap: '16px', alignItems: 'start' }}>
                  <div style={styles.formGroup}>
                    <label style={styles.label}>Shot Weight</label>
                    <select
                      style={styles.select}
                      value={shotForm.weight}
                      onChange={(e) => setShotForm(prev => ({ ...prev, weight: e.target.value }))}
                    >
                      <option value="---">---</option>
                      {(() => {
                        const TAKEOUT_SHOTS = ["Dig", "Peel", "Double Peel", "Takeout", "Double Takeout", "Hit and Roll", "Runback"];
                        const isTakeout = TAKEOUT_SHOTS.includes(shotForm.shotType);
                        const filteredWeights = isTakeout 
                          ? SHOT_WEIGHTS.filter(sw => sw !== "Guard" && sw !== "Draw")
                          : SHOT_WEIGHTS;
                        return filteredWeights.map(sw => <option key={sw} value={sw}>{sw}</option>);
                      })()}
                    </select>
                  </div>
                  <div style={styles.formGroup}>
                    <label style={styles.label}>Draw Weight</label>
                    <input
                      type="text"
                      style={styles.input}
                      value={shotForm.drawWeight}
                      onChange={(e) => setShotForm(prev => ({ ...prev, drawWeight: e.target.value }))}
                      placeholder="e.g., 14.5"
                    />
                  </div>
                  <div style={styles.formGroup}>
                    <label style={styles.label}>Key Shot</label>
                    <select
                      style={styles.select}
                      value={shotForm.keyShot}
                      onChange={(e) => setShotForm(prev => ({ ...prev, keyShot: e.target.value }))}
                    >
                      <option value="No">No</option>
                      <option value="Yes">Yes</option>
                    </select>
                  </div>
                  <div style={styles.formGroup}>
                    <label style={styles.label}>Power Play</label>
                    <select
                      style={styles.select}
                      value={shotForm.powerPlay}
                      onChange={(e) => setShotForm(prev => ({ ...prev, powerPlay: e.target.value }))}
                    >
                      <option value="No">No</option>
                      <option value="Yes">Yes</option>
                    </select>
                  </div>
                  <div style={styles.formGroup}>
                    <label style={styles.label}>Comments</label>
                    <textarea
                      style={{ ...styles.input, minHeight: '38px', resize: 'vertical' }}
                      value={shotForm.comments}
                      onChange={(e) => setShotForm(prev => ({ ...prev, comments: e.target.value }))}
                      placeholder="Optional notes..."
                    />
                  </div>
                </div>
              ) : (
                <div style={{ marginTop: '16px', display: 'grid', gridTemplateColumns: '1fr 1fr 1fr 2fr', gap: '16px', alignItems: 'start' }}>
                  <div style={styles.formGroup}>
                    <label style={styles.label}>Shot Weight</label>
                    <select
                      style={styles.select}
                      value={shotForm.weight}
                      onChange={(e) => setShotForm(prev => ({ ...prev, weight: e.target.value }))}
                    >
                      <option value="---">---</option>
                      {(() => {
                        const TAKEOUT_SHOTS = ["Dig", "Peel", "Double Peel", "Takeout", "Double Takeout", "Hit and Roll", "Runback"];
                        const isTakeout = TAKEOUT_SHOTS.includes(shotForm.shotType);
                        const filteredWeights = isTakeout 
                          ? SHOT_WEIGHTS.filter(sw => sw !== "Guard" && sw !== "Draw")
                          : SHOT_WEIGHTS;
                        return filteredWeights.map(sw => <option key={sw} value={sw}>{sw}</option>);
                      })()}
                    </select>
                  </div>
                  <div style={styles.formGroup}>
                    <label style={styles.label}>Draw Weight</label>
                    <input
                      type="text"
                      style={styles.input}
                      value={shotForm.drawWeight}
                      onChange={(e) => setShotForm(prev => ({ ...prev, drawWeight: e.target.value }))}
                      placeholder="e.g., 14.5"
                    />
                  </div>
                  <div style={styles.formGroup}>
                    <label style={styles.label}>Key Shot</label>
                    <select
                      style={styles.select}
                      value={shotForm.keyShot}
                      onChange={(e) => setShotForm(prev => ({ ...prev, keyShot: e.target.value }))}
                    >
                      <option value="No">No</option>
                      <option value="Yes">Yes</option>
                    </select>
                  </div>
                  <div style={styles.formGroup}>
                    <label style={styles.label}>Comments</label>
                    <textarea
                      style={{ ...styles.input, minHeight: '38px', resize: 'vertical' }}
                      value={shotForm.comments}
                      onChange={(e) => setShotForm(prev => ({ ...prev, comments: e.target.value }))}
                      placeholder="Optional notes..."
                    />
                  </div>
                </div>
              )
            )}

            {/* Comments for Simple mode */}
            {!isAdvancedMode && gameType === "Mixed Doubles" ? (
              <div style={{ marginTop: '16px', display: 'grid', gridTemplateColumns: 'minmax(140px, auto) 1fr', gap: '16px' }}>
                <div style={styles.formGroup}>
                  <label style={styles.label}>Power Play</label>
                  <select
                    style={styles.select}
                    value={shotForm.powerPlay}
                    onChange={(e) => setShotForm(prev => ({ ...prev, powerPlay: e.target.value }))}
                  >
                    <option value="No">No</option>
                    <option value="Yes">Yes</option>
                  </select>
                </div>
                <div style={styles.formGroup}>
                  <label style={styles.label}>Comments</label>
                  <textarea
                    style={{ ...styles.input, minHeight: '80px', resize: 'vertical' }}
                    value={shotForm.comments}
                    onChange={(e) => setShotForm(prev => ({ ...prev, comments: e.target.value }))}
                    placeholder="Optional notes about this shot..."
                  />
                </div>
              </div>
            ) : !isAdvancedMode && (
              <div style={{ marginTop: '16px' }}>
                <div style={styles.formGroup}>
                  <label style={styles.label}>Comments</label>
                  <textarea
                    style={{ ...styles.input, minHeight: '80px', resize: 'vertical' }}
                    value={shotForm.comments}
                    onChange={(e) => setShotForm(prev => ({ ...prev, comments: e.target.value }))}
                    placeholder="Optional notes about this shot..."
                  />
                </div>
              </div>
            )}

            {/* Score inputs for last shot */}
            {isLastShot && (
              <div style={styles.scoreInputs}>
                <h4 style={{ marginBottom: '16px', color: 'var(--secondary)' }}>End Score</h4>
                <div style={{ ...styles.grid, gridTemplateColumns: '1fr 1fr' }}>
                  <div style={styles.formGroup}>
                    <label style={styles.label}>{teamName}</label>
                    <input
                      style={styles.input}
                      type="number"
                      min="0"
                      value={shotForm.teamScore}
                      onChange={(e) => setShotForm(prev => ({ ...prev, teamScore: parseInt(e.target.value) || 0 }))}
                    />
                  </div>
                  <div style={styles.formGroup}>
                    <label style={styles.label}>{opponent}</label>
                    <input
                      style={styles.input}
                      type="number"
                      min="0"
                      value={shotForm.oppScore}
                      onChange={(e) => setShotForm(prev => ({ ...prev, oppScore: parseInt(e.target.value) || 0 }))}
                    />
                  </div>
                </div>
              </div>
            )}

            {/* Action Buttons */}
            <div style={{ 
              display: 'flex', 
              gap: '12px', 
              marginTop: '24px',
              justifyContent: 'space-between',
              flexWrap: 'wrap'
            }}>
              <button
                style={{ ...styles.button, ...styles.buttonWarning }}
                onClick={handleUndo}
              >
                ‚Üê Back
              </button>
              <button
                style={{ ...styles.button, ...styles.buttonSuccess, padding: '14px 48px' }}
                onClick={handleLogShot}
              >
                Log Shot ‚úì
              </button>
              <button
                style={{ ...styles.button, ...styles.buttonPrimary }}
                onClick={() => setShowEndGame(true)}
              >
                End Game
              </button>
            </div>
          </div>

          {/* Current Player Display */}
          <div style={{ 
            ...styles.card, 
            background: headerGradient,
            color: 'white',
            textAlign: 'center'
          }}>
            <div style={{ fontSize: '14px', opacity: 0.8, marginBottom: '4px' }}>
              Current Thrower
            </div>
            <div style={{ fontFamily: "'Bebas Neue', sans-serif", fontSize: '32px', letterSpacing: '1px' }}>
              {isOpponentThrowing ? opponent : (lineup[currentPosition] || "‚Äî")}
            </div>
            <div style={{ fontSize: '14px', marginTop: '4px' }}>
              {isOpponentThrowing ? `${opponent} ‚Ä¢ ${currentPosition}` : currentPosition}
            </div>
          </div>

          {showEndGame && (
            <ConfirmModal
              title="End Game?"
              message="You can still view analytics and export data after ending."
              onConfirm={handleEndGame}
              onCancel={() => setShowEndGame(false)}
            />
          )}
        </div>
      );
    }

    // Analytics Panel Component
    function AnalyticsPanel({ state, dispatch, onNotify }) {
      const { shots, teamName, opponent, gameType, statOptions, totalEnds, competitionId, competition, compRound, gameDate, lineup, gameEnded, firstEndHammer } = state;
      const [showNewGame, setShowNewGame] = useState(false);
      const [showArchiveModal, setShowArchiveModal] = useState(false);
      const [showExportCSVModal, setShowExportCSVModal] = useState(false);
      const [analyticsTab, setAnalyticsTab] = useState('team'); // 'team' or 'opponent'
      const [playerFilter, setPlayerFilter] = useState('Team'); // 'Team' or player name
      const [selectedEnds, setSelectedEnds] = useState([]); // Array of selected end numbers
      const [showTeamPct, setShowTeamPct] = useState(true); // Team shooting % toggle for heat map
      const [missFilterTurn, setMissFilterTurn] = useState(null);
      const [missFilterShotType, setMissFilterShotType] = useState(null);
      const [missFilterPrimary, setMissFilterPrimary] = useState(null);
      const [missFilterSecondary, setMissFilterSecondary] = useState(null);
      const maxShots = POSITION_MAP[gameType].maxShots;
      const isBothTeams = statOptions === "Both Teams";

      // Filter out LSD shots from all analytics
      const gameShots = useMemo(() => shots.filter(s => !s.isLSD), [shots]);

      // Archive game handler
      const handleArchiveGame = async () => {
        if (!competitionId) {
          onNotify('No competition selected', 'error');
          return;
        }
        try {
          await CompetitionDB.archiveGame(competitionId, state);
          onNotify('Game archived to ' + competition + '!', 'success');
          setShowArchiveModal(false);
        } catch (e) {
          console.error('Failed to archive game:', e);
          onNotify('Failed to archive game', 'error');
        }
      };

      // Handle end selection toggle
      const toggleEnd = (endNum) => {
        if (showTeamPct) {
          // Switching from team to specific ends
          setShowTeamPct(false);
          setSelectedEnds([endNum]);
        } else {
          setSelectedEnds(prev => 
            prev.includes(endNum) 
              ? prev.filter(e => e !== endNum)
              : [...prev, endNum]
          );
        }
      };

      // Handle team % toggle
      const toggleTeamPct = () => {
        setShowTeamPct(true);
        setSelectedEnds([]);
      };

      // Categorize shot types
      const DRAW_SHOTS = ["Draw", "Tap", "Center Guard", "Corner Guard", "Freeze", "Trick Shot"];
      const TAKEOUT_SHOTS = ["Dig", "Peel", "Double Peel", "Takeout", "Double Takeout", "Hit and Roll", "Runback"];
      const isDrawShot = (shotType) => DRAW_SHOTS.includes(shotType);
      const isTakeoutShot = (shotType) => TAKEOUT_SHOTS.includes(shotType);
      const isThrowThrough = (shotType) => shotType === "Throw Through";

      // Filter shots by team for Both Teams mode - use gameShots (excludes LSDs)
      const teamShots = useMemo(() => {
        if (!isBothTeams) return gameShots;
        return gameShots.filter(s => s.throwingTeam === teamName);
      }, [gameShots, isBothTeams, teamName]);

      const opponentShots = useMemo(() => {
        if (!isBothTeams) return [];
        return gameShots.filter(s => s.throwingTeam === opponent);
      }, [gameShots, isBothTeams, opponent]);

      // Get the shots to use based on current tab
      const currentShots = analyticsTab === 'opponent' ? opponentShots : teamShots;
      const currentTeamName = analyticsTab === 'opponent' ? opponent : teamName;
      const isOpponentTab = analyticsTab === 'opponent';

      // Calculate statistics
      const stats = useMemo(() => {
        if (currentShots.length === 0) return null;

        // Score by end - always use all shots for score data
        const allEndScores = shots
          .filter(s => s.score)
          .map(s => ({
            end: s.end,
            teamScore: parseInt(s.score.split('-')[0]),
            oppScore: parseInt(s.score.split('-')[1])
          }));

        // Regular ends (1 through totalEnds)
        const endScores = allEndScores.filter(e => e.end <= totalEnds);
        
        // Extra end (any end > totalEnds)
        const extraEndData = allEndScores.find(e => e.end > totalEnds);
        const extraEndTeamScore = extraEndData ? extraEndData.teamScore : undefined;
        const extraEndOppScore = extraEndData ? extraEndData.oppScore : undefined;

        const totalTeamScore = allEndScores.reduce((sum, e) => sum + e.teamScore, 0);
        const totalOppScore = allEndScores.reduce((sum, e) => sum + e.oppScore, 0);

        // Shooting percentage by end (exclude Throw Through) - use currentShots for team-specific
        const endPcts = {};
        currentShots.forEach(s => {
          if (s.outcome !== null && !isThrowThrough(s.shotType)) {
            if (!endPcts[s.end]) endPcts[s.end] = [];
            endPcts[s.end].push(s.outcome * 25);
          }
        });
        const endPercentages = Object.entries(endPcts).map(([end, pcts]) => ({
          end: parseInt(end),
          pct: pcts.length ? Math.round(pcts.reduce((a, b) => a + b, 0) / pcts.length) : 0
        })).sort((a, b) => a.end - b.end);

        // Player statistics with In-Turn/Out-Turn breakdown (exclude Throw Through)
        const playerStats = {};
        currentShots.forEach(s => {
          if (s.outcome === null || isThrowThrough(s.shotType)) return; // Skip shots with no outcome or Throw Through
          
          // For opponent tab, use position as the key instead of name
          const key = isOpponentTab ? s.position : s.name;
          
          if (!playerStats[key]) {
            playerStats[key] = { 
              position: s.position,
              draws: { inTurn: [], outTurn: [] }, 
              takeouts: { inTurn: [], outTurn: [] },
              all: []
            };
          }
          const pct = s.outcome * 25;
          playerStats[key].all.push(pct);
          
          const turnKey = s.turn === "In-Turn" ? "inTurn" : "outTurn";
          if (isDrawShot(s.shotType)) {
            playerStats[key].draws[turnKey].push(pct);
          } else {
            playerStats[key].takeouts[turnKey].push(pct);
          }
        });

        // Build player table in Shot Success Analysis format
        const playerTable = Object.entries(playerStats).map(([name, data]) => {
          const drawsInTurn = data.draws.inTurn;
          const drawsOutTurn = data.draws.outTurn;
          const drawsTotal = [...drawsInTurn, ...drawsOutTurn];
          const takeoutsInTurn = data.takeouts.inTurn;
          const takeoutsOutTurn = data.takeouts.outTurn;
          const takeoutsTotal = [...takeoutsInTurn, ...takeoutsOutTurn];
          
          return {
            name,
            position: data.position,
            draws: {
              inTurnCount: drawsInTurn.length,
              inTurnPct: drawsInTurn.length ? Math.round(drawsInTurn.reduce((a, b) => a + b, 0) / drawsInTurn.length) : null,
              outTurnCount: drawsOutTurn.length,
              outTurnPct: drawsOutTurn.length ? Math.round(drawsOutTurn.reduce((a, b) => a + b, 0) / drawsOutTurn.length) : null,
              totalCount: drawsTotal.length,
              totalPct: drawsTotal.length ? Math.round(drawsTotal.reduce((a, b) => a + b, 0) / drawsTotal.length) : null
            },
            takeouts: {
              inTurnCount: takeoutsInTurn.length,
              inTurnPct: takeoutsInTurn.length ? Math.round(takeoutsInTurn.reduce((a, b) => a + b, 0) / takeoutsInTurn.length) : null,
              outTurnCount: takeoutsOutTurn.length,
              outTurnPct: takeoutsOutTurn.length ? Math.round(takeoutsOutTurn.reduce((a, b) => a + b, 0) / takeoutsOutTurn.length) : null,
              totalCount: takeoutsTotal.length,
              totalPct: takeoutsTotal.length ? Math.round(takeoutsTotal.reduce((a, b) => a + b, 0) / takeoutsTotal.length) : null
            },
            total: {
              count: data.all.length,
              pct: data.all.length ? Math.round(data.all.reduce((a, b) => a + b, 0) / data.all.length) : null
            }
          };
        });

        // Calculate team totals (exclude Throw Through) - use currentShots
        const teamTotals = {
          draws: { inTurn: [], outTurn: [] },
          takeouts: { inTurn: [], outTurn: [] },
          all: []
        };
        currentShots.forEach(s => {
          if (s.outcome === null || isThrowThrough(s.shotType)) return;
          const pct = s.outcome * 25;
          teamTotals.all.push(pct);
          const turnKey = s.turn === "In-Turn" ? "inTurn" : "outTurn";
          if (isDrawShot(s.shotType)) {
            teamTotals.draws[turnKey].push(pct);
          } else {
            teamTotals.takeouts[turnKey].push(pct);
          }
        });

        const teamRow = {
          name: isOpponentTab ? "Opponent Total" : "Team Total",
          position: "",
          draws: {
            inTurnCount: teamTotals.draws.inTurn.length,
            inTurnPct: teamTotals.draws.inTurn.length ? Math.round(teamTotals.draws.inTurn.reduce((a, b) => a + b, 0) / teamTotals.draws.inTurn.length) : null,
            outTurnCount: teamTotals.draws.outTurn.length,
            outTurnPct: teamTotals.draws.outTurn.length ? Math.round(teamTotals.draws.outTurn.reduce((a, b) => a + b, 0) / teamTotals.draws.outTurn.length) : null,
            totalCount: [...teamTotals.draws.inTurn, ...teamTotals.draws.outTurn].length,
            totalPct: [...teamTotals.draws.inTurn, ...teamTotals.draws.outTurn].length ? Math.round([...teamTotals.draws.inTurn, ...teamTotals.draws.outTurn].reduce((a, b) => a + b, 0) / [...teamTotals.draws.inTurn, ...teamTotals.draws.outTurn].length) : null
          },
          takeouts: {
            inTurnCount: teamTotals.takeouts.inTurn.length,
            inTurnPct: teamTotals.takeouts.inTurn.length ? Math.round(teamTotals.takeouts.inTurn.reduce((a, b) => a + b, 0) / teamTotals.takeouts.inTurn.length) : null,
            outTurnCount: teamTotals.takeouts.outTurn.length,
            outTurnPct: teamTotals.takeouts.outTurn.length ? Math.round(teamTotals.takeouts.outTurn.reduce((a, b) => a + b, 0) / teamTotals.takeouts.outTurn.length) : null,
            totalCount: [...teamTotals.takeouts.inTurn, ...teamTotals.takeouts.outTurn].length,
            totalPct: [...teamTotals.takeouts.inTurn, ...teamTotals.takeouts.outTurn].length ? Math.round([...teamTotals.takeouts.inTurn, ...teamTotals.takeouts.outTurn].reduce((a, b) => a + b, 0) / [...teamTotals.takeouts.inTurn, ...teamTotals.takeouts.outTurn].length) : null
          },
          total: {
            count: teamTotals.all.length,
            pct: teamTotals.all.length ? Math.round(teamTotals.all.reduce((a, b) => a + b, 0) / teamTotals.all.length) : null
          }
        };

        // Miss analysis by shot type (Draw vs Takeout) with player breakdown - use currentShots
        const missMatrixDraws = {};
        const missMatrixTakeouts = {};
        const missMatrixByPlayer = {};
        
        currentShots.filter(s => s.miss && !isThrowThrough(s.shotType)).forEach(s => {
          const matrix = isDrawShot(s.shotType) ? missMatrixDraws : missMatrixTakeouts;
          if (!matrix[s.miss]) matrix[s.miss] = 0;
          matrix[s.miss]++;
          
          // Track by player
          const playerKey = isOpponentTab ? s.position : s.name;
          if (!missMatrixByPlayer[playerKey]) {
            missMatrixByPlayer[playerKey] = {};
          }
          if (!missMatrixByPlayer[playerKey][s.miss]) {
            missMatrixByPlayer[playerKey][s.miss] = 0;
          }
          missMatrixByPlayer[playerKey][s.miss]++;
        });

        const overallPct = teamTotals.all.length ? Math.round(teamTotals.all.reduce((sum, p) => sum + p, 0) / teamTotals.all.length) : 0;

        // Game outcome
        const gameOutcome = totalTeamScore > totalOppScore ? "Win" : "Loss";

        // Target Heat Map data (only for Advanced mode shots) - separate for draws and takeouts
        const TARGET_DIRECTIONS = ['Left', 'Center', 'Right'];
        const TARGET_DEPTHS = ['Back 12', 'Back 8', 'Back 4', 'T-Line', 'Top 4', 'Top 8', 'Top 12', 'Tight Guard', 'Mid Guard', 'High Guard'];
        
        const createEmptyHeatMap = () => {
          const map = {};
          TARGET_DEPTHS.forEach(depth => {
            map[depth] = {};
            TARGET_DIRECTIONS.forEach(dir => {
              map[depth][dir] = { outcomes: [], count: 0, pct: null };
            });
          });
          return map;
        };
        
        const targetHeatMapDraws = createEmptyHeatMap();
        const targetHeatMapTakeouts = createEmptyHeatMap();
        
        // Populate with shot data (only shots with target data)
        currentShots.forEach(s => {
          if (s.targetDirection && s.targetDepth && s.outcome !== null && !isThrowThrough(s.shotType)) {
            const isDrawType = isDrawShot(s.shotType);
            const map = isDrawType ? targetHeatMapDraws : targetHeatMapTakeouts;
            const cell = map[s.targetDepth]?.[s.targetDirection];
            if (cell) {
              cell.outcomes.push(s.outcome * 25);
              cell.count++;
            }
          }
        });
        
        // Calculate percentages for both maps
        [targetHeatMapDraws, targetHeatMapTakeouts].forEach(map => {
          TARGET_DEPTHS.forEach(depth => {
            TARGET_DIRECTIONS.forEach(dir => {
              const cell = map[depth][dir];
              if (cell.outcomes.length > 0) {
                cell.pct = Math.round(cell.outcomes.reduce((a, b) => a + b, 0) / cell.outcomes.length);
              }
            });
          });
        });

        // Calculate cumulative scores for score by end table
        let cumulativeTeam = 0;
        let cumulativeOpp = 0;
        const endScoresWithCumulative = endScores.map(e => {
          cumulativeTeam += e.teamScore;
          cumulativeOpp += e.oppScore;
          return { ...e, cumulativeTeam, cumulativeOpp };
        });

        return {
          endScores: endScoresWithCumulative,
          extraEndTeamScore,
          extraEndOppScore,
          totalTeamScore,
          totalOppScore,
          endPercentages,
          playerTable,
          teamRow,
          missMatrixDraws,
          missMatrixTakeouts,
          missMatrixByPlayer,
          targetHeatMapDraws,
          targetHeatMapTakeouts,
          overallPct,
          totalShots: currentShots.length,
          gameOutcome
        };
      }, [shots, currentShots, totalEnds, isOpponentTab]);

      // Get unique player names for the filter dropdown
      const playerNames = useMemo(() => {
        if (!stats) return [];
        return stats.playerTable.map(p => p.name);
      }, [stats]);

      // Get shots filtered by player
      const playerFilteredShots = useMemo(() => {
        if (playerFilter === 'Team') return currentShots;
        return currentShots.filter(s => s.name === playerFilter);
      }, [currentShots, playerFilter]);

      // Calculate filtered stats (shooting percentages) by player
      const filteredStats = useMemo(() => {
        if (!stats) return { overallPct: 0, endPercentages: [] };
        
        if (playerFilter === 'Team') {
          return { overallPct: stats.overallPct, endPercentages: stats.endPercentages };
        }
        
        // Calculate for specific player
        const playerShots = playerFilteredShots.filter(s => s.outcome !== null && s.shotType !== "Throw Through");
        const overallPct = playerShots.length > 0 
          ? Math.round(playerShots.reduce((sum, s) => sum + s.outcome * 25, 0) / playerShots.length)
          : 0;
        
        // End percentages for player
        const endPcts = {};
        playerShots.forEach(s => {
          if (!endPcts[s.end]) endPcts[s.end] = [];
          endPcts[s.end].push(s.outcome * 25);
        });
        const endPercentages = Object.entries(endPcts).map(([end, pcts]) => ({
          end: parseInt(end),
          pct: pcts.length ? Math.round(pcts.reduce((a, b) => a + b, 0) / pcts.length) : 0
        })).sort((a, b) => a.end - b.end);
        
        return { overallPct, endPercentages };
      }, [stats, playerFilter, playerFilteredShots]);

      // Calculate filtered heat maps based on selected ends AND player filter
      const filteredHeatMaps = useMemo(() => {
        if (!stats) return { draws: null, takeouts: null };
        
        const TARGET_DIRECTIONS = ['Left', 'Center', 'Right'];
        const TARGET_DEPTHS = ['Back 12', 'Back 8', 'Back 4', 'T-Line', 'Top 4', 'Top 8', 'Top 12', 'Tight Guard', 'Mid Guard', 'High Guard'];
        
        const createEmptyHeatMap = () => {
          const map = {};
          TARGET_DEPTHS.forEach(depth => {
            map[depth] = {};
            TARGET_DIRECTIONS.forEach(dir => {
              map[depth][dir] = { outcomes: [], count: 0, pct: null };
            });
          });
          return map;
        };
        
        // Start with player-filtered shots
        let shotsToUse = playerFilteredShots;
        
        // Further filter by selected ends if not showing team %
        if (!showTeamPct && selectedEnds.length > 0) {
          shotsToUse = shotsToUse.filter(s => selectedEnds.includes(s.end));
        }
        
        // If no ends selected and not showing team %, return empty
        if (!showTeamPct && selectedEnds.length === 0) {
          return { draws: null, takeouts: null };
        }
        
        const heatMapDraws = createEmptyHeatMap();
        const heatMapTakeouts = createEmptyHeatMap();
        
        shotsToUse.forEach(s => {
          if (s.targetDirection && s.targetDepth && s.outcome !== null && s.shotType !== "Throw Through") {
            const isDrawType = DRAW_SHOTS.includes(s.shotType);
            const map = isDrawType ? heatMapDraws : heatMapTakeouts;
            const cell = map[s.targetDepth]?.[s.targetDirection];
            if (cell) {
              cell.outcomes.push(s.outcome * 25);
              cell.count++;
            }
          }
        });
        
        [heatMapDraws, heatMapTakeouts].forEach(map => {
          TARGET_DEPTHS.forEach(depth => {
            TARGET_DIRECTIONS.forEach(dir => {
              const cell = map[depth][dir];
              if (cell.outcomes.length > 0) {
                cell.pct = Math.round(cell.outcomes.reduce((a, b) => a + b, 0) / cell.outcomes.length);
              }
            });
          });
        });
        
        return { draws: heatMapDraws, takeouts: heatMapTakeouts };
      }, [stats, showTeamPct, selectedEnds, playerFilteredShots]);

      // Filter miss matrix by player
      const filteredMissData = useMemo(() => {
        if (!stats) return { draws: {}, takeouts: {} };
        
        if (playerFilter === 'Team') {
          return { draws: stats.missMatrixDraws, takeouts: stats.missMatrixTakeouts };
        }
        
        // Split into draws and takeouts for selected player
        const drawMisses = {};
        const takeoutMisses = {};
        
        playerFilteredShots.filter(s => s.miss).forEach(s => {
          const isDrawType = DRAW_SHOTS.includes(s.shotType);
          const target = isDrawType ? drawMisses : takeoutMisses;
          if (!target[s.miss]) target[s.miss] = 0;
          target[s.miss]++;
        });
        
        return { draws: drawMisses, takeouts: takeoutMisses };
      }, [stats, playerFilter, playerFilteredShots]);

      // Calculate ScoreDiff and EndOutcome for CSV export
      const getScoreDiff = (end) => {
        let teamTotal = 0;
        let oppTotal = 0;
        const endScores = shots
          .filter(s => s.score && s.end < end)
          .map(s => ({ end: s.end, score: s.score }));
        
        endScores.forEach(e => {
          const [ts, os] = e.score.split('-').map(Number);
          teamTotal += ts;
          oppTotal += os;
        });
        return teamTotal - oppTotal;
      };

      const getEndOutcome = (end) => {
        const endShot = shots.find(s => s.end === end && s.shotNumber === maxShots);
        
        // Check if this is an incomplete end (game ended mid-end)
        if (!endShot || !endShot.score) {
          // Check if there are any shots in this end but it wasn't completed
          const shotsInEnd = shots.filter(s => s.end === end);
          if (shotsInEnd.length > 0 && gameEnded) {
            return "Conceded";
          }
          return "";
        }
        
        const [teamScore, oppScore] = endShot.score.split('-').map(Number);
        const hadHammer = endShot.hammer === teamName;
        
        // Blank end (0-0)
        if (teamScore === 0 && oppScore === 0) return "Blank";
        
        if (hadHammer) {
          // Team had hammer
          if (teamScore === 1) return "Got Forced";
          if (teamScore >= 2) return `Scored ${teamScore}`;
          if (oppScore >= 1) return `Allowed a Steal of ${oppScore}`;
        } else {
          // Opponent had hammer
          if (oppScore === 1) return "Forced";
          if (oppScore >= 2) return `Gave Up ${oppScore}`;
          if (teamScore >= 1) return `Stole ${teamScore}`;
        }
        return "";
      };

      // Get end points as positive (team scored) or negative (opponent scored)
      const getEndPoints = (end) => {
        const endShot = shots.find(s => s.end === end && s.score);
        
        if (!endShot || !endShot.score) {
          return '';
        }
        
        const [teamScore, oppScore] = endShot.score.split('-').map(Number);
        
        if (teamScore > 0) return teamScore;
        if (oppScore > 0) return -oppScore;
        return 0; // Blank end
      };

      const exportCSV = (exportTeam = 'team') => {
        // Format date as DD/MM/YYYY
        const formatDate = (dateStr) => {
          const [year, month, day] = dateStr.split('-');
          return `${day}/${month}/${year}`;
        };

        // Get all shots including LSDs for export
        const allShots = shots;
        
        // Determine which shots to export (filter by team but include LSDs)
        const shotsToExport = isBothTeams 
          ? (exportTeam === 'opponent' 
              ? allShots.filter(s => s.isLSD || s.throwingTeam === opponent)
              : allShots.filter(s => s.isLSD || s.throwingTeam === teamName))
          : allShots;
        const exportTeamName = exportTeam === 'opponent' ? opponent : teamName;

        // Pre-calculate EndPoints for each end (excluding LSDs)
        const gameOnlyShots = shotsToExport.filter(s => !s.isLSD);
        const endPoints = {};
        const uniqueEnds = [...new Set(gameOnlyShots.map(s => s.end))];
        uniqueEnds.forEach(end => {
          endPoints[end] = getEndPoints(end);
        });

        // Calculate efficiency stats for this game (excluding LSDs)
        // Group shots by end to determine end outcomes
        // Note: s.score is PER-END score (e.g., "2-0" means team scored 2 that end)
        const endStats = {};
        gameOnlyShots.forEach(s => {
          if (!endStats[s.end]) {
            endStats[s.end] = {
              hammer: s.hammer,
              teamScore: 0,
              oppScore: 0
            };
          }
          // Get the score from the last shot of the end (per-end score, not cumulative)
          if (s.score) {
            const [ts, os] = s.score.split('-').map(Number);
            endStats[s.end].teamScore = ts;
            endStats[s.end].oppScore = os;
          }
        });

        // Calculate efficiency metrics
        // Since s.score is already per-end, we use it directly (no need to calculate differences)
        // HammerEff: Ends with hammer where scored 2+ / Ends with hammer that weren't blank
        // ForceEff: Ends opponent scored 1 with hammer / Total ends opponent scored with hammer
        // StealEff: Ends without hammer where stole 1+ / Total ends without hammer
        // StealDef: Ends with hammer where gave up steal / Total ends with hammer
        
        let hammerEffNum = 0, hammerEffDenom = 0;
        let forceEffNum = 0, forceEffDenom = 0;
        let stealEffNum = 0, stealEffDenom = 0;
        let stealDefNum = 0, stealDefDenom = 0;

        Object.entries(endStats).forEach(([end, data]) => {
          const hadHammer = data.hammer === exportTeamName;
          const teamPts = data.teamScore;  // Per-end score (not cumulative)
          const oppPts = data.oppScore;    // Per-end score (not cumulative)
          const isBlank = teamPts === 0 && oppPts === 0;
          
          if (hadHammer) {
            // Team had hammer
            // HammerEff: scored 2+ / not blank (ends where someone scored)
            if (!isBlank) {
              hammerEffDenom++;
              if (teamPts >= 2) hammerEffNum++;
            }
            // StealDef: gave up 1+ (opponent scored) / total ends with hammer
            stealDefDenom++;
            if (oppPts >= 1) stealDefNum++;
          } else {
            // Team didn't have hammer (opponent had hammer)
            // ForceEff: opponent scored exactly 1 / total ends opponent scored
            if (oppPts >= 1) {
              forceEffDenom++;
              if (oppPts === 1) forceEffNum++;
            }
            // StealEff: stole 1+ / total ends without hammer
            stealEffDenom++;
            if (teamPts >= 1) stealEffNum++;
          }
        });

        // Format efficiency as "num/denom" for easy season aggregation
        const hammerEff = hammerEffDenom > 0 ? `${hammerEffNum}/${hammerEffDenom}` : '';
        const forceEff = forceEffDenom > 0 ? `${forceEffNum}/${forceEffDenom}` : '';
        const stealEff = stealEffDenom > 0 ? `${stealEffNum}/${stealEffDenom}` : '';
        const stealDef = stealDefDenom > 0 ? `${stealDefNum}/${stealDefDenom}` : '';

        // Determine if this is a Mixed Doubles game
        const isMixedDoubles = gameType === "Mixed Doubles";

        const csvData = shotsToExport.map(s => ({
          'Team Name': exportTeamName,
          Name: exportTeam === 'opponent' ? s.position : (s.name || ''),
          'User ID': exportTeam === 'opponent' ? '' : (s.userId || ''),
          Date: formatDate(s.date),
          Opponent: exportTeam === 'opponent' ? teamName : s.opponent,
          Competition: isMixedDoubles ? '' : s.competition,
          'MD Competition': isMixedDoubles ? s.competition : '',
          Round: s.compRound,
          'Draw Weight': s.drawWeight || '',
          End: s.isLSD ? 'LSD' : s.end,
          'Power Play': s.isLSD ? '' : (s.powerPlay || ''),
          Hammer: s.isLSD ? '' : s.hammer,
          'Shot Number': s.isLSD ? s.lsdNumber : (s.teamShotNumber || s.shotNumber),
          Position: s.isLSD ? (s.position || '') : s.position,
          Turn: s.turn === 'In-Turn' ? 'Clockwise' : s.turn === 'Out-Turn' ? 'Counter Clockwise' : (s.turn || ''),
          'Shot Type': s.isLSD ? 'LSD' : (s.shotType || ''),
          Outcome: s.outcome === null ? '' : s.outcome,
          'Primary Miss': s.isLSD ? '' : (s.miss || ''),
          'Secondary Miss': s.isLSD ? '' : (s.secondaryMiss || ''),
          'Shot Weight': s.isLSD ? '' : (s.weight || ''),
          'Key Shot': s.isLSD ? '' : (s.keyShot || ''),
          'Target Direction': s.isLSD ? '' : (s.targetDirection || ''),
          'Target Depth': s.isLSD ? '' : (s.targetDepth || ''),
          Comments: s.comments || '',
          ScoreDiff: s.isLSD ? '' : getScoreDiff(s.end),
          EndOutcome: s.isLSD ? '' : (endPoints[s.end] !== '' ? endPoints[s.end] : ''),
          GameOutcome: stats ? stats.gameOutcome : ''
        }));

        const csv = Papa.unparse(csvData);
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const teamSuffix = exportTeam === 'opponent' ? '_opponent' : '';
        a.download = `curling_shots_${gameDate.split('-').reverse().join('-')}${teamSuffix}.csv`;
        a.click();
        URL.revokeObjectURL(url);
        onNotify(`Shot CSV exported for ${exportTeamName}!`, "success");
      };

      // Export Team Stats CSV (aggregated player stats)
      const exportTeamStatsCSV = (exportTeam = 'team') => {
        const isExportingOpponent = exportTeam === 'opponent';
        const exportTeamName = isExportingOpponent ? opponent : teamName;
        const currentShots = isExportingOpponent ? opponentShots : teamShots;
        
        // Shot type categorization
        const DRAW_SHOTS = ["Draw", "Tap", "Center Guard", "Corner Guard", "Freeze", "Trick Shot"];
        const TAKEOUT_SHOTS = ["Dig", "Peel", "Double Peel", "Takeout", "Double Takeout", "Hit and Roll", "Runback"];
        
        // Build player stats
        const playerStats = {};
        currentShots.forEach(shot => {
          if (!shot.name || shot.outcome === null) return;
          
          if (!playerStats[shot.name]) {
            playerStats[shot.name] = {
              name: shot.name,
              cwDraw: { total: 0, count: 0 },
              cwTakeout: { total: 0, count: 0 },
              ccwDraw: { total: 0, count: 0 },
              ccwTakeout: { total: 0, count: 0 }
            };
          }
          
          const p = playerStats[shot.name];
          const isDraw = DRAW_SHOTS.includes(shot.shotType);
          const isTakeout = TAKEOUT_SHOTS.includes(shot.shotType);
          const isCW = shot.turn === 'In-Turn'; // Clockwise
          const isCCW = shot.turn === 'Out-Turn'; // Counter Clockwise
          
          if (isDraw && isCW) {
            p.cwDraw.total += shot.outcome;
            p.cwDraw.count++;
          } else if (isDraw && isCCW) {
            p.ccwDraw.total += shot.outcome;
            p.ccwDraw.count++;
          } else if (isTakeout && isCW) {
            p.cwTakeout.total += shot.outcome;
            p.cwTakeout.count++;
          } else if (isTakeout && isCCW) {
            p.ccwTakeout.total += shot.outcome;
            p.ccwTakeout.count++;
          }
        });
        
        // Calculate ends with/without hammer and efficiency stats
        // Note: s.score is PER-END score (e.g., "2-0" means team scored 2 that end)
        const endStats = {};
        currentShots.forEach(s => {
          if (!endStats[s.end]) {
            endStats[s.end] = {
              hammer: s.hammer,
              teamScore: 0,
              oppScore: 0
            };
          }
          if (s.score) {
            const [ts, os] = s.score.split('-').map(Number);
            endStats[s.end].teamScore = ts;
            endStats[s.end].oppScore = os;
          }
        });
        
        // Count ends with/without hammer and calculate efficiencies
        // Since s.score is already per-end, we use it directly (no need to calculate differences)
        let endsWithHammer = 0;
        let endsWithoutHammer = 0;
        let hammerEffNum = 0, hammerEffDenom = 0;
        let forceEffNum = 0, forceEffDenom = 0;
        let stealEffNum = 0, stealEffDenom = 0;
        let stealDefNum = 0, stealDefDenom = 0;
        
        Object.entries(endStats).forEach(([end, data]) => {
          const hadHammer = data.hammer === exportTeamName;
          const teamPts = data.teamScore;  // Per-end score (not cumulative)
          const oppPts = data.oppScore;    // Per-end score (not cumulative)
          const isBlank = teamPts === 0 && oppPts === 0;
          
          if (hadHammer) {
            endsWithHammer++;
            // HammerEff: scored 2+ / not blank
            if (!isBlank) {
              hammerEffDenom++;
              if (teamPts >= 2) hammerEffNum++;
            }
            // StealDef: gave up steal / total ends with hammer
            stealDefDenom++;
            if (oppPts >= 1) stealDefNum++;
          } else {
            endsWithoutHammer++;
            // ForceEff: opponent scored 1 / total ends opponent scored
            if (oppPts >= 1) {
              forceEffDenom++;
              if (oppPts === 1) forceEffNum++;
            }
            // StealEff: stole 1+ / total ends without hammer
            stealEffDenom++;
            if (teamPts >= 1) stealEffNum++;
          }
        });
        
        // Calculate decimal efficiencies
        const hammerEff = hammerEffDenom > 0 ? (hammerEffNum / hammerEffDenom).toFixed(3) : '';
        const forceEff = forceEffDenom > 0 ? (forceEffNum / forceEffDenom).toFixed(3) : '';
        const stealEff = stealEffDenom > 0 ? (stealEffNum / stealEffDenom).toFixed(3) : '';
        const stealDef = stealDefDenom > 0 ? (stealDefNum / stealDefDenom).toFixed(3) : '';
        
        // Calculate percentage (as integer) for each category
        const calcPct = (data) => {
          if (data.count === 0) return '';
          return Math.round((data.total / (data.count * 4)) * 100);
        };
        
        // Determine if this is a Mixed Doubles game
        const isMixedDoubles = gameType === "Mixed Doubles";
        
        // Build CSV rows
        const csvData = Object.values(playerStats).map(p => ({
          'Name': p.name,
          'Competition': isMixedDoubles ? '' : competition,
          'MD Competition': isMixedDoubles ? competition : '',
          'Competition Round': compRound,
          'Opponent': isExportingOpponent ? teamName : opponent,
          'CW Draw %': calcPct(p.cwDraw),
          'CW Draw Count': p.cwDraw.count || '',
          'CW Takeout %': calcPct(p.cwTakeout),
          'CW Takeout Count': p.cwTakeout.count || '',
          'CCW Draw %': calcPct(p.ccwDraw),
          'CCW Draw Count': p.ccwDraw.count || '',
          'CCW Takeout %': calcPct(p.ccwTakeout),
          'CCW Takeout Count': p.ccwTakeout.count || '',
          'Ends w/Hammer': endsWithHammer,
          'Ends w/o Hammer': endsWithoutHammer,
          'Hammer Efficiency': hammerEff,
          'Force Efficiency': forceEff,
          'Steal Defense': stealDef,
          'Steal Efficiency': stealEff
        }));
        
        const csv = Papa.unparse(csvData);
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const teamSuffix = exportTeam === 'opponent' ? '_opponent' : '';
        a.download = `curling_team_stats_${gameDate.split('-').reverse().join('-')}${teamSuffix}.csv`;
        a.click();
        URL.revokeObjectURL(url);
        onNotify(`Team Stats CSV exported for ${exportTeamName}!`, "success");
      };

      const exportPDF = (exportTeam = 'team') => {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        
        // Determine which data to use
        const isExportingOpponent = exportTeam === 'opponent';
        const exportTeamName = isExportingOpponent ? opponent : teamName;
        const exportOpponentName = isExportingOpponent ? teamName : opponent;
        const currentShots = isExportingOpponent ? opponentShots : teamShots;
        
        // Colors
        const primaryColor = [196, 30, 58]; // #c41e3a
        const secondaryColor = [26, 26, 46]; // #1a1a2e
        const textLight = [107, 114, 128]; // #6b7280
        const accentColor = [20, 184, 166]; // teal
        const errorColor = [239, 68, 68]; // red
        const warningColor = [245, 158, 11]; // amber
        
        let yPos = 20;
        const pageWidth = doc.internal.pageSize.getWidth();
        const pageHeight = doc.internal.pageSize.getHeight();
        const margin = 15;
        const contentWidth = pageWidth - (margin * 2);
        const maxY = pageHeight - 15;
        
        const ensureSpace = (requiredSpace) => {
          if (yPos + requiredSpace > maxY) {
            doc.addPage();
            yPos = 20;
            return true;
          }
          return false;
        };
        
        // ===== GAME SUMMARY =====
        doc.setFontSize(24);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(...secondaryColor);
        doc.text('USA CURLING SHOT TRACKER', pageWidth / 2, yPos, { align: 'center' });
        yPos += 12;
        
        doc.setFontSize(14);
        doc.setFont('helvetica', 'normal');
        doc.setTextColor(...textLight);
        doc.text(`${teamName} vs ${opponent}`, pageWidth / 2, yPos, { align: 'center' });
        yPos += 6;
        
        if (isExportingOpponent) {
          doc.setFontSize(10);
          doc.setTextColor(...primaryColor);
          doc.text(`(${opponent} Stats)`, pageWidth / 2, yPos, { align: 'center' });
          yPos += 6;
        }
        
        doc.setFontSize(10);
        doc.setTextColor(...textLight);
        doc.text(`${competition} ‚Ä¢ ${compRound} ‚Ä¢ ${gameDate}`, pageWidth / 2, yPos, { align: 'center' });
        yPos += 15;
        
        // Score Display
        doc.setFontSize(36);
        doc.setFont('helvetica', 'bold');
        const teamScoreColor = stats.totalTeamScore > stats.totalOppScore ? [45, 106, 79] : secondaryColor;
        const oppScoreColor = stats.totalOppScore > stats.totalTeamScore ? [45, 106, 79] : secondaryColor;
        doc.setTextColor(...teamScoreColor);
        doc.text(String(stats.totalTeamScore), pageWidth / 2 - 25, yPos, { align: 'center' });
        doc.setTextColor(...secondaryColor);
        doc.text('-', pageWidth / 2, yPos, { align: 'center' });
        doc.setTextColor(...oppScoreColor);
        doc.text(String(stats.totalOppScore), pageWidth / 2 + 25, yPos, { align: 'center' });
        yPos += 10;
        
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        doc.setTextColor(...textLight);
        doc.text(teamName, pageWidth / 2 - 25, yPos, { align: 'center' });
        doc.text(opponent, pageWidth / 2 + 25, yPos, { align: 'center' });
        yPos += 15;
        
        // ===== SCORE BY END TABLE =====
        ensureSpace(30);
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(...secondaryColor);
        doc.text('SCORE BY END', margin, yPos);
        yPos += 8;
        
        doc.setFontSize(8);
        doc.setFont('helvetica', 'bold');
        const endCols = totalEnds + 3;
        const colWidth = contentWidth / endCols;
        
        doc.setFillColor(240, 240, 240);
        doc.rect(margin, yPos - 4, contentWidth, 8, 'F');
        
        let xPos = margin;
        doc.text('Team', xPos + 2, yPos);
        xPos += colWidth * 1.5;
        doc.text('H', xPos + 2, yPos);
        xPos += colWidth * 0.5;
        for (let i = 1; i <= totalEnds; i++) {
          doc.text(String(i), xPos + colWidth/2, yPos, { align: 'center' });
          xPos += colWidth * 0.7;
        }
        doc.text('EE', xPos + colWidth/2, yPos, { align: 'center' });
        yPos += 8;
        
        doc.setFont('helvetica', 'normal');
        xPos = margin;
        doc.text(teamName.substring(0, 12), xPos + 2, yPos);
        xPos += colWidth * 1.5;
        doc.text(firstHammerTeam === teamName ? '*' : '', xPos + 2, yPos);
        xPos += colWidth * 0.5;
        for (let i = 1; i <= totalEnds; i++) {
          const endData = stats.endScores.find(e => e.end === i);
          const maxPlayedEnd = Math.max(...stats.endScores.map(e => e.end), 0);
          let val = '';
          if (endData) val = String(endData.teamScore);
          else if (gameEnded && i > maxPlayedEnd) val = 'X';
          doc.text(val, xPos + colWidth/2, yPos, { align: 'center' });
          xPos += colWidth * 0.7;
        }
        doc.text(stats.extraEndTeamScore !== undefined ? String(stats.extraEndTeamScore) : '', xPos + colWidth/2, yPos, { align: 'center' });
        yPos += 6;
        
        xPos = margin;
        doc.text(opponent.substring(0, 12), xPos + 2, yPos);
        xPos += colWidth * 1.5;
        doc.text(firstHammerTeam === opponent ? '*' : '', xPos + 2, yPos);
        xPos += colWidth * 0.5;
        for (let i = 1; i <= totalEnds; i++) {
          const endData = stats.endScores.find(e => e.end === i);
          const maxPlayedEnd = Math.max(...stats.endScores.map(e => e.end), 0);
          let val = '';
          if (endData) val = String(endData.oppScore);
          else if (gameEnded && i > maxPlayedEnd) val = 'X';
          doc.text(val, xPos + colWidth/2, yPos, { align: 'center' });
          xPos += colWidth * 0.7;
        }
        doc.text(stats.extraEndOppScore !== undefined ? String(stats.extraEndOppScore) : '', xPos + colWidth/2, yPos, { align: 'center' });
        yPos += 15;
        
        // ===== SHOOTING PERCENTAGE =====
        ensureSpace(35);
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(...secondaryColor);
        doc.text('SHOOTING PERCENTAGE', margin, yPos);
        yPos += 10;
        
        // Overall percentage - large display
        doc.setFontSize(28);
        doc.setTextColor(...primaryColor);
        doc.text(`${stats.overallPct}%`, margin, yPos);
        doc.setFontSize(10);
        doc.setTextColor(...textLight);
        doc.text('Overall', margin + 35, yPos - 3);
        yPos += 12;
        
        // End percentages in a row
        doc.setFontSize(9);
        xPos = margin;
        stats.endPercentages.forEach(e => {
          if (xPos + 25 > pageWidth - margin) {
            xPos = margin;
            yPos += 12;
          }
          doc.setFillColor(232, 244, 248);
          doc.rect(xPos, yPos - 6, 22, 10, 'F');
          doc.setTextColor(...textLight);
          doc.text(`E${e.end}`, xPos + 2, yPos);
          doc.setTextColor(...secondaryColor);
          doc.setFont('helvetica', 'bold');
          doc.text(`${e.pct}%`, xPos + 12, yPos);
          doc.setFont('helvetica', 'normal');
          xPos += 25;
        });
        yPos += 18;
        
        // ===== SHOT SUCCESS ANALYSIS TABLE =====
        const ssaRowHeight = 7;
        const ssaHeaderHeight = 16;
        const ssaTotalHeight = ssaHeaderHeight + (stats.playerTable.length * ssaRowHeight) + ssaRowHeight + 10;
        ensureSpace(ssaTotalHeight);
        
        doc.setFontSize(12);
        doc.setFont('helvetica', 'bold');
        doc.setTextColor(...secondaryColor);
        doc.text('SHOT SUCCESS ANALYSIS', margin, yPos);
        yPos += 8;
        
        doc.setFontSize(7);
        doc.setFillColor(240, 240, 240);
        doc.rect(margin, yPos - 4, contentWidth, 8, 'F');
        
        const ssaCols = [45, 18, 18, 18, 18, 18, 18, 18];
        xPos = margin;
        ['Player', 'IT', 'OT', 'Draws', 'IT', 'OT', 'T-Outs', 'Game'].forEach((header, i) => {
          doc.text(header, xPos + 2, yPos);
          xPos += ssaCols[i];
        });
        yPos += 8;
        
        doc.setFont('helvetica', 'normal');
        doc.setFontSize(7);
        
        const formatStat = (count, pct) => {
          if (count === 0) return '-';
          return `(${count}) ${pct}%`;
        };
        
        stats.playerTable.forEach((player, idx) => {
          if (idx % 2 === 0) {
            doc.setFillColor(248, 248, 248);
            doc.rect(margin, yPos - 4, contentWidth, 7, 'F');
          }
          
          xPos = margin;
          doc.setTextColor(...secondaryColor);
          doc.text(player.name.substring(0, 18), xPos + 2, yPos);
          xPos += ssaCols[0];
          doc.text(formatStat(player.draws.inTurnCount, player.draws.inTurnPct), xPos + 2, yPos);
          xPos += ssaCols[1];
          doc.text(formatStat(player.draws.outTurnCount, player.draws.outTurnPct), xPos + 2, yPos);
          xPos += ssaCols[2];
          doc.text(formatStat(player.draws.totalCount, player.draws.totalPct), xPos + 2, yPos);
          xPos += ssaCols[3];
          doc.text(formatStat(player.takeouts.inTurnCount, player.takeouts.inTurnPct), xPos + 2, yPos);
          xPos += ssaCols[4];
          doc.text(formatStat(player.takeouts.outTurnCount, player.takeouts.outTurnPct), xPos + 2, yPos);
          xPos += ssaCols[5];
          doc.text(formatStat(player.takeouts.totalCount, player.takeouts.totalPct), xPos + 2, yPos);
          xPos += ssaCols[6];
          doc.text(formatStat(player.total.count, player.total.pct), xPos + 2, yPos);
          yPos += 7;
        });
        
        // Team Total row
        doc.setFillColor(26, 26, 46);
        doc.rect(margin, yPos - 4, contentWidth, 7, 'F');
        doc.setTextColor(255, 255, 255);
        doc.setFont('helvetica', 'bold');
        
        xPos = margin;
        doc.text('Team Total', xPos + 2, yPos);
        xPos += ssaCols[0];
        doc.text(formatStat(stats.teamRow.draws.inTurnCount, stats.teamRow.draws.inTurnPct), xPos + 2, yPos);
        xPos += ssaCols[1];
        doc.text(formatStat(stats.teamRow.draws.outTurnCount, stats.teamRow.draws.outTurnPct), xPos + 2, yPos);
        xPos += ssaCols[2];
        doc.text(formatStat(stats.teamRow.draws.totalCount, stats.teamRow.draws.totalPct), xPos + 2, yPos);
        xPos += ssaCols[3];
        doc.text(formatStat(stats.teamRow.takeouts.inTurnCount, stats.teamRow.takeouts.inTurnPct), xPos + 2, yPos);
        xPos += ssaCols[4];
        doc.text(formatStat(stats.teamRow.takeouts.outTurnCount, stats.teamRow.takeouts.outTurnPct), xPos + 2, yPos);
        xPos += ssaCols[5];
        doc.text(formatStat(stats.teamRow.takeouts.totalCount, stats.teamRow.takeouts.totalPct), xPos + 2, yPos);
        xPos += ssaCols[6];
        doc.text(formatStat(stats.teamRow.total.count, stats.teamRow.total.pct), xPos + 2, yPos);
        yPos += 15;
        
        // ===== TARGET HEAT MAPS =====
        // Calculate heat map data for all shots
        const TARGET_DIRECTIONS = ['Left', 'Center', 'Right'];
        const TARGET_DEPTHS = ['Back 12', 'Back 8', 'Back 4', 'T-Line', 'Top 4', 'Top 8', 'Top 12', 'Tight Guard', 'Mid Guard', 'High Guard'];
        
        const DRAW_SHOT_TYPES = ['Center Guard', 'Corner Guard', 'Draw', 'Freeze', 'Tap'];
        const TAKEOUT_SHOT_TYPES = ['Dig', 'Peel', 'Double Peel', 'Takeout', 'Double Takeout', 'Hit and Roll', 'Runback'];
        
        const initHeatMap = () => {
          const map = {};
          TARGET_DEPTHS.forEach(depth => {
            map[depth] = {};
            TARGET_DIRECTIONS.forEach(dir => {
              map[depth][dir] = { total: 0, sum: 0, count: 0 };
            });
          });
          return map;
        };
        
        const drawHeatMap = initHeatMap();
        const takeoutHeatMap = initHeatMap();
        
        currentShots.forEach(shot => {
          if (!shot.targetDirection || shot.targetDirection === '---' || 
              !shot.targetDepth || shot.targetDepth === '---' ||
              shot.outcome === null) return;
          
          const isDrawShot = DRAW_SHOT_TYPES.includes(shot.shotType);
          const isTakeoutShot = TAKEOUT_SHOT_TYPES.includes(shot.shotType);
          
          if (isDrawShot && drawHeatMap[shot.targetDepth]) {
            drawHeatMap[shot.targetDepth][shot.targetDirection].total += shot.outcome;
            drawHeatMap[shot.targetDepth][shot.targetDirection].sum += 4;
            drawHeatMap[shot.targetDepth][shot.targetDirection].count++;
          } else if (isTakeoutShot && takeoutHeatMap[shot.targetDepth]) {
            takeoutHeatMap[shot.targetDepth][shot.targetDirection].total += shot.outcome;
            takeoutHeatMap[shot.targetDepth][shot.targetDirection].sum += 4;
            takeoutHeatMap[shot.targetDepth][shot.targetDirection].count++;
          }
        });
        
        const hasDrawData = Object.values(drawHeatMap).some(row => 
          Object.values(row).some(cell => cell.count > 0)
        );
        const hasTakeoutData = Object.values(takeoutHeatMap).some(row => 
          Object.values(row).some(cell => cell.count > 0)
        );
        
        if (hasDrawData || hasTakeoutData) {
          ensureSpace(85);
          
          doc.setFontSize(12);
          doc.setFont('helvetica', 'bold');
          doc.setTextColor(...secondaryColor);
          doc.text('TARGET HEAT MAPS', margin, yPos);
          yPos += 10;
          
          const getHeatColor = (pct) => {
            if (pct === null) return [229, 231, 235];
            if (pct >= 90) return [34, 197, 94];
            if (pct >= 83) return [132, 204, 22];
            if (pct >= 75) return [250, 204, 21];
            if (pct >= 70) return [251, 146, 60];
            return [239, 68, 68];
          };
          
          const renderHeatMapPDF = (heatMap, title, startX) => {
            const cellW = 22;
            const cellH = 7;
            const labelW = 25;
            
            // Title
            doc.setFontSize(9);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...secondaryColor);
            doc.text(title, startX + labelW + (cellW * 1.5), yPos, { align: 'center' });
            
            let localY = yPos + 6;
            
            // Column headers
            doc.setFontSize(6);
            TARGET_DIRECTIONS.forEach((dir, i) => {
              doc.text(dir, startX + labelW + (i * cellW) + (cellW / 2), localY, { align: 'center' });
            });
            localY += 4;
            
            // Rows
            TARGET_DEPTHS.forEach(depth => {
              // Row label
              doc.setFontSize(5);
              doc.setTextColor(...textLight);
              const shortDepth = depth.replace('Guard', 'G').replace('High', 'Hi').replace('Tight', 'Tgt');
              doc.text(shortDepth, startX + labelW - 2, localY + 3, { align: 'right' });
              
              // Cells
              TARGET_DIRECTIONS.forEach((dir, i) => {
                const cell = heatMap[depth][dir];
                const pct = cell.count > 0 ? Math.round((cell.total / cell.sum) * 100) : null;
                const color = getHeatColor(pct);
                
                doc.setFillColor(...color);
                doc.rect(startX + labelW + (i * cellW), localY - 1, cellW - 1, cellH, 'F');
                
                if (pct !== null) {
                  doc.setFontSize(5);
                  doc.setTextColor(pct >= 75 ? 0 : 255, pct >= 75 ? 0 : 255, pct >= 75 ? 0 : 255);
                  doc.text(`${pct}%`, startX + labelW + (i * cellW) + (cellW / 2), localY + 3, { align: 'center' });
                  doc.setFontSize(4);
                  doc.text(`(${cell.count})`, startX + labelW + (i * cellW) + (cellW / 2), localY + 5.5, { align: 'center' });
                }
              });
              
              localY += cellH;
            });
            
            return localY;
          };
          
          const halfWidth = contentWidth / 2 - 5;
          let maxY = yPos;
          
          if (hasDrawData) {
            maxY = Math.max(maxY, renderHeatMapPDF(drawHeatMap, 'DRAWS', margin));
          }
          if (hasTakeoutData) {
            const takeoutY = renderHeatMapPDF(takeoutHeatMap, 'TAKEOUTS', margin + halfWidth + 10);
            maxY = Math.max(maxY, takeoutY);
          }
          
          yPos = maxY + 8;
          
          // Legend
          doc.setFontSize(6);
          doc.setFont('helvetica', 'normal');
          const legendItems = [
            { label: '90%+', color: [34, 197, 94] },
            { label: '75-89%', color: [132, 204, 22] },
            { label: '60-74%', color: [250, 204, 21] },
            { label: '45-59%', color: [251, 146, 60] },
            { label: '<45%', color: [239, 68, 68] }
          ];
          
          xPos = margin;
          legendItems.forEach(item => {
            doc.setFillColor(...item.color);
            doc.rect(xPos, yPos - 2, 8, 4, 'F');
            doc.setTextColor(...textLight);
            doc.text(item.label, xPos + 10, yPos + 1);
            xPos += 28;
          });
        }
        
        // ===== MISS ANALYSIS =====
        const missShots = currentShots.filter(s => s.miss || s.secondaryMiss);
        
        if (missShots.length > 0) {
          // Calculate miss breakdowns
          const turnCounts = {};
          const shotTypeCounts = {};
          const primaryCounts = {};
          const secondaryCounts = {};
          
          missShots.forEach(s => {
            if (s.turn) turnCounts[s.turn] = (turnCounts[s.turn] || 0) + 1;
            if (s.shotType) shotTypeCounts[s.shotType] = (shotTypeCounts[s.shotType] || 0) + 1;
            if (s.miss) primaryCounts[s.miss] = (primaryCounts[s.miss] || 0) + 1;
            if (s.secondaryMiss) secondaryCounts[s.secondaryMiss] = (secondaryCounts[s.secondaryMiss] || 0) + 1;
          });
          
          const allBreakdowns = [
            { title: 'By Turn', data: turnCounts, color: primaryColor },
            { title: 'By Shot Type', data: shotTypeCounts, color: accentColor },
            { title: 'By Primary Miss', data: primaryCounts, color: secondaryColor },
            { title: 'By Secondary Miss', data: secondaryCounts, color: warningColor }
          ].filter(b => Object.keys(b.data).length > 0);
          
          if (allBreakdowns.length > 0) {
            const maxRows = Math.max(...allBreakdowns.map(b => Object.keys(b.data).length));
            const missAnalysisHeight = 20 + (maxRows * 8) + 10;
            ensureSpace(missAnalysisHeight);
            
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.setTextColor(...secondaryColor);
            doc.text(`MISS ANALYSIS (${missShots.length} total misses)`, margin, yPos);
            yPos += 10;
            
            // Render breakdowns in columns
            const numCols = Math.min(allBreakdowns.length, 4);
            const breakdownColWidth = contentWidth / numCols;
            const startY = yPos;
            
            allBreakdowns.forEach((breakdown, colIdx) => {
              const colX = margin + (colIdx * breakdownColWidth);
              let localY = startY;
              
              // Column header
              doc.setFontSize(9);
              doc.setFont('helvetica', 'bold');
              doc.setTextColor(...breakdown.color);
              doc.text(breakdown.title, colX, localY);
              localY += 6;
              
              // Entries
              const entries = Object.entries(breakdown.data).sort((a, b) => b[1] - a[1]);
              const max = Math.max(...entries.map(e => e[1]));
              
              doc.setFontSize(7);
              doc.setFont('helvetica', 'normal');
              
              entries.forEach(([label, count]) => {
                const displayLabel = label === 'In-Turn' ? 'Clockwise' : label === 'Out-Turn' ? 'Counter CW' : label;
                const pct = ((count / missShots.length) * 100).toFixed(0);
                const barWidth = (count / max) * (breakdownColWidth - 30);
                
                // Draw bar
                doc.setFillColor(...breakdown.color);
                doc.rect(colX, localY - 3, barWidth, 4, 'F');
                
                // Label and count
                doc.setTextColor(...secondaryColor);
                const truncLabel = displayLabel.length > 12 ? displayLabel.substring(0, 11) + '.' : displayLabel;
                doc.text(`${truncLabel}: ${count} (${pct}%)`, colX, localY + 4);
                localY += 8;
              });
            });
            
            yPos = startY + (maxRows * 8) + 10;
          }
        }
        
        // Save PDF
        const teamSuffix = isExportingOpponent ? '_opponent' : '';
        doc.save(`curling_analytics_${gameDate.split('-').reverse().join('-')}${teamSuffix}.pdf`);
        onNotify(`PDF exported for ${exportTeamName}!`, "success");
      };

      const handleNewGame = () => {
        dispatch({ type: 'NEW_GAME' });
        Storage.remove('curlingGame');
        setShowNewGame(false);
        onNotify("New game started!", "success");
      };

      if (!stats) {
        return (
          <div style={styles.card}>
            <p style={{ textAlign: 'center', color: 'var(--text-light)' }}>
              No shots recorded yet. Start tracking to see analytics.
            </p>
          </div>
        );
      }

      // Style helpers for the Shot Success table
      const statCellStyle = {
        ...styles.td,
        padding: '6px 8px',
        fontSize: '13px',
        textAlign: 'center'
      };

      const headerCellStyle = {
        ...styles.th,
        padding: '8px',
        fontSize: '12px',
        textAlign: 'center'
      };

      // Cell style with left border for section dividers
      const sectionStartCell = {
        ...statCellStyle,
        borderLeft: '2px solid var(--secondary)'
      };

      const sectionStartHeader = {
        ...headerCellStyle,
        borderLeft: '2px solid var(--secondary)'
      };

      const formatStat = (count, pct) => {
        if (count === 0 || pct === null) return "-";
        return `(${count}) ${pct}%`;
      };

      // Get first end hammer team
      const firstHammerTeam = firstEndHammer || teamName;

      return (
        <div>
          {/* Sub-tabs for Both Teams mode */}
          {isBothTeams && (
            <div style={{ 
              display: 'flex', 
              gap: '8px', 
              marginBottom: '16px',
              background: 'var(--ice)',
              padding: '8px',
              borderRadius: 'var(--radius)'
            }}>
              <button
                style={{
                  flex: 1,
                  padding: '12px 20px',
                  border: 'none',
                  borderRadius: 'var(--radius-sm)',
                  fontSize: '14px',
                  fontWeight: '600',
                  cursor: 'pointer',
                  background: analyticsTab === 'team' ? 'var(--secondary)' : 'transparent',
                  color: analyticsTab === 'team' ? 'white' : 'var(--text)'
                }}
                onClick={() => setAnalyticsTab('team')}
              >
                {teamName}
              </button>
              <button
                style={{
                  flex: 1,
                  padding: '12px 20px',
                  border: 'none',
                  borderRadius: 'var(--radius-sm)',
                  fontSize: '14px',
                  fontWeight: '600',
                  cursor: 'pointer',
                  background: analyticsTab === 'opponent' ? 'var(--primary)' : 'transparent',
                  color: analyticsTab === 'opponent' ? 'white' : 'var(--text)'
                }}
                onClick={() => setAnalyticsTab('opponent')}
              >
                {opponent}
              </button>
            </div>
          )}

          {/* Score by End Table with Cumulative - Full Width */}
          <div style={styles.card}>
            <h2 style={styles.cardTitle}>SCORE BY END</h2>
            <div style={{ overflowX: 'auto' }}>
              <table style={{ ...styles.table, fontSize: '13px', borderCollapse: 'collapse', border: '1px solid var(--text-light)' }}>
                <thead>
                  <tr>
                    <th style={{ ...headerCellStyle, borderRight: '1px solid var(--text-light)' }}>Team</th>
                    <th style={{ ...headerCellStyle, borderRight: '1px solid var(--text-light)' }}>*</th>
                    {Array.from({ length: totalEnds }, (_, i) => i + 1).map(endNum => (
                      <th key={endNum} style={{ ...headerCellStyle, borderRight: '1px solid var(--text-light)' }}>{endNum}</th>
                    ))}
                    <th style={{ ...headerCellStyle, borderRight: '1px solid var(--text-light)' }}>EE</th>
                    <th style={{ ...headerCellStyle, background: 'var(--secondary)', color: 'white' }}>Total</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td style={{ ...statCellStyle, fontWeight: '600', textAlign: 'left', borderRight: '1px solid var(--text-light)' }}>{teamName}</td>
                    <td style={{ ...statCellStyle, borderRight: '1px solid var(--text-light)' }}>{firstHammerTeam === teamName ? 'üî®' : ''}</td>
                    {Array.from({ length: totalEnds }, (_, i) => i + 1).map(endNum => {
                      const endData = stats.endScores.find(e => e.end === endNum);
                      const maxPlayedEnd = Math.max(...stats.endScores.map(e => e.end), 0);
                      let displayValue = '';
                      if (endData) {
                        displayValue = endData.teamScore;
                      } else if (gameEnded && endNum > maxPlayedEnd) {
                        displayValue = 'X';
                      }
                      return (
                        <td key={endNum} style={{ 
                          ...statCellStyle, 
                          fontWeight: endData && endData.teamScore > 0 ? '700' : '400',
                          borderRight: '1px solid var(--text-light)'
                        }}>
                          {displayValue}
                        </td>
                      );
                    })}
                    <td style={{ ...statCellStyle, borderRight: '1px solid var(--text-light)' }}>
                      {stats.extraEndTeamScore !== undefined ? stats.extraEndTeamScore : ''}
                    </td>
                    <td style={{ ...statCellStyle, fontWeight: '700', background: 'var(--ice-dark)' }}>
                      {stats.totalTeamScore}
                    </td>
                  </tr>
                  <tr>
                    <td style={{ ...statCellStyle, fontWeight: '600', textAlign: 'left', borderRight: '1px solid var(--text-light)' }}>{opponent}</td>
                    <td style={{ ...statCellStyle, borderRight: '1px solid var(--text-light)' }}>{firstHammerTeam === opponent ? 'üî®' : ''}</td>
                    {Array.from({ length: totalEnds }, (_, i) => i + 1).map(endNum => {
                      const endData = stats.endScores.find(e => e.end === endNum);
                      const maxPlayedEnd = Math.max(...stats.endScores.map(e => e.end), 0);
                      let displayValue = '';
                      if (endData) {
                        displayValue = endData.oppScore;
                      } else if (gameEnded && endNum > maxPlayedEnd) {
                        displayValue = 'X';
                      }
                      return (
                        <td key={endNum} style={{ 
                          ...statCellStyle, 
                          fontWeight: endData && endData.oppScore > 0 ? '700' : '400',
                          borderRight: '1px solid var(--text-light)'
                        }}>
                          {displayValue}
                        </td>
                      );
                    })}
                    <td style={{ ...statCellStyle, borderRight: '1px solid var(--text-light)' }}>
                      {stats.extraEndOppScore !== undefined ? stats.extraEndOppScore : ''}
                    </td>
                    <td style={{ ...statCellStyle, fontWeight: '700', background: 'var(--ice-dark)' }}>
                      {stats.totalOppScore}
                    </td>
                  </tr>
                </tbody>
              </table>
              <div style={{ fontSize: '11px', color: 'var(--text-light)', marginTop: '4px' }}>
                üî® = Hammer in 1st End ‚Ä¢ X = Unplayed ‚Ä¢ EE = Extra End
              </div>
            </div>
          </div>

          {/* Shot Success Analysis Table */}
          <div style={styles.card}>
            <h2 style={styles.cardTitle}>SHOT SUCCESS ANALYSIS</h2>
            <div style={{ overflowX: 'auto' }}>
              <table style={{ ...styles.table, fontSize: '13px', borderCollapse: 'collapse' }}>
                <thead>
                  <tr>
                    <th style={headerCellStyle} rowSpan={2}>Player</th>
                    <th style={{ ...sectionStartHeader }} colSpan={3}>Draws</th>
                    <th style={{ ...sectionStartHeader }} colSpan={3}>Take-outs</th>
                    <th style={{ ...sectionStartHeader }} rowSpan={2}>Game</th>
                  </tr>
                  <tr>
                    <th style={sectionStartHeader}>‚Üª</th>
                    <th style={headerCellStyle}>‚Ü∫</th>
                    <th style={headerCellStyle}>Total</th>
                    <th style={sectionStartHeader}>‚Üª</th>
                    <th style={headerCellStyle}>‚Ü∫</th>
                    <th style={headerCellStyle}>Total</th>
                  </tr>
                </thead>
                <tbody>
                  {stats.playerTable.map((p, idx) => (
                    <tr key={p.name} style={{ background: idx % 2 === 0 ? 'white' : 'var(--ice)' }}>
                      <td style={{ ...statCellStyle, textAlign: 'left', fontWeight: '500' }}>
                        {p.name}
                      </td>
                      <td style={sectionStartCell}>{formatStat(p.draws.inTurnCount, p.draws.inTurnPct)}</td>
                      <td style={statCellStyle}>{formatStat(p.draws.outTurnCount, p.draws.outTurnPct)}</td>
                      <td style={{ ...statCellStyle, fontWeight: '600' }}>{formatStat(p.draws.totalCount, p.draws.totalPct)}</td>
                      <td style={sectionStartCell}>{formatStat(p.takeouts.inTurnCount, p.takeouts.inTurnPct)}</td>
                      <td style={statCellStyle}>{formatStat(p.takeouts.outTurnCount, p.takeouts.outTurnPct)}</td>
                      <td style={{ ...statCellStyle, fontWeight: '600' }}>{formatStat(p.takeouts.totalCount, p.takeouts.totalPct)}</td>
                      <td style={{ ...sectionStartCell, fontWeight: '700', background: 'var(--ice-dark)' }}>{formatStat(p.total.count, p.total.pct)}</td>
                    </tr>
                  ))}
                  {/* Team Total Row */}
                  <tr style={{ background: 'var(--secondary)', color: 'white' }}>
                    <td style={{ ...statCellStyle, textAlign: 'left', fontWeight: '700' }}>Team Total</td>
                    <td style={{ ...sectionStartCell, color: 'white' }}>{formatStat(stats.teamRow.draws.inTurnCount, stats.teamRow.draws.inTurnPct)}</td>
                    <td style={{ ...statCellStyle, color: 'white' }}>{formatStat(stats.teamRow.draws.outTurnCount, stats.teamRow.draws.outTurnPct)}</td>
                    <td style={{ ...statCellStyle, fontWeight: '600', color: 'white' }}>{formatStat(stats.teamRow.draws.totalCount, stats.teamRow.draws.totalPct)}</td>
                    <td style={{ ...sectionStartCell, color: 'white' }}>{formatStat(stats.teamRow.takeouts.inTurnCount, stats.teamRow.takeouts.inTurnPct)}</td>
                    <td style={{ ...statCellStyle, color: 'white' }}>{formatStat(stats.teamRow.takeouts.outTurnCount, stats.teamRow.takeouts.outTurnPct)}</td>
                    <td style={{ ...statCellStyle, fontWeight: '600', color: 'white' }}>{formatStat(stats.teamRow.takeouts.totalCount, stats.teamRow.takeouts.totalPct)}</td>
                    <td style={{ ...sectionStartCell, fontWeight: '700', color: 'white' }}>{formatStat(stats.teamRow.total.count, stats.teamRow.total.pct)}</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div style={{ fontSize: '11px', color: 'var(--text-light)', marginTop: '8px' }}>
              ‚Üª = Clockwise ‚Ä¢ ‚Ü∫ = Counter Clockwise ‚Ä¢ Format: Count Percentage
            </div>
          </div>

          {/* Player Filter Section */}
          <div style={styles.card}>
            <h2 style={styles.cardTitle}>FILTER BY PLAYER</h2>
            <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
              <button
                onClick={() => setPlayerFilter('Team')}
                style={{
                  padding: '10px 20px',
                  borderRadius: 'var(--radius-sm)',
                  border: 'none',
                  cursor: 'pointer',
                  fontWeight: playerFilter === 'Team' ? '700' : '500',
                  background: playerFilter === 'Team' ? 'var(--primary)' : 'var(--ice)',
                  color: playerFilter === 'Team' ? 'white' : 'var(--text)',
                  fontSize: '14px'
                }}
              >
                Team
              </button>
              {playerNames.map(name => (
                <button
                  key={name}
                  onClick={() => setPlayerFilter(name)}
                  style={{
                    padding: '10px 20px',
                    borderRadius: 'var(--radius-sm)',
                    border: 'none',
                    cursor: 'pointer',
                    fontWeight: playerFilter === name ? '700' : '500',
                    background: playerFilter === name ? 'var(--secondary)' : 'var(--ice)',
                    color: playerFilter === name ? 'white' : 'var(--text)',
                    fontSize: '14px'
                  }}
                >
                  {name}
                </button>
              ))}
            </div>
            <div style={{ fontSize: '11px', color: 'var(--text-light)', marginTop: '8px' }}>
              Filter affects Miss Matrix, Shooting Percentages, and Heat Maps below
            </div>
          </div>

          {/* Shooting % and Shooting % by End - with interactive end selection */}
          <div style={styles.card}>
            <h2 style={styles.cardTitle}>SHOOTING PERCENTAGE {playerFilter !== 'Team' && `- ${playerFilter}`}</h2>
            <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap', alignItems: 'center' }}>
              {/* Overall Shooting % Button */}
              <button
                onClick={toggleTeamPct}
                style={{
                  background: showTeamPct ? 'var(--primary)' : 'var(--ice)',
                  color: showTeamPct ? 'white' : 'var(--text)',
                  padding: '12px 20px',
                  borderRadius: 'var(--radius-sm)',
                  border: 'none',
                  cursor: 'pointer',
                  textAlign: 'center',
                  minWidth: '90px',
                  fontWeight: showTeamPct ? '700' : '500'
                }}
              >
                <div style={{ fontSize: '12px', opacity: 0.8 }}>Overall</div>
                <div style={{ fontSize: '20px', fontWeight: '700' }}>{filteredStats.overallPct}%</div>
              </button>
              
              {/* End Buttons */}
              {filteredStats.endPercentages.map(e => (
                <button
                  key={e.end}
                  onClick={() => toggleEnd(e.end)}
                  style={{
                    background: selectedEnds.includes(e.end) ? 'var(--secondary)' : 'var(--ice)',
                    color: selectedEnds.includes(e.end) ? 'white' : 'var(--text)',
                    padding: '12px 20px',
                    borderRadius: 'var(--radius-sm)',
                    border: 'none',
                    cursor: 'pointer',
                    textAlign: 'center',
                    minWidth: '70px'
                  }}
                >
                  <div style={{ fontSize: '12px', opacity: 0.8 }}>End {e.end}</div>
                  <div style={{ fontWeight: '700', fontSize: '20px' }}>{e.pct}%</div>
                </button>
              ))}
            </div>
            <div style={{ fontSize: '11px', color: 'var(--text-light)', marginTop: '8px' }}>
              Click "Overall" for all stats, or click end buttons to filter heat maps by specific ends (multiple ends can be selected)
            </div>
          </div>

          {/* Target Heat Maps - Draws and Takeouts Side by Side */}
          {(() => {
            const hasDrawData = filteredHeatMaps.draws && Object.values(filteredHeatMaps.draws).some(row => 
              Object.values(row).some(cell => cell.count > 0)
            );
            const hasTakeoutData = filteredHeatMaps.takeouts && Object.values(filteredHeatMaps.takeouts).some(row => 
              Object.values(row).some(cell => cell.count > 0)
            );
            
            if (!hasDrawData && !hasTakeoutData) return null;
            
            const TARGET_DIRECTIONS = ['Left', 'Center', 'Right'];
            const TARGET_DEPTHS = ['Back 12', 'Back 8', 'Back 4', 'T-Line', 'Top 4', 'Top 8', 'Top 12', 'Tight Guard', 'Mid Guard', 'High Guard'];
            
            const getHeatColor = (pct) => {
              if (pct === null) return 'rgba(229, 231, 235, 0.7)';
              if (pct >= 90) return 'rgba(34, 197, 94, 0.8)';
              if (pct >= 83) return 'rgba(132, 204, 22, 0.8)';
              if (pct >= 75) return 'rgba(250, 204, 21, 0.8)';
              if (pct >= 70) return 'rgba(251, 146, 60, 0.8)';
              return 'rgba(239, 68, 68, 0.8)';
            };
            
            const cellWidth = 70;
            const cellHeight = 45;
            const labelWidth = 60;
            const gridWidth = cellWidth * 3;
            const gridHeight = cellHeight * 8;
            
            const renderHeatMap = (heatMapData, title) => {
              if (!heatMapData) return null;
              const hasData = Object.values(heatMapData).some(row => Object.values(row).some(cell => cell.count > 0));
              if (!hasData) return (
                <div style={{ flex: 1, minWidth: '280px' }}>
                  <h3 style={{ fontSize: '14px', fontWeight: '600', marginBottom: '12px', color: 'var(--secondary)', textAlign: 'center' }}>{title}</h3>
                  <p style={{ textAlign: 'center', color: 'var(--text-light)', padding: '20px' }}>No data for selected filter</p>
                </div>
              );
              
              return (
                <div style={{ flex: 1, minWidth: '280px' }}>
                  <h3 style={{ fontSize: '14px', fontWeight: '600', marginBottom: '12px', color: 'var(--secondary)', textAlign: 'center' }}>{title}</h3>
                  <div style={{ display: 'flex', justifyContent: 'center' }}>
                    <div style={{ position: 'relative' }}>
                      <div style={{ display: 'flex', marginLeft: labelWidth }}>
                        {TARGET_DIRECTIONS.map(dir => (
                          <div key={dir} style={{ width: cellWidth, textAlign: 'center', fontWeight: '600', fontSize: '11px', padding: '4px 0', color: 'var(--secondary)' }}>{dir}</div>
                        ))}
                      </div>
                      <div style={{ display: 'flex' }}>
                        <div style={{ width: labelWidth }}>
                          {TARGET_DEPTHS.map(depth => (
                            <div key={depth} style={{ height: cellHeight, display: 'flex', alignItems: 'center', justifyContent: 'flex-end', paddingRight: '6px', fontWeight: '500', fontSize: '10px', color: 'var(--text-light)' }}>{depth}</div>
                          ))}
                        </div>
                        <div style={{ position: 'relative', width: gridWidth, height: gridHeight }}>
                          <svg style={{ position: 'absolute', top: 0, left: 0, width: gridWidth, height: gridHeight, pointerEvents: 'none' }} viewBox={`0 0 ${gridWidth} ${gridHeight}`} preserveAspectRatio="none">
                            {(() => {
                              const tLineRowIndex = 3;
                              const centerX = gridWidth / 2;
                              const centerY = (tLineRowIndex * cellHeight) + (cellHeight / 2);
                              const maxRadius = cellHeight * 3.2;
                              const ring8 = maxRadius * (8/12);
                              const ring4 = maxRadius * (4/12);
                              const button = maxRadius * (1/12);
                              return (
                                <>
                                  <circle cx={centerX} cy={centerY} r={maxRadius} fill="rgba(59, 130, 246, 0.15)" stroke="rgba(59, 130, 246, 0.3)" strokeWidth="2"/>
                                  <circle cx={centerX} cy={centerY} r={ring8} fill="rgba(255, 255, 255, 0.4)" stroke="rgba(200, 200, 200, 0.5)" strokeWidth="2"/>
                                  <circle cx={centerX} cy={centerY} r={ring4} fill="rgba(239, 68, 68, 0.15)" stroke="rgba(239, 68, 68, 0.3)" strokeWidth="2"/>
                                  <circle cx={centerX} cy={centerY} r={button} fill="rgba(255, 255, 255, 0.6)" stroke="rgba(100, 100, 100, 0.4)" strokeWidth="1"/>
                                  <line x1={0} y1={centerY} x2={gridWidth} y2={centerY} stroke="rgba(100, 100, 100, 0.3)" strokeWidth="2"/>
                                  <line x1={centerX} y1={0} x2={centerX} y2={gridHeight - cellHeight} stroke="rgba(100, 100, 100, 0.3)" strokeWidth="2"/>
                                </>
                              );
                            })()}
                          </svg>
                          <div style={{ position: 'relative', zIndex: 1 }}>
                            {TARGET_DEPTHS.map((depth, rowIdx) => (
                              <div key={depth} style={{ display: 'flex' }}>
                                {TARGET_DIRECTIONS.map(dir => {
                                  const cell = heatMapData[depth][dir];
                                  return (
                                    <div key={dir} style={{ width: cellWidth, height: cellHeight, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', background: getHeatColor(cell.pct), border: '1px solid rgba(255,255,255,0.5)' }}>
                                      {cell.count > 0 ? (
                                        <>
                                          <div style={{ fontWeight: '700', fontSize: '14px', color: cell.pct >= 75 ? 'var(--secondary)' : 'white', textShadow: cell.pct < 75 ? '0 1px 2px rgba(0,0,0,0.3)' : 'none' }}>{cell.pct}%</div>
                                          <div style={{ fontSize: '9px', color: cell.pct >= 75 ? 'var(--text-light)' : 'rgba(255,255,255,0.9)' }}>({cell.count})</div>
                                        </>
                                      ) : (
                                        <div style={{ fontSize: '10px', color: 'var(--text-light)' }}>-</div>
                                      )}
                                    </div>
                                  );
                                })}
                              </div>
                            ))}
                          </div>
                        </div>
                      </div>
                    </div>
                  </div>
                </div>
              );
            };
            
            return (
              <div style={styles.card}>
                <h2 style={styles.cardTitle}>TARGET HEAT MAPS</h2>
                <p style={{ fontSize: '12px', color: 'var(--text-light)', marginBottom: '16px' }}>
                  Shooting percentage by target location {showTeamPct ? '(Team Total)' : `(End${selectedEnds.length > 1 ? 's' : ''}: ${selectedEnds.join(', ')})`}
                </p>
                <div style={{ display: 'flex', gap: '24px', flexWrap: 'wrap', justifyContent: 'center' }}>
                  {renderHeatMap(filteredHeatMaps.draws, 'DRAWS')}
                  {renderHeatMap(filteredHeatMaps.takeouts, 'TAKEOUTS')}
                </div>
                <div style={{ display: 'flex', justifyContent: 'center', gap: '12px', marginTop: '16px', flexWrap: 'wrap' }}>
                  {[
                    { label: '90%+', color: 'rgba(34, 197, 94, 0.8)' },
                    { label: '83-89%', color: 'rgba(132, 204, 22, 0.8)' },
                    { label: '75-82%', color: 'rgba(250, 204, 21, 0.8)' },
                    { label: '70-74%', color: 'rgba(251, 146, 60, 0.8)' },
                    { label: '<70%', color: 'rgba(239, 68, 68, 0.8)' },
                    { label: 'No data', color: 'rgba(229, 231, 235, 0.7)' }
                  ].map(item => (
                    <div key={item.label} style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                      <div style={{ width: '16px', height: '16px', background: item.color, borderRadius: '3px', border: '1px solid rgba(0,0,0,0.1)' }} />
                      <span style={{ fontSize: '11px', color: 'var(--text-light)' }}>{item.label}</span>
                    </div>
                  ))}
                </div>
              </div>
            );
          })()}

          {/* Miss Analysis - Interactive Filter View */}
          <div style={styles.card}>
            <h2 style={styles.cardTitle}>MISS ANALYSIS {playerFilter !== 'Team' && `- ${playerFilter}`}</h2>
            
            {(() => {
              // Get all shots with misses for the filtered player
              const missShots = playerFilteredShots.filter(s => s.miss || s.secondaryMiss);
              
              if (missShots.length === 0) {
                return (
                  <p style={{ textAlign: 'center', color: 'var(--text-light)', padding: '40px 20px' }}>
                    No misses recorded yet
                  </p>
                );
              }
              
              // Get unique values for filters
              const turns = [...new Set(missShots.map(s => s.turn).filter(Boolean))];
              const shotTypes = [...new Set(missShots.map(s => s.shotType).filter(Boolean))];
              const primaryMisses = [...new Set(missShots.map(s => s.miss).filter(Boolean))];
              const secondaryMisses = [...new Set(missShots.map(s => s.secondaryMiss).filter(Boolean))];
              
              return (
                <div>
                  {/* Filter Controls */}
                  <div style={{ 
                    display: 'grid', 
                    gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', 
                    gap: '12px',
                    marginBottom: '20px',
                    padding: '16px',
                    background: 'var(--ice)',
                    borderRadius: 'var(--radius-sm)'
                  }}>
                    <div>
                      <label style={{ fontSize: '12px', fontWeight: '600', display: 'block', marginBottom: '4px' }}>Turn</label>
                      <select
                        style={{ ...styles.select, width: '100%', fontSize: '13px' }}
                        value={missFilterTurn || ''}
                        onChange={(e) => setMissFilterTurn(e.target.value || null)}
                      >
                        <option value="">All Turns</option>
                        {turns.map(t => <option key={t} value={t}>{t === 'In-Turn' ? 'Clockwise' : t === 'Out-Turn' ? 'Counter Clockwise' : t}</option>)}
                      </select>
                    </div>
                    <div>
                      <label style={{ fontSize: '12px', fontWeight: '600', display: 'block', marginBottom: '4px' }}>Shot Type</label>
                      <select
                        style={{ ...styles.select, width: '100%', fontSize: '13px' }}
                        value={missFilterShotType || ''}
                        onChange={(e) => setMissFilterShotType(e.target.value || null)}
                      >
                        <option value="">All Shot Types</option>
                        {shotTypes.map(st => <option key={st} value={st}>{st}</option>)}
                      </select>
                    </div>
                    <div>
                      <label style={{ fontSize: '12px', fontWeight: '600', display: 'block', marginBottom: '4px' }}>Primary Miss</label>
                      <select
                        style={{ ...styles.select, width: '100%', fontSize: '13px' }}
                        value={missFilterPrimary || ''}
                        onChange={(e) => setMissFilterPrimary(e.target.value || null)}
                      >
                        <option value="">All Primary</option>
                        {primaryMisses.map(m => <option key={m} value={m}>{m}</option>)}
                      </select>
                    </div>
                    <div>
                      <label style={{ fontSize: '12px', fontWeight: '600', display: 'block', marginBottom: '4px' }}>Secondary Miss</label>
                      <select
                        style={{ ...styles.select, width: '100%', fontSize: '13px' }}
                        value={missFilterSecondary || ''}
                        onChange={(e) => setMissFilterSecondary(e.target.value || null)}
                      >
                        <option value="">All Secondary</option>
                        {secondaryMisses.map(m => <option key={m} value={m}>{m}</option>)}
                      </select>
                    </div>
                  </div>
                  
                  {/* Filtered Results */}
                  {(() => {
                    // Apply filters
                    let filtered = missShots;
                    if (missFilterTurn) filtered = filtered.filter(s => s.turn === missFilterTurn);
                    if (missFilterShotType) filtered = filtered.filter(s => s.shotType === missFilterShotType);
                    if (missFilterPrimary) filtered = filtered.filter(s => s.miss === missFilterPrimary);
                    if (missFilterSecondary) filtered = filtered.filter(s => s.secondaryMiss === missFilterSecondary);
                    
                    // Calculate aggregations based on what's NOT filtered
                    const showTurnBreakdown = !missFilterTurn;
                    const showShotTypeBreakdown = !missFilterShotType;
                    const showPrimaryBreakdown = !missFilterPrimary;
                    const showSecondaryBreakdown = !missFilterSecondary;
                    
                    // Aggregate data
                    const turnCounts = {};
                    const shotTypeCounts = {};
                    const primaryCounts = {};
                    const secondaryCounts = {};
                    
                    filtered.forEach(s => {
                      if (s.turn) turnCounts[s.turn] = (turnCounts[s.turn] || 0) + 1;
                      if (s.shotType) shotTypeCounts[s.shotType] = (shotTypeCounts[s.shotType] || 0) + 1;
                      if (s.miss) primaryCounts[s.miss] = (primaryCounts[s.miss] || 0) + 1;
                      if (s.secondaryMiss) secondaryCounts[s.secondaryMiss] = (secondaryCounts[s.secondaryMiss] || 0) + 1;
                    });
                    
                    const totalFiltered = filtered.length;
                    
                    // Render aggregation bars
                    const renderBreakdown = (title, counts, colorBase) => {
                      const entries = Object.entries(counts).sort((a, b) => b[1] - a[1]);
                      if (entries.length === 0) return null;
                      const max = Math.max(...entries.map(e => e[1]));
                      
                      return (
                        <div style={{ marginBottom: '20px' }}>
                          <h4 style={{ fontSize: '13px', fontWeight: '600', marginBottom: '10px', color: 'var(--secondary)' }}>{title}</h4>
                          {entries.map(([label, count]) => {
                            const displayLabel = label === 'In-Turn' ? 'Clockwise' : label === 'Out-Turn' ? 'Counter Clockwise' : label;
                            const pct = ((count / totalFiltered) * 100).toFixed(0);
                            const barWidth = (count / max) * 100;
                            return (
                              <div key={label} style={{ marginBottom: '6px' }}>
                                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '12px', marginBottom: '2px' }}>
                                  <span>{displayLabel}</span>
                                  <span style={{ fontWeight: '600' }}>{count} ({pct}%)</span>
                                </div>
                                <div style={{ 
                                  height: '18px', 
                                  background: 'var(--ice)', 
                                  borderRadius: '4px',
                                  overflow: 'hidden'
                                }}>
                                  <div style={{ 
                                    width: `${barWidth}%`, 
                                    height: '100%', 
                                    background: colorBase,
                                    borderRadius: '4px',
                                    transition: 'width 0.3s ease'
                                  }} />
                                </div>
                              </div>
                            );
                          })}
                        </div>
                      );
                    };
                    
                    return (
                      <div>
                        {/* Summary */}
                        <div style={{ 
                          textAlign: 'center', 
                          padding: '16px', 
                          background: 'var(--secondary)', 
                          color: 'white',
                          borderRadius: 'var(--radius-sm)',
                          marginBottom: '20px'
                        }}>
                          <div style={{ fontSize: '28px', fontWeight: '700' }}>{totalFiltered}</div>
                          <div style={{ fontSize: '13px', opacity: 0.9 }}>
                            {totalFiltered === 1 ? 'Miss' : 'Misses'} matching filters
                            {totalFiltered !== missShots.length && ` (of ${missShots.length} total)`}
                          </div>
                        </div>
                        
                        {/* Breakdowns Grid */}
                        <div style={{ 
                          display: 'grid', 
                          gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', 
                          gap: '20px' 
                        }}>
                          {showTurnBreakdown && Object.keys(turnCounts).length > 0 && renderBreakdown('By Turn', turnCounts, 'var(--primary)')}
                          {showShotTypeBreakdown && Object.keys(shotTypeCounts).length > 0 && renderBreakdown('By Shot Type', shotTypeCounts, 'var(--accent)')}
                          {showPrimaryBreakdown && Object.keys(primaryCounts).length > 0 && renderBreakdown('By Primary Miss', primaryCounts, 'var(--secondary)')}
                          {showSecondaryBreakdown && Object.keys(secondaryCounts).length > 0 && renderBreakdown('By Secondary Miss', secondaryCounts, 'var(--warning)')}
                        </div>
                        
                        {/* Detailed List */}
                        {filtered.length > 0 && filtered.length <= 20 && (
                          <div style={{ marginTop: '20px' }}>
                            <h4 style={{ fontSize: '13px', fontWeight: '600', marginBottom: '10px', color: 'var(--secondary)' }}>Shot Details</h4>
                            <div style={{ overflowX: 'auto' }}>
                              <table style={{ ...styles.table, fontSize: '12px' }}>
                                <thead>
                                  <tr>
                                    <th style={headerCellStyle}>End</th>
                                    <th style={headerCellStyle}>Shot</th>
                                    <th style={headerCellStyle}>Turn</th>
                                    <th style={headerCellStyle}>Shot Type</th>
                                    <th style={headerCellStyle}>Outcome</th>
                                    <th style={headerCellStyle}>Primary Miss</th>
                                    <th style={headerCellStyle}>Secondary Miss</th>
                                  </tr>
                                </thead>
                                <tbody>
                                  {filtered.map((s, idx) => (
                                    <tr key={idx} style={{ background: idx % 2 === 0 ? 'white' : 'var(--ice)' }}>
                                      <td style={statCellStyle}>{s.end}</td>
                                      <td style={statCellStyle}>{s.teamShotNumber || s.shotNumber}</td>
                                      <td style={statCellStyle}>{s.turn === 'In-Turn' ? 'CW' : s.turn === 'Out-Turn' ? 'CCW' : s.turn}</td>
                                      <td style={statCellStyle}>{s.shotType}</td>
                                      <td style={statCellStyle}>{s.outcome !== null ? s.outcome : '-'}</td>
                                      <td style={{ ...statCellStyle, color: 'var(--error)', fontWeight: '500' }}>{s.miss || '-'}</td>
                                      <td style={{ ...statCellStyle, color: 'var(--warning)', fontWeight: '500' }}>{s.secondaryMiss || '-'}</td>
                                    </tr>
                                  ))}
                                </tbody>
                              </table>
                            </div>
                          </div>
                        )}
                        
                        {filtered.length > 20 && (
                          <p style={{ fontSize: '12px', color: 'var(--text-light)', textAlign: 'center', marginTop: '16px' }}>
                            {filtered.length} shots found. Apply more filters to see individual shot details.
                          </p>
                        )}
                      </div>
                    );
                  })()}
                </div>
              );
            })()}
          </div>

          {/* Export Buttons */}
          <div style={{ 
            display: 'flex', 
            gap: '12px', 
            justifyContent: 'center',
            flexWrap: 'wrap',
            marginTop: '24px'
          }}>
            <button
              style={{ ...styles.button, ...styles.buttonSecondary }}
              onClick={() => setShowExportCSVModal(true)}
            >
              üìä Export CSV {isBothTeams && `(${analyticsTab === 'opponent' ? opponent : teamName})`}
            </button>
            <button
              style={{ ...styles.button, ...styles.buttonSecondary }}
              onClick={() => exportPDF(analyticsTab)}
            >
              üìÑ Export PDF {isBothTeams && `(${analyticsTab === 'opponent' ? opponent : teamName})`}
            </button>
            <button
              style={{ ...styles.button, background: 'var(--accent)', color: 'white' }}
              onClick={() => setShowArchiveModal(true)}
              disabled={!competitionId}
              title={competitionId ? 'Archive game to competition' : 'No competition selected'}
            >
              üìÅ Archive Game
            </button>
            <button
              style={{ ...styles.button, ...styles.buttonPrimary }}
              onClick={() => setShowNewGame(true)}
            >
              ü•å New Game
            </button>
          </div>

          {/* CSV Export Modal */}
          {showExportCSVModal && (
            <div style={{
              position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
              background: 'rgba(0,0,0,0.5)', display: 'flex',
              alignItems: 'center', justifyContent: 'center', zIndex: 1000
            }}>
              <div style={{
                background: 'white', padding: '32px', borderRadius: 'var(--radius)',
                maxWidth: '400px', width: '90%'
              }}>
                <h3 style={{ marginTop: 0, color: 'var(--secondary)' }}>üìä Export CSV</h3>
                <p style={{ color: 'var(--text-light)', marginBottom: '20px' }}>
                  Select which data to export:
                </p>
                <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                  <button
                    onClick={() => {
                      exportCSV(analyticsTab);
                      setShowExportCSVModal(false);
                    }}
                    style={{ 
                      ...styles.button, 
                      ...styles.buttonSecondary, 
                      width: '100%',
                      padding: '16px',
                      textAlign: 'left',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'flex-start'
                    }}
                  >
                    <span style={{ fontWeight: '600' }}>üìã Shot-by-Shot Data</span>
                    <span style={{ fontSize: '12px', color: 'var(--text-light)', marginTop: '4px' }}>
                      Individual shot details with outcomes, misses, etc.
                    </span>
                  </button>
                  <button
                    onClick={() => {
                      exportTeamStatsCSV(analyticsTab);
                      setShowExportCSVModal(false);
                    }}
                    style={{ 
                      ...styles.button, 
                      ...styles.buttonSecondary, 
                      width: '100%',
                      padding: '16px',
                      textAlign: 'left',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'flex-start'
                    }}
                  >
                    <span style={{ fontWeight: '600' }}>üìà Team Stats Summary</span>
                    <span style={{ fontSize: '12px', color: 'var(--text-light)', marginTop: '4px' }}>
                      Player percentages by turn/shot type, efficiency stats
                    </span>
                  </button>
                  <button
                    onClick={() => {
                      exportCSV(analyticsTab);
                      exportTeamStatsCSV(analyticsTab);
                      setShowExportCSVModal(false);
                    }}
                    style={{ 
                      ...styles.button, 
                      background: 'var(--accent)', 
                      color: 'white',
                      width: '100%',
                      padding: '16px',
                      textAlign: 'left',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'flex-start'
                    }}
                  >
                    <span style={{ fontWeight: '600' }}>üìä Export Both</span>
                    <span style={{ fontSize: '12px', opacity: 0.9, marginTop: '4px' }}>
                      Download both CSV files at once
                    </span>
                  </button>
                </div>
                <button
                  onClick={() => setShowExportCSVModal(false)}
                  style={{ ...styles.button, background: '#d1d5db', color: 'var(--text)', width: '100%', marginTop: '16px' }}
                >
                  Cancel
                </button>
              </div>
            </div>
          )}

          {showNewGame && (
            <ConfirmModal
              title="Start New Game?"
              message="All current game data will be cleared. Make sure you've exported your data!"
              onConfirm={handleNewGame}
              onCancel={() => setShowNewGame(false)}
            />
          )}

          {/* Archive Game Modal */}
          {showArchiveModal && (
            <div style={{
              position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
              background: 'rgba(0,0,0,0.5)', display: 'flex',
              alignItems: 'center', justifyContent: 'center', zIndex: 1000
            }}>
              <div style={{
                background: 'white', padding: '32px', borderRadius: 'var(--radius)',
                maxWidth: '450px', width: '90%'
              }}>
                <h3 style={{ marginTop: 0, color: 'var(--secondary)' }}>üìÅ Archive Game?</h3>
                <p style={{ color: 'var(--text-light)', lineHeight: 1.6 }}>
                  Save this game to <strong>{competition}</strong> for cumulative stats and later export.
                </p>
                <div style={{ 
                  background: 'var(--ice)', 
                  padding: '12px', 
                  borderRadius: 'var(--radius-sm)',
                  marginBottom: '16px'
                }}>
                  <div style={{ fontSize: '14px' }}>
                    <strong>{teamName}</strong> vs <strong>{opponent}</strong>
                  </div>
                  <div style={{ fontSize: '13px', color: 'var(--text-light)' }}>
                    {compRound} ‚Ä¢ {gameDate} ‚Ä¢ {gameShots.length} shots
                  </div>
                </div>
                <div style={{ display: 'flex', gap: '12px' }}>
                  <button
                    onClick={() => setShowArchiveModal(false)}
                    style={{ ...styles.button, background: '#d1d5db', color: 'var(--text)', flex: 1 }}
                  >
                    Cancel
                  </button>
                  <button
                    onClick={handleArchiveGame}
                    style={{ ...styles.button, background: 'var(--accent)', color: 'white', flex: 1 }}
                  >
                    Archive Game
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    // ============================================
    // HOME PAGE COMPONENT
    // ============================================
    
    function HomePage({ onSelectMode }) {
      return (
        <div style={{ 
          display: 'flex', 
          flexDirection: 'column', 
          alignItems: 'center', 
          justifyContent: 'center',
          minHeight: 'calc(100vh - 120px)',
          padding: '40px 20px',
          gap: '40px'
        }}>
          <div style={{ textAlign: 'center' }}>
            <img 
              src="usa_curling_logo.png" 
              alt="USA Curling" 
              style={{ height: '100px', marginBottom: '20px' }}
              onError={(e) => e.target.style.display = 'none'}
            />
            <h1 style={{ 
              fontFamily: "'Bebas Neue', sans-serif", 
              fontSize: '48px', 
              color: 'var(--secondary)',
              letterSpacing: '2px',
              margin: 0
            }}>
              USA CURLING
            </h1>
            <p style={{ color: 'var(--text-light)', fontSize: '18px', marginTop: '8px' }}>
              Stats & Rock Tracking
            </p>
          </div>
          
          <div style={{ 
            display: 'flex', 
            gap: '24px', 
            flexWrap: 'wrap',
            justifyContent: 'center'
          }}>
            <button
              onClick={() => onSelectMode('rockbook')}
              style={{
                ...styles.button,
                width: '200px',
                height: '200px',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '16px',
                background: 'linear-gradient(135deg, var(--primary) 0%, #a01830 100%)',
                border: 'none',
                borderRadius: 'var(--radius)',
                cursor: 'pointer',
                transition: 'transform 0.2s, box-shadow 0.2s',
                boxShadow: '0 4px 15px rgba(196, 30, 58, 0.3)'
              }}
              onMouseOver={(e) => {
                e.currentTarget.style.transform = 'translateY(-4px)';
                e.currentTarget.style.boxShadow = '0 8px 25px rgba(196, 30, 58, 0.4)';
              }}
              onMouseOut={(e) => {
                e.currentTarget.style.transform = 'translateY(0)';
                e.currentTarget.style.boxShadow = '0 4px 15px rgba(196, 30, 58, 0.3)';
              }}
            >
              <span style={{ fontSize: '64px' }}>üìñ</span>
              <span style={{ 
                fontFamily: "'Bebas Neue', sans-serif", 
                fontSize: '24px', 
                color: 'white',
                letterSpacing: '1px'
              }}>
                ROCK BOOK
              </span>
            </button>
            
            <button
              onClick={() => onSelectMode('gamestats')}
              style={{
                ...styles.button,
                width: '200px',
                height: '200px',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '16px',
                background: 'linear-gradient(135deg, var(--secondary) 0%, #0f0f1a 100%)',
                border: 'none',
                borderRadius: 'var(--radius)',
                cursor: 'pointer',
                transition: 'transform 0.2s, box-shadow 0.2s',
                boxShadow: '0 4px 15px rgba(26, 26, 46, 0.3)'
              }}
              onMouseOver={(e) => {
                e.currentTarget.style.transform = 'translateY(-4px)';
                e.currentTarget.style.boxShadow = '0 8px 25px rgba(26, 26, 46, 0.4)';
              }}
              onMouseOut={(e) => {
                e.currentTarget.style.transform = 'translateY(0)';
                e.currentTarget.style.boxShadow = '0 4px 15px rgba(26, 26, 46, 0.3)';
              }}
            >
              <span style={{ fontSize: '64px' }}>üìä</span>
              <span style={{ 
                fontFamily: "'Bebas Neue', sans-serif", 
                fontSize: '24px', 
                color: 'white',
                letterSpacing: '1px'
              }}>
                GAME STATS
              </span>
            </button>
            
            <button
              onClick={() => onSelectMode('history')}
              style={{
                ...styles.button,
                width: '200px',
                height: '200px',
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                gap: '16px',
                background: 'linear-gradient(135deg, var(--accent) 0%, #0d9488 100%)',
                border: 'none',
                borderRadius: 'var(--radius)',
                cursor: 'pointer',
                transition: 'transform 0.2s, box-shadow 0.2s',
                boxShadow: '0 4px 15px rgba(20, 184, 166, 0.3)'
              }}
              onMouseOver={(e) => {
                e.currentTarget.style.transform = 'translateY(-4px)';
                e.currentTarget.style.boxShadow = '0 8px 25px rgba(20, 184, 166, 0.4)';
              }}
              onMouseOut={(e) => {
                e.currentTarget.style.transform = 'translateY(0)';
                e.currentTarget.style.boxShadow = '0 4px 15px rgba(20, 184, 166, 0.3)';
              }}
            >
              <span style={{ fontSize: '64px' }}>üìÅ</span>
              <span style={{ 
                fontFamily: "'Bebas Neue', sans-serif", 
                fontSize: '24px', 
                color: 'white',
                letterSpacing: '1px'
              }}>
                SEASON STATS
              </span>
            </button>
          </div>
        </div>
      );
    }

    // ============================================
    // ROCK BOOK COMPONENT
    // ============================================
    
    function RockBook({ onBack, onNotify }) {
      // Get today's date in YYYY-MM-DD format
      const today = new Date().toISOString().split('T')[0];
      
      // Rock positions with labels
      const ROCK_POSITIONS = [
        { id: 'LR1', label: 'L1' },
        { id: 'LR2', label: 'L2' },
        { id: 'SR1', label: 'S1' },
        { id: 'SR2', label: 'S2' },
        { id: 'TR1', label: 'T1' },
        { id: 'TR2', label: 'T2' },
        { id: 'FR1', label: 'F1' },
        { id: 'FR2', label: 'F2' }
      ];
      
      const SPEED_OPTIONS = ['---', 'Fast', 'Med', 'Slow'];
      const CURL_OPTIONS = ['---', 'Straight', 'Curly', 'Cutter'];
      const ROUND_OPTIONS = ['---', 'Pool Play', 'Quarter-Final', 'Semi-Final', 'Final'];
      
      // Initialize rock data with new structure
      const createEmptyRocks = () => {
        const rocks = {};
        ROCK_POSITIONS.forEach(pos => {
          rocks[pos.id] = { sheet: '', rock: '', speed: '---', curl: '---' };
        });
        return rocks;
      };
      
      const [activeTab, setActiveTab] = useState('entry'); // 'entry' or 'editor'
      const [editingIndex, setEditingIndex] = useState(null); // Index of entry being edited
      
      const [rockData, setRockData] = useState({
        curlingClub: '',
        sheet: '',
        round: '---',
        winner: '',
        score: '',
        date: today,
        redTeamName: '',
        redRocks: createEmptyRocks(),
        yellowTeamName: '',
        yellowRocks: createEmptyRocks(),
        comments: '',
        signature: ''
      });
      
      const [loggedEntries, setLoggedEntries] = useState([]);
      const [originalClub, setOriginalClub] = useState('');
      const [originalDate, setOriginalDate] = useState('');
      const [showBlankWarning, setShowBlankWarning] = useState(false);
      const [blankFields, setBlankFields] = useState([]);
      const [showClearConfirm, setShowClearConfirm] = useState(false);

      // Load saved rock book entries on mount
      React.useEffect(() => {
        const saved = localStorage.getItem('rockBookEntries');
        if (saved) {
          try {
            const parsed = JSON.parse(saved);
            setLoggedEntries(parsed.entries || []);
            setOriginalClub(parsed.originalClub || '');
            setOriginalDate(parsed.originalDate || '');
          } catch (e) {
            console.error('Failed to load rock book entries:', e);
          }
        }
      }, []);

      // Save rock book entries whenever they change
      React.useEffect(() => {
        if (loggedEntries.length > 0 || originalClub || originalDate) {
          localStorage.setItem('rockBookEntries', JSON.stringify({
            entries: loggedEntries,
            originalClub,
            originalDate
          }));
        }
      }, [loggedEntries, originalClub, originalDate]);

      // Auto-populate sheet in rocks when game info sheet changes
      React.useEffect(() => {
        if (rockData.sheet) {
          setRockData(prev => {
            const newRedRocks = { ...prev.redRocks };
            const newYellowRocks = { ...prev.yellowRocks };
            ROCK_POSITIONS.forEach(pos => {
              newRedRocks[pos.id] = { ...newRedRocks[pos.id], sheet: prev.sheet };
              newYellowRocks[pos.id] = { ...newYellowRocks[pos.id], sheet: prev.sheet };
            });
            return { ...prev, redRocks: newRedRocks, yellowRocks: newYellowRocks };
          });
        }
      }, [rockData.sheet]);

      const handleChange = (field, value) => {
        setRockData(prev => ({ ...prev, [field]: value }));
      };

      const handleRockChange = (color, posId, field, value) => {
        const rocksKey = color === 'red' ? 'redRocks' : 'yellowRocks';
        setRockData(prev => ({
          ...prev,
          [rocksKey]: {
            ...prev[rocksKey],
            [posId]: { ...prev[rocksKey][posId], [field]: value }
          }
        }));
      };

      const getBlankFields = () => {
        const blanks = [];
        if (!rockData.date) blanks.push('Date');
        if (!rockData.curlingClub) blanks.push('Curling Club');
        if (!rockData.sheet) blanks.push('Sheet');
        if (!rockData.winner) blanks.push('Winner');
        if (!rockData.score) blanks.push('Score');
        if (!rockData.redTeamName) blanks.push('Red Team Name');
        if (!rockData.yellowTeamName) blanks.push('Yellow Team Name');
        if (!rockData.signature) blanks.push('Signature');
        
        // Check Rock and Speed for each position
        ROCK_POSITIONS.forEach(pos => {
          if (!rockData.redRocks[pos.id].rock) blanks.push(`Red ${pos.label} Rock`);
          if (rockData.redRocks[pos.id].speed === '---') blanks.push(`Red ${pos.label} Speed`);
          if (!rockData.yellowRocks[pos.id].rock) blanks.push(`Yellow ${pos.label} Rock`);
          if (rockData.yellowRocks[pos.id].speed === '---') blanks.push(`Yellow ${pos.label} Speed`);
        });
        
        return blanks;
      };

      // Check if date or club differs from most recent entry
      const checkDateClubMismatch = () => {
        if (loggedEntries.length === 0) return null;
        const mostRecent = loggedEntries[loggedEntries.length - 1];
        if (rockData.date !== mostRecent.date || rockData.curlingClub !== mostRecent.curlingClub) {
          return mostRecent;
        }
        return null;
      };

      const [showMismatchWarning, setShowMismatchWarning] = useState(false);
      const [mismatchEntry, setMismatchEntry] = useState(null);

      const handleLogEntry = () => {
        // First check for blank fields
        const blanks = getBlankFields();
        if (blanks.length > 0) {
          setBlankFields(blanks);
          setShowBlankWarning(true);
          return;
        }
        
        // Then check for date/club mismatch (only for new entries, not edits)
        if (editingIndex === null) {
          const mismatch = checkDateClubMismatch();
          if (mismatch) {
            setMismatchEntry(mismatch);
            setShowMismatchWarning(true);
            return;
          }
        }
        
        proceedWithLogEntry();
      };

      const proceedWithLogEntry = () => {
        if (rockData.score && !/^\d+-\d+$/.test(rockData.score)) {
          if (onNotify) onNotify("Score must be in format #-# (e.g., 7-5)", "error");
          return;
        }

        // Flatten rock data for CSV - combine sheet+rock, use label instead of id
        const flattenRocks = (rocks, prefix) => {
          const flat = {};
          ROCK_POSITIONS.forEach(pos => {
            // Combine sheet and rock into one field (e.g., "A3")
            const combinedRock = (rocks[pos.id].sheet || '') + (rocks[pos.id].rock || '');
            flat[`${prefix}_${pos.label}_Rock`] = combinedRock;
            flat[`${prefix}_${pos.label}_Speed`] = rocks[pos.id].speed;
            flat[`${prefix}_${pos.label}_Curl`] = rocks[pos.id].curl;
          });
          return flat;
        };

        const entry = {
          curlingClub: rockData.curlingClub,
          sheet: rockData.sheet,
          round: rockData.round,
          winner: rockData.winner,
          score: rockData.score,
          date: rockData.date,
          redTeamName: rockData.redTeamName,
          redRocks: rockData.redRocks, // Keep structured data for editing
          ...flattenRocks(rockData.redRocks, 'Red'),
          yellowTeamName: rockData.yellowTeamName,
          yellowRocks: rockData.yellowRocks, // Keep structured data for editing
          ...flattenRocks(rockData.yellowRocks, 'Yellow'),
          comments: rockData.comments,
          signature: rockData.signature
        };
        
        if (editingIndex !== null) {
          // Update existing entry
          setLoggedEntries(prev => {
            const updated = [...prev];
            updated[editingIndex] = entry;
            return updated;
          });
          setEditingIndex(null);
          if (onNotify) onNotify("Entry updated!", "success");
        } else {
          // Add new entry
          setLoggedEntries(prev => [...prev, entry]);
          if (onNotify) onNotify(`Entry logged! (${loggedEntries.length + 1} total entries)`, "success");
        }
        
        if (!originalClub && rockData.curlingClub) {
          setOriginalClub(rockData.curlingClub);
        }
        if (!originalDate && rockData.date) {
          setOriginalDate(rockData.date);
        }
        
        // Reset fields (keep date, curling club, and signature)
        setRockData(prev => ({
          ...prev,
          sheet: '',
          round: '---',
          winner: '',
          score: '',
          redTeamName: '',
          redRocks: createEmptyRocks(),
          yellowTeamName: '',
          yellowRocks: createEmptyRocks(),
          comments: ''
        }));
        
        setShowBlankWarning(false);
      };

      // Load an entry for editing
      const loadEntryForEdit = (index) => {
        const entry = loggedEntries[index];
        setRockData({
          curlingClub: entry.curlingClub || '',
          sheet: entry.sheet || '',
          round: entry.round || '---',
          winner: entry.winner || '',
          score: entry.score || '',
          date: entry.date || today,
          redTeamName: entry.redTeamName || '',
          redRocks: entry.redRocks || createEmptyRocks(),
          yellowTeamName: entry.yellowTeamName || '',
          yellowRocks: entry.yellowRocks || createEmptyRocks(),
          comments: entry.comments || '',
          signature: entry.signature || ''
        });
        setEditingIndex(index);
        setActiveTab('entry');
      };

      // Cancel editing
      const cancelEdit = () => {
        setEditingIndex(null);
        setRockData(prev => ({
          ...prev,
          sheet: '',
          round: '---',
          winner: '',
          score: '',
          redTeamName: '',
          redRocks: createEmptyRocks(),
          yellowTeamName: '',
          yellowRocks: createEmptyRocks(),
          comments: ''
        }));
      };

      const handleExportCSV = () => {
        if (loggedEntries.length === 0) {
          if (onNotify) onNotify("No entries to export. Log an entry first.", "error");
          return;
        }
        
        // Remove redRocks and yellowRocks from export (they're for internal use)
        // Add ScoreDiff and Blowout columns
        const exportData = loggedEntries.map(entry => {
          const { redRocks, yellowRocks, ...rest } = entry;
          
          // Calculate ScoreDiff and Blowout from score
          let scoreDiff = '';
          let blowout = '';
          if (entry.score && entry.score.includes('-')) {
            const [score1, score2] = entry.score.split('-').map(Number);
            if (!isNaN(score1) && !isNaN(score2)) {
              scoreDiff = Math.abs(score1 - score2);
              blowout = scoreDiff >= 4 ? 'Yes' : 'No';
            }
          }
          
          return {
            ...rest,
            ScoreDiff: scoreDiff,
            Blowout: blowout
          };
        });
        
        const csv = Papa.unparse(exportData);
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        const clubName = originalClub ? originalClub.replace(/\s+/g, '_') : 'rockbook';
        const dateStr = originalDate || rockData.date;
        a.download = `rockbook_${clubName}_${dateStr}.csv`;
        a.click();
        URL.revokeObjectURL(url);
        
        if (onNotify) onNotify(`CSV exported with ${loggedEntries.length} entries!`, "success");
      };

      // Append to existing CSV file
      const handleAppendCSV = async () => {
        if (loggedEntries.length === 0) {
          if (onNotify) onNotify("No entries to append. Log an entry first.", "error");
          return;
        }

        try {
          // Create file input to select existing CSV
          const input = document.createElement('input');
          input.type = 'file';
          input.accept = '.csv';
          
          input.onchange = async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (event) => {
              const existingCSV = event.target.result;
              
              // Parse existing CSV to get headers
              const existingData = Papa.parse(existingCSV, { header: true });
              
              // Remove redRocks and yellowRocks from export, add ScoreDiff and Blowout
              const exportData = loggedEntries.map(entry => {
                const { redRocks, yellowRocks, ...rest } = entry;
                
                // Calculate ScoreDiff and Blowout from score
                let scoreDiff = '';
                let blowout = '';
                if (entry.score && entry.score.includes('-')) {
                  const [score1, score2] = entry.score.split('-').map(Number);
                  if (!isNaN(score1) && !isNaN(score2)) {
                    scoreDiff = Math.abs(score1 - score2);
                    blowout = scoreDiff >= 4 ? 'Yes' : 'No';
                  }
                }
                
                return {
                  ...rest,
                  ScoreDiff: scoreDiff,
                  Blowout: blowout
                };
              });
              
              // Combine existing data with new data
              const combinedData = [...existingData.data.filter(row => Object.values(row).some(v => v)), ...exportData];
              
              // Generate new CSV
              const csv = Papa.unparse(combinedData);
              const blob = new Blob([csv], { type: 'text/csv' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = file.name;
              a.click();
              URL.revokeObjectURL(url);
              
              if (onNotify) onNotify(`Appended ${loggedEntries.length} entries to ${file.name}!`, "success");
            };
            reader.readAsText(file);
          };
          
          input.click();
        } catch (error) {
          if (onNotify) onNotify("Error appending to CSV: " + error.message, "error");
        }
      };

      // Clear all logged entries
      const handleClearLogged = () => {
        setLoggedEntries([]);
        setOriginalClub('');
        setOriginalDate('');
        localStorage.removeItem('rockBookEntries');
        setShowClearConfirm(false);
        if (onNotify) onNotify("All rock book entries cleared.", "info");
      };

      const inputStyle = {
        ...styles.input,
        marginBottom: '0',
        padding: '6px 8px',
        fontSize: '13px'
      };

      const smallInputStyle = {
        ...inputStyle,
        width: '100%',
        minWidth: '50px'
      };

      const smallSelectStyle = {
        ...styles.select,
        padding: '6px 8px',
        fontSize: '13px',
        width: '100%',
        minWidth: '70px'
      };

      const labelStyle = {
        ...styles.label,
        minWidth: '50px',
        marginBottom: '0',
        fontSize: '13px'
      };

      const rowStyle = {
        display: 'flex',
        alignItems: 'center',
        gap: '2px',
        marginBottom: '6px'
      };

      // Render rock entry row
      const renderRockRow = (color, pos, isFirst) => {
        const rocks = color === 'red' ? rockData.redRocks : rockData.yellowRocks;
        const rock = rocks[pos.id];
        
        return (
          <tr key={pos.id}>
            <td style={{ padding: '4px 8px', fontWeight: '600', fontSize: '12px', color: color === 'red' ? '#c41e3a' : '#d97706' }}>
              {pos.label}
            </td>
            <td style={{ padding: '4px' }}>
              <input
                type="text"
                style={smallInputStyle}
                value={rock.sheet}
                onChange={(e) => handleRockChange(color, pos.id, 'sheet', e.target.value)}
              />
            </td>
            <td style={{ padding: '4px' }}>
              <input
                type="text"
                style={smallInputStyle}
                value={rock.rock}
                onChange={(e) => handleRockChange(color, pos.id, 'rock', e.target.value)}
              />
            </td>
            <td style={{ padding: '4px' }}>
              <select
                style={smallSelectStyle}
                value={rock.speed}
                onChange={(e) => handleRockChange(color, pos.id, 'speed', e.target.value)}
              >
                {SPEED_OPTIONS.map(opt => <option key={opt} value={opt}>{opt}</option>)}
              </select>
            </td>
            <td style={{ padding: '4px' }}>
              <select
                style={smallSelectStyle}
                value={rock.curl}
                onChange={(e) => handleRockChange(color, pos.id, 'curl', e.target.value)}
              >
                {CURL_OPTIONS.map(opt => <option key={opt} value={opt}>{opt}</option>)}
              </select>
            </td>
          </tr>
        );
      };

      // Render rocks section
      const renderRocksSection = (color, teamName, onTeamNameChange) => {
        const borderColor = color === 'red' ? '#c41e3a' : '#fbbf24';
        const titleColor = color === 'red' ? '#c41e3a' : '#d97706';
        const rocks = color === 'red' ? rockData.redRocks : rockData.yellowRocks;
        
        return (
          <div style={{ ...styles.card, borderLeft: `4px solid ${borderColor}`, flex: 1, minWidth: '320px' }}>
            <h2 style={{ ...styles.cardTitle, color: titleColor }}>{color.toUpperCase()} ROCKS</h2>
            
            {/* Team Name */}
            <div style={{ ...rowStyle, marginBottom: '12px' }}>
              <label style={{ ...labelStyle, minWidth: '80px' }}>Team Name</label>
              <input
                type="text"
                style={{ ...inputStyle, flex: 1 }}
                value={teamName}
                onChange={(e) => onTeamNameChange(e.target.value)}
                placeholder={`Enter ${color} team name`}
              />
            </div>
            
            {/* Rock Table */}
            <div style={{ overflowX: 'auto' }}>
              <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '12px' }}>
                <thead>
                  <tr style={{ background: 'var(--ice)' }}>
                    <th style={{ padding: '6px 8px', textAlign: 'left', fontWeight: '600', width: '50px' }}></th>
                    <th style={{ padding: '6px 4px', textAlign: 'center', fontWeight: '600' }}>Sheet</th>
                    <th style={{ padding: '6px 4px', textAlign: 'center', fontWeight: '600' }}>Rock</th>
                    <th style={{ padding: '6px 4px', textAlign: 'center', fontWeight: '600' }}>Speed</th>
                    <th style={{ padding: '6px 4px', textAlign: 'center', fontWeight: '600' }}>Curl</th>
                  </tr>
                </thead>
                <tbody>
                  {ROCK_POSITIONS.map((pos, idx) => renderRockRow(color, pos, idx === 0))}
                </tbody>
              </table>
            </div>
          </div>
        );
      };

      return (
        <div>
          {/* Header with title */}
          <div style={{ 
            display: 'flex', 
            alignItems: 'center', 
            justifyContent: 'space-between',
            marginBottom: '16px' 
          }}>
            <h1 style={{ 
              fontFamily: "'Bebas Neue', sans-serif", 
              fontSize: '32px', 
              color: 'var(--secondary)',
              letterSpacing: '1px',
              margin: 0
            }}>
              üìñ ROCK BOOK
            </h1>
            {loggedEntries.length > 0 && (
              <div style={{ 
                background: 'var(--success)', 
                color: 'white', 
                padding: '8px 16px', 
                borderRadius: 'var(--radius-sm)',
                fontSize: '14px',
                fontWeight: '600'
              }}>
                {loggedEntries.length} {loggedEntries.length === 1 ? 'Entry' : 'Entries'} Logged
              </div>
            )}
          </div>

          {/* Tabs */}
          <div style={{ 
            display: 'flex', 
            gap: '8px', 
            marginBottom: '20px',
            borderBottom: '2px solid var(--ice-dark)',
            paddingBottom: '0'
          }}>
            <button
              onClick={() => { setActiveTab('entry'); }}
              style={{
                padding: '12px 24px',
                background: activeTab === 'entry' ? 'var(--secondary)' : 'transparent',
                color: activeTab === 'entry' ? 'white' : 'var(--text)',
                border: 'none',
                borderRadius: 'var(--radius-sm) var(--radius-sm) 0 0',
                cursor: 'pointer',
                fontWeight: activeTab === 'entry' ? '700' : '500',
                fontSize: '14px'
              }}
            >
              üìù Entry
            </button>
            <button
              onClick={() => setActiveTab('editor')}
              style={{
                padding: '12px 24px',
                background: activeTab === 'editor' ? 'var(--secondary)' : 'transparent',
                color: activeTab === 'editor' ? 'white' : 'var(--text)',
                border: 'none',
                borderRadius: 'var(--radius-sm) var(--radius-sm) 0 0',
                cursor: 'pointer',
                fontWeight: activeTab === 'editor' ? '700' : '500',
                fontSize: '14px'
              }}
            >
              ‚úèÔ∏è Editor {loggedEntries.length > 0 && `(${loggedEntries.length})`}
            </button>
          </div>

          {/* Editor Tab */}
          {activeTab === 'editor' && (
            <div>
              {loggedEntries.length === 0 ? (
                <div style={styles.card}>
                  <p style={{ textAlign: 'center', color: 'var(--text-light)', padding: '40px 20px' }}>
                    No entries logged yet. Switch to the Entry tab to add entries.
                  </p>
                </div>
              ) : (
                <div style={styles.card}>
                  <h2 style={styles.cardTitle}>LOGGED ENTRIES</h2>
                  <p style={{ fontSize: '13px', color: 'var(--text-light)', marginBottom: '16px' }}>
                    Click on a row to edit that entry
                  </p>
                  <div style={{ overflowX: 'auto' }}>
                    <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: '13px' }}>
                      <thead>
                        <tr style={{ background: 'var(--secondary)', color: 'white' }}>
                          <th style={{ padding: '10px 8px', textAlign: 'left' }}>#</th>
                          <th style={{ padding: '10px 8px', textAlign: 'left' }}>Date</th>
                          <th style={{ padding: '10px 8px', textAlign: 'left' }}>Club</th>
                          <th style={{ padding: '10px 8px', textAlign: 'left' }}>Sheet</th>
                          <th style={{ padding: '10px 8px', textAlign: 'left' }}>Round</th>
                          <th style={{ padding: '10px 8px', textAlign: 'left' }}>Winner</th>
                          <th style={{ padding: '10px 8px', textAlign: 'left' }}>Score</th>
                          <th style={{ padding: '10px 8px', textAlign: 'left', color: '#fca5a5' }}>Red Team</th>
                          <th style={{ padding: '10px 8px', textAlign: 'left', color: '#fde047' }}>Yellow Team</th>
                        </tr>
                      </thead>
                      <tbody>
                        {loggedEntries.map((entry, idx) => (
                          <tr 
                            key={idx}
                            onClick={() => loadEntryForEdit(idx)}
                            style={{ 
                              background: idx % 2 === 0 ? 'white' : 'var(--ice)',
                              cursor: 'pointer',
                              transition: 'background 0.2s'
                            }}
                            onMouseEnter={(e) => e.currentTarget.style.background = 'var(--ice-dark)'}
                            onMouseLeave={(e) => e.currentTarget.style.background = idx % 2 === 0 ? 'white' : 'var(--ice)'}
                          >
                            <td style={{ padding: '10px 8px', fontWeight: '600' }}>{idx + 1}</td>
                            <td style={{ padding: '10px 8px' }}>{entry.date}</td>
                            <td style={{ padding: '10px 8px' }}>{entry.curlingClub}</td>
                            <td style={{ padding: '10px 8px' }}>{entry.sheet}</td>
                            <td style={{ padding: '10px 8px' }}>{entry.round !== '---' ? entry.round : ''}</td>
                            <td style={{ padding: '10px 8px' }}>{entry.winner}</td>
                            <td style={{ padding: '10px 8px' }}>{entry.score}</td>
                            <td style={{ padding: '10px 8px', color: '#c41e3a', fontWeight: '500' }}>{entry.redTeamName}</td>
                            <td style={{ padding: '10px 8px', color: '#d97706', fontWeight: '500' }}>{entry.yellowTeamName}</td>
                          </tr>
                        ))}
                      </tbody>
                    </table>
                  </div>
                </div>
              )}

              {/* Action Buttons for Editor */}
              <div style={{ 
                display: 'flex', 
                gap: '16px', 
                justifyContent: 'center',
                flexWrap: 'wrap',
                marginTop: '24px'
              }}>
                <button
                  onClick={handleExportCSV}
                  style={{
                    ...styles.button,
                    ...styles.buttonSecondary,
                    padding: '16px 32px',
                    fontSize: '16px',
                    opacity: loggedEntries.length === 0 ? 0.5 : 1
                  }}
                  disabled={loggedEntries.length === 0}
                >
                  üìä Export CSV
                </button>
                <button
                  onClick={handleAppendCSV}
                  style={{
                    ...styles.button,
                    ...styles.buttonPrimary,
                    padding: '16px 32px',
                    fontSize: '16px',
                    opacity: loggedEntries.length === 0 ? 0.5 : 1
                  }}
                  disabled={loggedEntries.length === 0}
                >
                  üìé Append to CSV
                </button>
                <button
                  onClick={() => setShowClearConfirm(true)}
                  style={{
                    ...styles.button,
                    background: '#d1d5db',
                    color: 'var(--text)',
                    padding: '16px 32px',
                    fontSize: '16px',
                    opacity: loggedEntries.length === 0 ? 0.5 : 1
                  }}
                  disabled={loggedEntries.length === 0}
                >
                  üóëÔ∏è Clear Logged
                </button>
              </div>
            </div>
          )}

          {/* Entry Tab */}
          {activeTab === 'entry' && (
            <>
            {/* Editing indicator */}
            {editingIndex !== null && (
              <div style={{ 
                background: 'var(--warning)', 
                color: 'white', 
                padding: '12px 16px', 
                borderRadius: 'var(--radius-sm)',
                marginBottom: '16px',
                display: 'flex',
                justifyContent: 'space-between',
                alignItems: 'center'
              }}>
                <span>‚úèÔ∏è Editing Entry #{editingIndex + 1}</span>
                <button
                  onClick={cancelEdit}
                  style={{
                    background: 'rgba(255,255,255,0.2)',
                    border: 'none',
                    color: 'white',
                    padding: '6px 12px',
                    borderRadius: 'var(--radius-sm)',
                    cursor: 'pointer',
                    fontSize: '13px'
                  }}
                >
                  Cancel Edit
                </button>
              </div>
            )}

          {/* Game Info */}
          <div style={styles.card}>
            <h2 style={styles.cardTitle}>GAME INFORMATION</h2>
            <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fill, minmax(180px, 1fr))', gap: '8px' }}>
              <div style={rowStyle}>
                <label style={labelStyle}>Date</label>
                <input
                  type="date"
                  style={inputStyle}
                  value={rockData.date}
                  onChange={(e) => handleChange('date', e.target.value)}
                />
              </div>
              <div style={rowStyle}>
                <label style={labelStyle}>Club</label>
                <input
                  type="text"
                  style={inputStyle}
                  value={rockData.curlingClub}
                  onChange={(e) => handleChange('curlingClub', e.target.value)}
                  placeholder="Club name"
                />
              </div>
              <div style={rowStyle}>
                <label style={labelStyle}>Sheet</label>
                <input
                  type="text"
                  style={inputStyle}
                  value={rockData.sheet}
                  onChange={(e) => handleChange('sheet', e.target.value)}
                  placeholder="Sheet"
                />
              </div>
              <div style={rowStyle}>
                <label style={labelStyle}>Round</label>
                <select
                  style={{ ...styles.select, flex: 1, padding: '6px 8px', fontSize: '13px' }}
                  value={rockData.round}
                  onChange={(e) => handleChange('round', e.target.value)}
                >
                  {ROUND_OPTIONS.map(opt => <option key={opt} value={opt}>{opt}</option>)}
                </select>
              </div>
              <div style={rowStyle}>
                <label style={labelStyle}>Winner</label>
                <select
                  style={{ ...styles.select, flex: 1, padding: '6px 8px', fontSize: '13px' }}
                  value={rockData.winner}
                  onChange={(e) => handleChange('winner', e.target.value)}
                >
                  <option value="">---</option>
                  <option value="Red">Red</option>
                  <option value="Yellow">Yellow</option>
                </select>
              </div>
              <div style={rowStyle}>
                <label style={labelStyle}>Score</label>
                <input
                  type="text"
                  style={inputStyle}
                  value={rockData.score}
                  onChange={(e) => handleChange('score', e.target.value)}
                  placeholder="#-#"
                />
              </div>
            </div>
          </div>

          {/* Red and Yellow Rocks Side by Side */}
          <div style={{ display: 'flex', gap: '16px', flexWrap: 'wrap' }}>
            {renderRocksSection('red', rockData.redTeamName, (val) => handleChange('redTeamName', val))}
            {renderRocksSection('yellow', rockData.yellowTeamName, (val) => handleChange('yellowTeamName', val))}
          </div>

          {/* Comments & Signature */}
          <div style={styles.card}>
            <h2 style={styles.cardTitle}>NOTES & SIGNATURE</h2>
            <div style={{ display: 'grid', gridTemplateColumns: '2fr 1fr', gap: '16px' }}>
              <div style={{ ...rowStyle, alignItems: 'flex-start' }}>
                <label style={{ ...labelStyle, marginTop: '10px', minWidth: '70px' }}>Comments</label>
                <textarea
                  style={{ ...inputStyle, minHeight: '80px', resize: 'vertical', flex: 1 }}
                  value={rockData.comments}
                  onChange={(e) => handleChange('comments', e.target.value)}
                  placeholder="Enter any notes or comments..."
                />
              </div>
              <div style={rowStyle}>
                <label style={{ ...labelStyle, minWidth: '70px' }}>Signature</label>
                <input
                  type="text"
                  style={inputStyle}
                  value={rockData.signature}
                  onChange={(e) => handleChange('signature', e.target.value)}
                  placeholder="Your name"
                />
              </div>
            </div>
          </div>

          {/* Action Buttons */}
          <div style={{ 
            display: 'flex', 
            gap: '16px', 
            justifyContent: 'center',
            flexWrap: 'wrap',
            marginTop: '24px'
          }}>
            <button
              onClick={handleLogEntry}
              style={{
                ...styles.button,
                ...styles.buttonPrimary,
                padding: '16px 32px',
                fontSize: '16px'
              }}
            >
              {editingIndex !== null ? '‚úì Update Entry' : '‚úì Log Entry'}
            </button>
          </div>
          </>
          )}

          {/* Clear Confirmation Modal */}
          {showClearConfirm && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.5)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1000
            }}>
              <div style={{
                background: 'white',
                padding: '32px',
                borderRadius: 'var(--radius)',
                maxWidth: '400px',
                width: '90%',
                boxShadow: '0 10px 40px rgba(0,0,0,0.2)'
              }}>
                <h3 style={{ marginTop: 0, color: 'var(--error)' }}>üóëÔ∏è Clear All Entries?</h3>
                <p style={{ color: 'var(--text-light)', lineHeight: 1.6 }}>
                  This will permanently delete all {loggedEntries.length} logged {loggedEntries.length === 1 ? 'entry' : 'entries'}. 
                  This action cannot be undone.
                </p>
                <div style={{ display: 'flex', gap: '12px', marginTop: '24px' }}>
                  <button
                    onClick={() => setShowClearConfirm(false)}
                    style={{
                      ...styles.button,
                      background: '#d1d5db',
                      color: '#1a1a2e',
                      flex: 1
                    }}
                  >
                    Cancel
                  </button>
                  <button
                    onClick={handleClearLogged}
                    style={{
                      ...styles.button,
                      background: '#ef4444',
                      color: '#ffffff',
                      flex: 1
                    }}
                  >
                    Clear All
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Date/Club Mismatch Warning Modal */}
          {showMismatchWarning && mismatchEntry && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.5)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1000
            }}>
              <div style={{
                background: 'white',
                padding: '32px',
                borderRadius: 'var(--radius)',
                maxWidth: '450px',
                width: '90%',
                boxShadow: '0 10px 40px rgba(0,0,0,0.2)'
              }}>
                <h3 style={{ marginTop: 0, color: 'var(--warning)' }}>‚ö†Ô∏è Different Date/Club</h3>
                <p style={{ color: 'var(--text-light)', lineHeight: 1.6 }}>
                  Your most recent entry logged for "{mismatchEntry.date}"{mismatchEntry.curlingClub ? ` at "${mismatchEntry.curlingClub}"` : ''}. 
                  Do you want to continue adding to what you have logged or review what is in the system?
                </p>
                <div style={{ display: 'flex', gap: '12px', marginTop: '24px' }}>
                  <button
                    onClick={() => {
                      setShowMismatchWarning(false);
                      setMismatchEntry(null);
                      proceedWithLogEntry();
                    }}
                    style={{
                      ...styles.button,
                      ...styles.buttonPrimary,
                      flex: 1
                    }}
                  >
                    Continue
                  </button>
                  <button
                    onClick={() => {
                      setShowMismatchWarning(false);
                      setMismatchEntry(null);
                      setActiveTab('editor');
                    }}
                    style={{
                      ...styles.button,
                      ...styles.buttonSecondary,
                      flex: 1
                    }}
                  >
                    Review
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Blank Fields Warning Modal */}
          {showBlankWarning && (
            <div style={{
              position: 'fixed',
              top: 0,
              left: 0,
              right: 0,
              bottom: 0,
              background: 'rgba(0, 0, 0, 0.5)',
              display: 'flex',
              alignItems: 'center',
              justifyContent: 'center',
              zIndex: 1000
            }}>
              <div style={{
                background: 'white',
                padding: '32px',
                borderRadius: 'var(--radius)',
                maxWidth: '500px',
                width: '90%',
                boxShadow: '0 10px 40px rgba(0,0,0,0.2)'
              }}>
                <h3 style={{ marginTop: 0, color: 'var(--warning)' }}>‚ö†Ô∏è Blank Fields Detected</h3>
                <p style={{ color: 'var(--text-light)', lineHeight: 1.6 }}>
                  The following fields are blank:
                </p>
                <div style={{ 
                  background: 'var(--ice)', 
                  padding: '12px', 
                  borderRadius: 'var(--radius-sm)',
                  maxHeight: '150px',
                  overflowY: 'auto',
                  marginBottom: '16px'
                }}>
                  {blankFields.map((field, idx) => (
                    <span key={field} style={{ color: 'var(--text)', fontSize: '13px' }}>
                      {field}{idx < blankFields.length - 1 ? ', ' : ''}
                    </span>
                  ))}
                </div>
                <p style={{ color: 'var(--text-light)', fontSize: '14px' }}>
                  Do you want to log the entry anyway?
                </p>
                <div style={{ display: 'flex', gap: '12px', marginTop: '24px' }}>
                  <button
                    onClick={() => setShowBlankWarning(false)}
                    style={{
                      ...styles.button,
                      ...styles.buttonSecondary,
                      flex: 1
                    }}
                  >
                    Go Back & Fill In
                  </button>
                  <button
                    onClick={() => {
                      setShowBlankWarning(false);
                      // After blank warning, check for date/club mismatch (only for new entries)
                      if (editingIndex === null) {
                        const mismatch = checkDateClubMismatch();
                        if (mismatch) {
                          setMismatchEntry(mismatch);
                          setShowMismatchWarning(true);
                          return;
                        }
                      }
                      proceedWithLogEntry();
                    }}
                    style={{
                      ...styles.button,
                      background: 'var(--warning)',
                      color: 'white',
                      flex: 1
                    }}
                  >
                    Log Anyway
                  </button>
                </div>
              </div>
            </div>
          )}
        </div>
      );
    }

    // ============================================
    // HISTORY COMPONENT
    // ============================================
    
    function History({ onBack, onNotify }) {
      const [competitions, setCompetitions] = useState([]);
      const [selectedCompetition, setSelectedCompetition] = useState(null);
      const [viewMode, setViewMode] = useState('list'); // 'list', 'stats'
      const [showNewCompModal, setShowNewCompModal] = useState(false);
      const [newCompName, setNewCompName] = useState('');
      const [showDeleteConfirm, setShowDeleteConfirm] = useState(null); // competitionId or gameId
      const [deleteType, setDeleteType] = useState(null); // 'competition' or 'game'
      const [showExportModal, setShowExportModal] = useState(null); // game object
      const [selectedGames, setSelectedGames] = useState([]); // For filtering in stats view
      const [playerFilter, setPlayerFilter] = useState('Team'); // For filtering by player
      const [missFilterTurn, setMissFilterTurn] = useState(null);
      const [missFilterShotType, setMissFilterShotType] = useState(null);
      const [missFilterPrimary, setMissFilterPrimary] = useState(null);
      const [missFilterSecondary, setMissFilterSecondary] = useState(null);
      const [loading, setLoading] = useState(true);
      
      // Team filter for entire Season Stats
      const [seasonTeamFilter, setSeasonTeamFilter] = useState('All Teams');
      
      // Sub-tab state - default to competitions
      const [activeSubTab, setActiveSubTab] = useState('competitions'); // 'overview', 'competitions'
      
      // Season Overview states
      const [overviewPlayerFilter, setOverviewPlayerFilter] = useState('Team');
      const [efficiencyLineToggles, setEfficiencyLineToggles] = useState({
        hammer: true,
        force: true,
        steal: true,
        stealDef: true
      });
      
      // Season Miss filter states
      const [seasonMissFilterTurn, setSeasonMissFilterTurn] = useState(null);
      const [seasonMissFilterShotType, setSeasonMissFilterShotType] = useState(null);
      const [seasonMissFilterPrimary, setSeasonMissFilterPrimary] = useState(null);
      const [seasonMissFilterSecondary, setSeasonMissFilterSecondary] = useState(null);
      
      // Storage usage state
      const [storageUsage, setStorageUsage] = useState({ used: 0, quota: 0 });

      // Load competitions on mount
      useEffect(() => {
        loadCompetitions();
      }, []);

      const loadCompetitions = async () => {
        try {
          const comps = await CompetitionDB.getAll();
          setCompetitions(comps.sort((a, b) => new Date(b.dateCreated) - new Date(a.dateCreated)));
          
          // Auto-select last used competition
          const lastCompId = Storage.get('lastCompetitionId');
          if (lastCompId) {
            const lastComp = comps.find(c => c.id === lastCompId);
            if (lastComp) setSelectedCompetition(lastComp);
          }
          
          // Check storage usage
          if (navigator.storage && navigator.storage.estimate) {
            const estimate = await navigator.storage.estimate();
            setStorageUsage({ used: estimate.usage || 0, quota: estimate.quota || 0 });
          }
        } catch (e) {
          console.error('Failed to load competitions:', e);
          onNotify('Failed to load competitions', 'error');
        } finally {
          setLoading(false);
        }
      };

      const handleCreateCompetition = async () => {
        if (!newCompName.trim()) {
          onNotify('Please enter a competition name', 'error');
          return;
        }
        try {
          const newComp = await CompetitionDB.createCompetition(newCompName.trim());
          setCompetitions(prev => [newComp, ...prev]);
          setSelectedCompetition(newComp);
          Storage.set('lastCompetitionId', newComp.id);
          setNewCompName('');
          setShowNewCompModal(false);
          onNotify('Competition created!', 'success');
        } catch (e) {
          console.error('Failed to create competition:', e);
          onNotify('Failed to create competition', 'error');
        }
      };

      const handleDeleteCompetition = async (compId) => {
        try {
          await CompetitionDB.delete(compId);
          setCompetitions(prev => prev.filter(c => c.id !== compId));
          if (selectedCompetition?.id === compId) {
            setSelectedCompetition(null);
          }
          setShowDeleteConfirm(null);
          setDeleteType(null);
          onNotify('Competition deleted', 'success');
        } catch (e) {
          console.error('Failed to delete competition:', e);
          onNotify('Failed to delete competition', 'error');
        }
      };

      const handleDeleteGame = async (gameId) => {
        if (!selectedCompetition) return;
        try {
          await CompetitionDB.deleteGame(selectedCompetition.id, gameId);
          const updated = await CompetitionDB.get(selectedCompetition.id);
          setSelectedCompetition(updated);
          setCompetitions(prev => prev.map(c => c.id === updated.id ? updated : c));
          setShowDeleteConfirm(null);
          setDeleteType(null);
          onNotify('Game deleted', 'success');
        } catch (e) {
          console.error('Failed to delete game:', e);
          onNotify('Failed to delete game', 'error');
        }
      };

      // Export archived game as CSV
      const exportArchivedGameCSV = (game) => {
        const formatDateForExport = (dateStr) => {
          const [year, month, day] = dateStr.split('-');
          return `${day}/${month}/${year}`;
        };

        const isMixedDoubles = game.gameType === "Mixed Doubles";
        
        const csvData = game.shots.map(s => ({
          'Team Name': game.teamName,
          Name: s.name || '',
          'User ID': s.userId || '',
          Date: formatDateForExport(game.gameDate),
          Opponent: game.opponent,
          Competition: isMixedDoubles ? '' : game.competition,
          'MD Competition': isMixedDoubles ? game.competition : '',
          Round: game.compRound,
          'Draw Weight': s.drawWeight || '',
          End: s.isLSD ? 'LSD' : s.end,
          'Power Play': s.isLSD ? '' : (s.powerPlay || ''),
          Hammer: s.isLSD ? '' : s.hammer,
          'Shot Number': s.isLSD ? s.lsdNumber : (s.teamShotNumber || s.shotNumber),
          Position: s.position || '',
          Turn: s.turn === 'In-Turn' ? 'Clockwise' : s.turn === 'Out-Turn' ? 'Counter Clockwise' : (s.turn || ''),
          'Shot Type': s.isLSD ? 'LSD' : (s.shotType || ''),
          Outcome: s.outcome === null ? '' : s.outcome,
          'Primary Miss': s.isLSD ? '' : (s.miss || ''),
          'Secondary Miss': s.isLSD ? '' : (s.secondaryMiss || ''),
          'Shot Weight': s.isLSD ? '' : (s.weight || ''),
          'Key Shot': s.isLSD ? '' : (s.keyShot || ''),
          'Target Direction': s.isLSD ? '' : (s.targetDirection || ''),
          'Target Depth': s.isLSD ? '' : (s.targetDepth || ''),
          Comments: s.comments || '',
          GameOutcome: game.finalScore ? (parseInt(game.finalScore.split('-')[0]) > parseInt(game.finalScore.split('-')[1]) ? 'Win' : parseInt(game.finalScore.split('-')[0]) < parseInt(game.finalScore.split('-')[1]) ? 'Loss' : 'Tie') : ''
        }));

        const csv = Papa.unparse(csvData);
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `curling_shots_${game.gameDate}_vs_${game.opponent.replace(/\s+/g, '_')}.csv`;
        a.click();
        URL.revokeObjectURL(url);
        onNotify('Shot CSV exported!', 'success');
      };

      // Export archived game Team Stats as CSV
      const exportArchivedTeamStatsCSV = (game) => {
        const gameShots = game.shots.filter(s => !s.isLSD);
        const isMixedDoubles = game.gameType === "Mixed Doubles";
        
        // Shot type categorization
        const DRAW_SHOTS = ["Draw", "Tap", "Center Guard", "Corner Guard", "Freeze", "Trick Shot"];
        const TAKEOUT_SHOTS = ["Dig", "Peel", "Double Peel", "Takeout", "Double Takeout", "Hit and Roll", "Runback"];
        
        // Build player stats
        const playerStats = {};
        gameShots.forEach(shot => {
          if (!shot.name || shot.outcome === null) return;
          
          if (!playerStats[shot.name]) {
            playerStats[shot.name] = {
              name: shot.name,
              cwDraw: { total: 0, count: 0 },
              cwTakeout: { total: 0, count: 0 },
              ccwDraw: { total: 0, count: 0 },
              ccwTakeout: { total: 0, count: 0 }
            };
          }
          
          const p = playerStats[shot.name];
          const isDraw = DRAW_SHOTS.includes(shot.shotType);
          const isTakeout = TAKEOUT_SHOTS.includes(shot.shotType);
          const isCW = shot.turn === 'In-Turn';
          const isCCW = shot.turn === 'Out-Turn';
          
          if (isDraw && isCW) { p.cwDraw.total += shot.outcome; p.cwDraw.count++; }
          else if (isDraw && isCCW) { p.ccwDraw.total += shot.outcome; p.ccwDraw.count++; }
          else if (isTakeout && isCW) { p.cwTakeout.total += shot.outcome; p.cwTakeout.count++; }
          else if (isTakeout && isCCW) { p.ccwTakeout.total += shot.outcome; p.ccwTakeout.count++; }
        });
        
        // Calculate ends with/without hammer and efficiency stats
        // Note: s.score is PER-END score (e.g., "2-0" means team scored 2 that end)
        const endStats = {};
        gameShots.forEach(s => {
          if (!endStats[s.end]) {
            endStats[s.end] = { hammer: s.hammer, teamScore: 0, oppScore: 0 };
          }
          if (s.score) {
            const [ts, os] = s.score.split('-').map(Number);
            endStats[s.end].teamScore = ts;
            endStats[s.end].oppScore = os;
          }
        });
        
        // Calculate efficiency stats using per-end scores directly
        let endsWithHammer = 0, endsWithoutHammer = 0;
        let hammerEffNum = 0, hammerEffDenom = 0;
        let forceEffNum = 0, forceEffDenom = 0;
        let stealEffNum = 0, stealEffDenom = 0;
        let stealDefNum = 0, stealDefDenom = 0;
        
        Object.entries(endStats).forEach(([end, data]) => {
          const hadHammer = data.hammer === game.teamName;
          const teamPts = data.teamScore;  // Per-end score
          const oppPts = data.oppScore;    // Per-end score
          const isBlank = teamPts === 0 && oppPts === 0;
          
          if (hadHammer) {
            endsWithHammer++;
            if (!isBlank) { hammerEffDenom++; if (teamPts >= 2) hammerEffNum++; }
            stealDefDenom++; if (oppPts >= 1) stealDefNum++;
          } else {
            endsWithoutHammer++;
            if (oppPts >= 1) { forceEffDenom++; if (oppPts === 1) forceEffNum++; }
            stealEffDenom++; if (teamPts >= 1) stealEffNum++;
          }
        });
        
        const hammerEff = hammerEffDenom > 0 ? (hammerEffNum / hammerEffDenom).toFixed(3) : '';
        const forceEff = forceEffDenom > 0 ? (forceEffNum / forceEffDenom).toFixed(3) : '';
        const stealEff = stealEffDenom > 0 ? (stealEffNum / stealEffDenom).toFixed(3) : '';
        const stealDef = stealDefDenom > 0 ? (stealDefNum / stealDefDenom).toFixed(3) : '';
        
        const calcPct = (data) => data.count === 0 ? '' : Math.round((data.total / (data.count * 4)) * 100);
        
        const csvData = Object.values(playerStats).map(p => ({
          'Name': p.name,
          'Competition': isMixedDoubles ? '' : game.competition,
          'MD Competition': isMixedDoubles ? game.competition : '',
          'Competition Round': game.compRound,
          'Opponent': game.opponent,
          'CW Draw %': calcPct(p.cwDraw),
          'CW Draw Count': p.cwDraw.count || '',
          'CW Takeout %': calcPct(p.cwTakeout),
          'CW Takeout Count': p.cwTakeout.count || '',
          'CCW Draw %': calcPct(p.ccwDraw),
          'CCW Draw Count': p.ccwDraw.count || '',
          'CCW Takeout %': calcPct(p.ccwTakeout),
          'CCW Takeout Count': p.ccwTakeout.count || '',
          'Ends w/Hammer': endsWithHammer,
          'Ends w/o Hammer': endsWithoutHammer,
          'Hammer Efficiency': hammerEff,
          'Force Efficiency': forceEff,
          'Steal Defense': stealDef,
          'Steal Efficiency': stealEff
        }));
        
        const csv = Papa.unparse(csvData);
        const blob = new Blob([csv], { type: 'text/csv' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `curling_team_stats_${game.gameDate}_vs_${game.opponent.replace(/\s+/g, '_')}.csv`;
        a.click();
        URL.revokeObjectURL(url);
        onNotify('Team Stats CSV exported!', 'success');
      };

      // Export archived game as PDF
      const exportArchivedGamePDF = (game) => {
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        
        const gameShots = game.shots.filter(s => !s.isLSD);
        
        // Colors
        const primaryColor = [196, 30, 58];
        const secondaryColor = [26, 26, 46];
        const textLight = [107, 114, 128];
        const accentColor = [20, 184, 166];
        
        let y = 20;
        
        // Header
        doc.setFillColor(...primaryColor);
        doc.rect(0, 0, 210, 40, 'F');
        doc.setTextColor(255, 255, 255);
        doc.setFontSize(20);
        doc.setFont('helvetica', 'bold');
        doc.text('USA CURLING SHOT TRACKER', 105, 18, { align: 'center' });
        doc.setFontSize(12);
        doc.setFont('helvetica', 'normal');
        doc.text(`${game.teamName} vs ${game.opponent}`, 105, 28, { align: 'center' });
        doc.text(`${game.competition} ‚Ä¢ ${game.compRound} ‚Ä¢ ${game.gameDate}`, 105, 36, { align: 'center' });
        
        y = 50;
        
        // Final Score
        doc.setTextColor(...secondaryColor);
        doc.setFontSize(36);
        doc.setFont('helvetica', 'bold');
        doc.text(game.finalScore || '0-0', 105, y + 15, { align: 'center' });
        doc.setFontSize(10);
        doc.text(`${game.teamName}`, 75, y + 25, { align: 'center' });
        doc.text(`${game.opponent}`, 135, y + 25, { align: 'center' });
        
        y += 40;
        
        // Shooting Percentage
        const scoredShots = gameShots.filter(s => s.outcome !== null);
        const totalPoints = scoredShots.reduce((sum, s) => sum + s.outcome, 0);
        const maxPoints = scoredShots.length * 4;
        const overallPct = maxPoints > 0 ? Math.round((totalPoints / maxPoints) * 100) : 0;
        
        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        doc.text('SHOOTING PERCENTAGE', 20, y);
        y += 10;
        doc.setFontSize(28);
        doc.text(`${overallPct}%`, 20, y + 8);
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        doc.setTextColor(...textLight);
        doc.text(`${scoredShots.length} shots`, 50, y + 8);
        
        y += 25;
        
        // Player Stats
        doc.setTextColor(...secondaryColor);
        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        doc.text('SHOT SUCCESS ANALYSIS', 20, y);
        y += 8;
        
        const DRAW_SHOTS = ["Draw", "Tap", "Center Guard", "Corner Guard", "Freeze", "Trick Shot"];
        const TAKEOUT_SHOTS = ["Dig", "Peel", "Double Peel", "Takeout", "Double Takeout", "Hit and Roll", "Runback"];
        
        const playerStats = {};
        gameShots.forEach(shot => {
          if (!shot.name || shot.outcome === null) return;
          if (!playerStats[shot.name]) {
            playerStats[shot.name] = { draws: [], takeouts: [], total: [] };
          }
          playerStats[shot.name].total.push(shot.outcome);
          if (DRAW_SHOTS.includes(shot.shotType)) playerStats[shot.name].draws.push(shot.outcome);
          if (TAKEOUT_SHOTS.includes(shot.shotType)) playerStats[shot.name].takeouts.push(shot.outcome);
        });
        
        const calcPct = (arr) => arr.length > 0 ? Math.round((arr.reduce((a,b) => a+b, 0) / (arr.length * 4)) * 100) : null;
        
        const tableData = Object.entries(playerStats).map(([name, stats]) => [
          name,
          stats.draws.length > 0 ? `(${stats.draws.length}) ${calcPct(stats.draws)}%` : '-',
          stats.takeouts.length > 0 ? `(${stats.takeouts.length}) ${calcPct(stats.takeouts)}%` : '-',
          `(${stats.total.length}) ${calcPct(stats.total)}%`
        ]);
        
        doc.autoTable({
          startY: y,
          head: [['Player', 'Draws', 'Takeouts', 'Overall']],
          body: tableData,
          theme: 'grid',
          headStyles: { fillColor: secondaryColor, fontSize: 9 },
          bodyStyles: { fontSize: 9 },
          columnStyles: { 0: { fontStyle: 'bold' } }
        });
        
        doc.save(`curling_${game.gameDate}_vs_${game.opponent.replace(/\s+/g, '_')}.pdf`);
        onNotify('PDF exported!', 'success');
        setShowExportModal(null);
      };

      // Export competition backup as JSON
      const exportCompetitionBackup = () => {
        if (!selectedCompetition) return;
        
        const backupData = {
          exportedAt: new Date().toISOString(),
          version: '1.0',
          competition: selectedCompetition
        };
        
        const json = JSON.stringify(backupData, null, 2);
        const blob = new Blob([json], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `curling_backup_${selectedCompetition.name.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.json`;
        a.click();
        URL.revokeObjectURL(url);
        onNotify('Competition backup exported!', 'success');
      };

      // Import competition from backup
      const importCompetitionBackup = async (event) => {
        const file = event.target.files[0];
        if (!file) return;
        
        try {
          const text = await file.text();
          const backupData = JSON.parse(text);
          
          if (!backupData.competition || !backupData.competition.name) {
            throw new Error('Invalid backup file format');
          }
          
          // Create new competition with imported data
          const importedComp = {
            ...backupData.competition,
            id: `comp_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            name: backupData.competition.name + ' (Imported)',
            dateCreated: new Date().toISOString()
          };
          
          await CompetitionDB.save(importedComp);
          await loadCompetitions();
          setSelectedCompetition(importedComp);
          onNotify('Competition imported successfully!', 'success');
        } catch (e) {
          console.error('Failed to import backup:', e);
          onNotify('Failed to import backup: ' + e.message, 'error');
        }
        
        // Reset file input
        event.target.value = '';
      };

      // Export Competition Summary PDF
      const exportCompetitionSummaryPDF = () => {
        if (!cumulativeStats) return;
        
        const { jsPDF } = window.jspdf;
        const doc = new jsPDF();
        
        const primaryColor = [196, 30, 58];
        const secondaryColor = [26, 26, 46];
        const textLight = [107, 114, 128];
        const accentColor = [20, 184, 166];
        const successColor = [34, 197, 94];
        const warningColor = [245, 158, 11];
        const errorColor = [239, 68, 68];
        
        let y = 20;
        
        // Header
        doc.setFillColor(...primaryColor);
        doc.rect(0, 0, 210, 35, 'F');
        doc.setTextColor(255, 255, 255);
        doc.setFontSize(18);
        doc.setFont('helvetica', 'bold');
        doc.text('USA CURLING - COMPETITION SUMMARY', 105, 15, { align: 'center' });
        doc.setFontSize(14);
        doc.text(selectedCompetition.name, 105, 24, { align: 'center' });
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        doc.text(`${cumulativeStats.teamName} ‚Ä¢ ${cumulativeStats.totalGames} Games ‚Ä¢ ${cumulativeStats.totalShots} Shots`, 105, 32, { align: 'center' });
        
        y = 45;
        
        // Overall Shooting Percentage
        doc.setTextColor(...secondaryColor);
        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        doc.text('OVERALL SHOOTING PERCENTAGE', 105, y, { align: 'center' });
        y += 15;
        doc.setFontSize(36);
        doc.text(`${cumulativeStats.overallPct}%`, 105, y, { align: 'center' });
        
        y += 15;
        
        // Per-game percentages
        doc.setFontSize(10);
        doc.setFont('helvetica', 'normal');
        const gameLabels = cumulativeStats.gamePercentages.map(g => `vs ${g.opponent}: ${g.pct}%`).join('  ‚Ä¢  ');
        const labelLines = doc.splitTextToSize(gameLabels, 170);
        doc.text(labelLines, 105, y, { align: 'center' });
        y += labelLines.length * 5 + 10;
        
        // Shot Success Analysis Table
        doc.setFontSize(14);
        doc.setFont('helvetica', 'bold');
        doc.text('SHOT SUCCESS ANALYSIS', 20, y);
        y += 5;
        
        const tableData = cumulativeStats.playerTable.map(p => [
          p.name,
          p.draws.inTurnCount > 0 ? `(${p.draws.inTurnCount}) ${p.draws.inTurnPct}%` : '-',
          p.draws.outTurnCount > 0 ? `(${p.draws.outTurnCount}) ${p.draws.outTurnPct}%` : '-',
          p.draws.totalCount > 0 ? `(${p.draws.totalCount}) ${p.draws.totalPct}%` : '-',
          p.takeouts.inTurnCount > 0 ? `(${p.takeouts.inTurnCount}) ${p.takeouts.inTurnPct}%` : '-',
          p.takeouts.outTurnCount > 0 ? `(${p.takeouts.outTurnCount}) ${p.takeouts.outTurnPct}%` : '-',
          p.takeouts.totalCount > 0 ? `(${p.takeouts.totalCount}) ${p.takeouts.totalPct}%` : '-',
          `(${p.total.count}) ${p.total.pct}%`
        ]);
        
        // Add team total row
        const tr = cumulativeStats.teamRow;
        tableData.push([
          'TEAM TOTAL',
          tr.draws.inTurnCount > 0 ? `(${tr.draws.inTurnCount}) ${tr.draws.inTurnPct}%` : '-',
          tr.draws.outTurnCount > 0 ? `(${tr.draws.outTurnCount}) ${tr.draws.outTurnPct}%` : '-',
          tr.draws.totalCount > 0 ? `(${tr.draws.totalCount}) ${tr.draws.totalPct}%` : '-',
          tr.takeouts.inTurnCount > 0 ? `(${tr.takeouts.inTurnCount}) ${tr.takeouts.inTurnPct}%` : '-',
          tr.takeouts.outTurnCount > 0 ? `(${tr.takeouts.outTurnCount}) ${tr.takeouts.outTurnPct}%` : '-',
          tr.takeouts.totalCount > 0 ? `(${tr.takeouts.totalCount}) ${tr.takeouts.totalPct}%` : '-',
          `(${tr.total.count}) ${tr.total.pct}%`
        ]);
        
        doc.autoTable({
          startY: y,
          head: [['Player', 'D-IT', 'D-OT', 'Draws', 'T-IT', 'T-OT', 'T-Outs', 'Game']],
          body: tableData,
          theme: 'grid',
          headStyles: { fillColor: secondaryColor, fontSize: 7 },
          bodyStyles: { fontSize: 7 },
          columnStyles: { 0: { fontStyle: 'bold' } },
          didParseCell: function(data) {
            if (data.row.index === tableData.length - 1) {
              data.cell.styles.fillColor = secondaryColor;
              data.cell.styles.textColor = [255, 255, 255];
              data.cell.styles.fontStyle = 'bold';
            }
          }
        });
        
        y = doc.lastAutoTable.finalY + 15;
        
        // Check if we need a new page
        if (y > 200) {
          doc.addPage();
          y = 20;
        }
        
        // Miss Analysis
        if (cumulativeStats.missShots.length > 0) {
          doc.setFontSize(14);
          doc.setFont('helvetica', 'bold');
          doc.setTextColor(...secondaryColor);
          doc.text(`MISS ANALYSIS (${cumulativeStats.missShots.length} misses)`, 20, y);
          y += 8;
          
          const missCategories = [
            { title: 'By Turn', data: cumulativeStats.missCounts.byTurn, color: primaryColor },
            { title: 'By Shot Type', data: cumulativeStats.missCounts.byShotType, color: accentColor },
            { title: 'By Primary Miss', data: cumulativeStats.missCounts.byPrimary, color: secondaryColor },
            { title: 'By Secondary Miss', data: cumulativeStats.missCounts.bySecondary, color: warningColor }
          ].filter(c => Object.keys(c.data).length > 0);
          
          const colWidth = 45;
          missCategories.forEach((cat, idx) => {
            const x = 20 + (idx * colWidth);
            doc.setFontSize(8);
            doc.setFont('helvetica', 'bold');
            doc.text(cat.title, x, y);
            
            let cy = y + 5;
            const entries = Object.entries(cat.data).sort((a, b) => b[1] - a[1]).slice(0, 5);
            const max = Math.max(...entries.map(e => e[1]));
            
            entries.forEach(([label, count]) => {
              const displayLabel = label === 'In-Turn' ? 'CW' : label === 'Out-Turn' ? 'CCW' : label.substring(0, 10);
              const pct = ((count / cumulativeStats.missShots.length) * 100).toFixed(0);
              const barWidth = (count / max) * 35;
              
              doc.setFontSize(6);
              doc.setFont('helvetica', 'normal');
              doc.setTextColor(...textLight);
              doc.text(`${displayLabel}: ${count}`, x, cy);
              
              doc.setFillColor(...cat.color);
              doc.rect(x, cy + 1, barWidth, 3, 'F');
              
              cy += 6;
            });
          });
          
          y += 45;
        }
        
        // Heat Maps on new page
        if (cumulativeStats.drawHeatMap && cumulativeStats.takeoutHeatMap) {
          doc.addPage();
          y = 20;
          
          doc.setFontSize(14);
          doc.setFont('helvetica', 'bold');
          doc.setTextColor(...secondaryColor);
          doc.text('TARGET HEAT MAPS', 105, y, { align: 'center' });
          y += 10;
          
          const TARGET_DIRECTIONS = ['Left', 'Center', 'Right'];
          const TARGET_DEPTHS = ['Back 12', 'Back 8', 'Back 4', 'T-Line', 'Top 4', 'Top 8', 'Top 12', 'Tight Guard', 'Mid Guard', 'High Guard'];
          
          const getHeatColor = (pct) => {
            if (pct === null) return [229, 231, 235];
            if (pct >= 90) return [34, 197, 94];
            if (pct >= 83) return [132, 204, 22];
            if (pct >= 75) return [250, 204, 21];
            if (pct >= 70) return [251, 146, 60];
            return [239, 68, 68];
          };
          
          const drawHeatMap = (heatMap, title, startX) => {
            doc.setFontSize(12);
            doc.setFont('helvetica', 'bold');
            doc.text(title, startX + 30, y);
            
            const cellW = 20;
            const cellH = 8;
            let mapY = y + 5;
            
            // Header row
            doc.setFontSize(6);
            TARGET_DIRECTIONS.forEach((dir, i) => {
              doc.text(dir.charAt(0), startX + (i * cellW) + cellW/2, mapY, { align: 'center' });
            });
            mapY += 5;
            
            // Data rows
            TARGET_DEPTHS.forEach(depth => {
              // Row label
              const shortLabel = depth.replace('Guard', 'G').replace('High', 'Hi').replace('Mid', 'Mi').replace('Tight', 'Ti');
              doc.setTextColor(...textLight);
              doc.text(shortLabel, startX - 2, mapY + 5, { align: 'right' });
              
              TARGET_DIRECTIONS.forEach((dir, i) => {
                const cell = heatMap[depth]?.[dir];
                const pct = cell && cell.count > 0 ? Math.round((cell.total / cell.sum) * 100) : null;
                const color = getHeatColor(pct);
                
                doc.setFillColor(...color);
                doc.rect(startX + (i * cellW), mapY, cellW - 1, cellH - 1, 'F');
                
                if (pct !== null) {
                  doc.setTextColor(pct >= 75 ? 0 : 255, pct >= 75 ? 0 : 255, pct >= 75 ? 0 : 255);
                  doc.setFontSize(5);
                  doc.text(`${pct}%`, startX + (i * cellW) + cellW/2 - 0.5, mapY + 4, { align: 'center' });
                  doc.text(`(${cell.count})`, startX + (i * cellW) + cellW/2 - 0.5, mapY + 7, { align: 'center' });
                }
              });
              
              mapY += cellH;
            });
          };
          
          drawHeatMap(cumulativeStats.drawHeatMap, 'Draws', 25);
          drawHeatMap(cumulativeStats.takeoutHeatMap, 'Takeouts', 115);
        }
        
        doc.save(`curling_competition_summary_${selectedCompetition.name.replace(/\s+/g, '_')}.pdf`);
        onNotify('Competition Summary PDF exported!', 'success');
      };

      const formatDate = (dateStr) => {
        const date = new Date(dateStr);
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
      };

      const getGameResult = (game) => {
        if (!game.finalScore) return { result: '-', color: 'var(--text-light)' };
        const [team, opp] = game.finalScore.split('-').map(Number);
        if (team > opp) return { result: 'W', color: 'var(--success)' };
        if (team < opp) return { result: 'L', color: 'var(--error)' };
        return { result: 'T', color: 'var(--text-light)' };
      };

      // Calculate cumulative stats for selected competition
      const cumulativeStats = useMemo(() => {
        if (!selectedCompetition || selectedCompetition.games.length === 0) return null;
        
        const gamesToInclude = selectedGames.length > 0 
          ? selectedCompetition.games.filter(g => selectedGames.includes(g.id))
          : selectedCompetition.games;
        
        if (gamesToInclude.length === 0) return null;

        // Combine all non-LSD shots
        const allShots = gamesToInclude.flatMap(g => g.shots.filter(s => !s.isLSD));
        if (allShots.length === 0) return null;

        const teamName = gamesToInclude[0].teamName;
        
        // Filter shots by player for shooting percentage
        const playerFilteredShots = playerFilter === 'Team' 
          ? allShots 
          : allShots.filter(s => s.name === playerFilter);
        
        // Calculate overall shooting percentage (filtered by player)
        const scoredShots = playerFilteredShots.filter(s => s.outcome !== null && s.outcome !== undefined);
        const totalPoints = scoredShots.reduce((sum, s) => sum + s.outcome, 0);
        const maxPoints = scoredShots.length * 4;
        const overallPct = maxPoints > 0 ? Math.round((totalPoints / maxPoints) * 100) : 0;

        // Per-game percentages (filtered by player)
        const gamePercentages = gamesToInclude.map(g => {
          const gameShots = g.shots.filter(s => !s.isLSD && s.outcome !== null && (playerFilter === 'Team' || s.name === playerFilter));
          const pts = gameShots.reduce((sum, s) => sum + s.outcome, 0);
          const max = gameShots.length * 4;
          return {
            id: g.id,
            opponent: g.opponent,
            date: g.gameDate,
            pct: max > 0 ? Math.round((pts / max) * 100) : 0,
            shotCount: gameShots.length
          };
        });

        // Shot type categorization
        const DRAW_SHOTS = ["Draw", "Tap", "Center Guard", "Corner Guard", "Freeze", "Trick Shot"];
        const TAKEOUT_SHOTS = ["Dig", "Peel", "Double Peel", "Takeout", "Double Takeout", "Hit and Roll", "Runback"];

        // Player breakdown
        const playerStats = {};
        allShots.forEach(shot => {
          if (!shot.name || shot.outcome === null) return;
          if (!playerStats[shot.name]) {
            playerStats[shot.name] = {
              name: shot.name,
              draws: { inTurn: [], outTurn: [], all: [] },
              takeouts: { inTurn: [], outTurn: [], all: [] },
              total: []
            };
          }
          const p = playerStats[shot.name];
          const isDraw = DRAW_SHOTS.includes(shot.shotType);
          const isTakeout = TAKEOUT_SHOTS.includes(shot.shotType);
          
          p.total.push(shot.outcome);
          
          if (isDraw) {
            p.draws.all.push(shot.outcome);
            if (shot.turn === 'In-Turn') p.draws.inTurn.push(shot.outcome);
            if (shot.turn === 'Out-Turn') p.draws.outTurn.push(shot.outcome);
          }
          if (isTakeout) {
            p.takeouts.all.push(shot.outcome);
            if (shot.turn === 'In-Turn') p.takeouts.inTurn.push(shot.outcome);
            if (shot.turn === 'Out-Turn') p.takeouts.outTurn.push(shot.outcome);
          }
        });

        const calcPct = (arr) => {
          if (arr.length === 0) return { count: 0, pct: null };
          const sum = arr.reduce((a, b) => a + b, 0);
          return { count: arr.length, pct: Math.round((sum / (arr.length * 4)) * 100) };
        };

        const playerTable = Object.values(playerStats).map(p => ({
          name: p.name,
          draws: {
            inTurnCount: p.draws.inTurn.length,
            inTurnPct: calcPct(p.draws.inTurn).pct,
            outTurnCount: p.draws.outTurn.length,
            outTurnPct: calcPct(p.draws.outTurn).pct,
            totalCount: p.draws.all.length,
            totalPct: calcPct(p.draws.all).pct
          },
          takeouts: {
            inTurnCount: p.takeouts.inTurn.length,
            inTurnPct: calcPct(p.takeouts.inTurn).pct,
            outTurnCount: p.takeouts.outTurn.length,
            outTurnPct: calcPct(p.takeouts.outTurn).pct,
            totalCount: p.takeouts.all.length,
            totalPct: calcPct(p.takeouts.all).pct
          },
          total: calcPct(p.total)
        })).sort((a, b) => b.total.count - a.total.count);

        // Team totals
        const allDraws = { inTurn: [], outTurn: [], all: [] };
        const allTakeouts = { inTurn: [], outTurn: [], all: [] };
        Object.values(playerStats).forEach(p => {
          allDraws.inTurn.push(...p.draws.inTurn);
          allDraws.outTurn.push(...p.draws.outTurn);
          allDraws.all.push(...p.draws.all);
          allTakeouts.inTurn.push(...p.takeouts.inTurn);
          allTakeouts.outTurn.push(...p.takeouts.outTurn);
          allTakeouts.all.push(...p.takeouts.all);
        });

        const teamRow = {
          draws: {
            inTurnCount: allDraws.inTurn.length,
            inTurnPct: calcPct(allDraws.inTurn).pct,
            outTurnCount: allDraws.outTurn.length,
            outTurnPct: calcPct(allDraws.outTurn).pct,
            totalCount: allDraws.all.length,
            totalPct: calcPct(allDraws.all).pct
          },
          takeouts: {
            inTurnCount: allTakeouts.inTurn.length,
            inTurnPct: calcPct(allTakeouts.inTurn).pct,
            outTurnCount: allTakeouts.outTurn.length,
            outTurnPct: calcPct(allTakeouts.outTurn).pct,
            totalCount: allTakeouts.all.length,
            totalPct: calcPct(allTakeouts.all).pct
          },
          total: { count: scoredShots.length, pct: overallPct }
        };

        // Miss analysis - apply player filter
        const filteredShotsForMiss = playerFilter === 'Team' 
          ? allShots 
          : allShots.filter(s => s.name === playerFilter);
        const missShots = filteredShotsForMiss.filter(s => s.miss || s.secondaryMiss);
        const missCounts = {
          byTurn: {},
          byShotType: {},
          byPrimary: {},
          bySecondary: {}
        };
        missShots.forEach(s => {
          if (s.turn) missCounts.byTurn[s.turn] = (missCounts.byTurn[s.turn] || 0) + 1;
          if (s.shotType) missCounts.byShotType[s.shotType] = (missCounts.byShotType[s.shotType] || 0) + 1;
          if (s.miss) missCounts.byPrimary[s.miss] = (missCounts.byPrimary[s.miss] || 0) + 1;
          if (s.secondaryMiss) missCounts.bySecondary[s.secondaryMiss] = (missCounts.bySecondary[s.secondaryMiss] || 0) + 1;
        });

        // Heat maps - apply player filter
        const filteredShotsForHeatMap = playerFilter === 'Team' 
          ? allShots 
          : allShots.filter(s => s.name === playerFilter);
        const TARGET_DIRECTIONS = ['Left', 'Center', 'Right'];
        const TARGET_DEPTHS = ['High Guard', 'Mid Guard', 'Tight Guard', 'Top 12', 'Top 8', 'Top 4', 'T-Line', 'Back 4', 'Back 8', 'Back 12'];
        
        const initHeatMap = () => {
          const map = {};
          TARGET_DEPTHS.forEach(depth => {
            map[depth] = {};
            TARGET_DIRECTIONS.forEach(dir => {
              map[depth][dir] = { total: 0, sum: 0, count: 0 };
            });
          });
          return map;
        };

        const drawHeatMap = initHeatMap();
        const takeoutHeatMap = initHeatMap();

        filteredShotsForHeatMap.forEach(shot => {
          if (!shot.targetDirection || shot.targetDirection === '---' || 
              !shot.targetDepth || shot.targetDepth === '---' ||
              shot.outcome === null) return;
          
          const isDraw = DRAW_SHOTS.includes(shot.shotType);
          const isTakeout = TAKEOUT_SHOTS.includes(shot.shotType);
          
          if (isDraw && drawHeatMap[shot.targetDepth]) {
            drawHeatMap[shot.targetDepth][shot.targetDirection].total += shot.outcome;
            drawHeatMap[shot.targetDepth][shot.targetDirection].sum += 4;
            drawHeatMap[shot.targetDepth][shot.targetDirection].count++;
          } else if (isTakeout && takeoutHeatMap[shot.targetDepth]) {
            takeoutHeatMap[shot.targetDepth][shot.targetDirection].total += shot.outcome;
            takeoutHeatMap[shot.targetDepth][shot.targetDirection].sum += 4;
            takeoutHeatMap[shot.targetDepth][shot.targetDirection].count++;
          }
        });

        // Get unique player names
        const playerNames = [...new Set(allShots.filter(s => s.name).map(s => s.name))].sort();

        // Calculate efficiency stats for competition
        let hammerEffNum = 0, hammerEffDenom = 0;
        let forceEffNum = 0, forceEffDenom = 0;
        let stealEffNum = 0, stealEffDenom = 0;
        let stealDefNum = 0, stealDefDenom = 0;

        gamesToInclude.forEach(game => {
          const gameShots = game.shots.filter(s => !s.isLSD);
          const endStats = {};
          gameShots.forEach(s => {
            if (!endStats[s.end]) {
              endStats[s.end] = { hammer: s.hammer, teamScore: 0, oppScore: 0 };
            }
            if (s.score) {
              const [ts, os] = s.score.split('-').map(Number);
              endStats[s.end].teamScore = ts;
              endStats[s.end].oppScore = os;
            }
          });

          // Per-end scores - use directly
          Object.entries(endStats).forEach(([end, es]) => {
            const teamPts = es.teamScore;
            const oppPts = es.oppScore;
            const hadHammer = es.hammer === game.teamName;
            const isBlank = teamPts === 0 && oppPts === 0;
            
            if (hadHammer) {
              if (!isBlank) { hammerEffDenom++; if (teamPts >= 2) hammerEffNum++; }
              stealDefDenom++; if (oppPts >= 1) stealDefNum++;
            } else {
              if (oppPts >= 1) { forceEffDenom++; if (oppPts === 1) forceEffNum++; }
              stealEffDenom++; if (teamPts >= 1) stealEffNum++;
            }
          });
        });

        return {
          teamName,
          totalGames: gamesToInclude.length,
          totalShots: allShots.length,
          overallPct,
          gamePercentages,
          playerTable,
          playerNames,
          teamRow,
          missShots,
          missCounts,
          drawHeatMap,
          takeoutHeatMap,
          hammerEff: hammerEffDenom > 0 ? Math.round((hammerEffNum / hammerEffDenom) * 100) : null,
          forceEff: forceEffDenom > 0 ? Math.round((forceEffNum / forceEffDenom) * 100) : null,
          stealEff: stealEffDenom > 0 ? Math.round((stealEffNum / stealEffDenom) * 100) : null,
          stealDef: stealDefDenom > 0 ? Math.round((stealDefNum / stealDefDenom) * 100) : null
        };
      }, [selectedCompetition, selectedGames, playerFilter]);

      // Calculate season-wide stats across all competitions
      const seasonStats = useMemo(() => {
        // Get all competitions with archived games
        let competitionsWithGames = competitions.filter(c => c.games && c.games.length > 0);
        if (competitionsWithGames.length === 0) return null;

        const DRAW_SHOTS = ["Draw", "Tap", "Center Guard", "Corner Guard", "Freeze", "Trick Shot"];
        const TAKEOUT_SHOTS = ["Dig", "Peel", "Double Peel", "Takeout", "Double Takeout", "Hit and Roll", "Runback"];
        const TARGET_DIRECTIONS = ['Left', 'Center', 'Right'];
        const TARGET_DEPTHS = ['High Guard', 'Mid Guard', 'Tight Guard', 'Top 12', 'Top 8', 'Top 4', 'T-Line', 'Back 4', 'Back 8', 'Back 12'];

        // Get all games first to extract team names
        const allGamesUnfiltered = competitionsWithGames.flatMap(c => c.games.map(g => ({ ...g, competitionName: c.name, competitionId: c.id })));
        
        // Get unique team names
        const teamNames = [...new Set(allGamesUnfiltered.map(g => g.teamName).filter(Boolean))].sort();
        
        // Filter by team if not "All Teams"
        let allGames = allGamesUnfiltered;
        if (seasonTeamFilter !== 'All Teams') {
          allGames = allGamesUnfiltered.filter(g => g.teamName === seasonTeamFilter);
          // Also filter competitions to only those with games from this team
          competitionsWithGames = competitionsWithGames.map(c => ({
            ...c,
            games: c.games.filter(g => g.teamName === seasonTeamFilter)
          })).filter(c => c.games.length > 0);
        }
        
        if (allGames.length === 0) return { teamNames, noData: true };
        
        const allShots = allGames.flatMap(g => g.shots.filter(s => !s.isLSD).map(s => ({ ...s, competitionName: g.competitionName })));
        
        if (allShots.length === 0) return { teamNames, noData: true };

        // Calculate wins/losses
        let wins = 0, losses = 0, ties = 0;
        allGames.forEach(g => {
          if (g.finalScore) {
            const [teamScore, oppScore] = g.finalScore.split('-').map(Number);
            if (teamScore > oppScore) wins++;
            else if (teamScore < oppScore) losses++;
            else ties++;
          }
        });

        // Get unique player names
        const playerNames = [...new Set(allShots.filter(s => s.name).map(s => s.name))].sort();

        // Filter shots by player for overview
        const filteredShots = overviewPlayerFilter === 'Team' 
          ? allShots 
          : allShots.filter(s => s.name === overviewPlayerFilter);

        // Overall shooting percentage
        const scoredShots = filteredShots.filter(s => s.outcome !== null && s.outcome !== undefined);
        const totalPoints = scoredShots.reduce((sum, s) => sum + s.outcome, 0);
        const maxPoints = scoredShots.length * 4;
        const overallPct = maxPoints > 0 ? Math.round((totalPoints / maxPoints) * 100) : 0;

        // Per-competition stats for graphs
        const competitionStats = competitionsWithGames.map(comp => {
          const compGames = comp.games;
          const compShots = compGames.flatMap(g => g.shots.filter(s => !s.isLSD));
          const filteredCompShots = overviewPlayerFilter === 'Team' 
            ? compShots 
            : compShots.filter(s => s.name === overviewPlayerFilter);
          
          // Shooting percentage
          const scored = filteredCompShots.filter(s => s.outcome !== null);
          const pts = scored.reduce((sum, s) => sum + s.outcome, 0);
          const shootingPct = scored.length > 0 ? Math.round((pts / (scored.length * 4)) * 100) : null;

          // Efficiency calculations for this competition
          let hammerEffNum = 0, hammerEffDenom = 0;
          let forceEffNum = 0, forceEffDenom = 0;
          let stealEffNum = 0, stealEffDenom = 0;
          let stealDefNum = 0, stealDefDenom = 0;

          compGames.forEach(game => {
            const gameShots = game.shots.filter(s => !s.isLSD);
            const endStats = {};
            gameShots.forEach(s => {
              if (!endStats[s.end]) {
                endStats[s.end] = { hammer: s.hammer, teamScore: 0, oppScore: 0 };
              }
              if (s.score) {
                const [ts, os] = s.score.split('-').map(Number);
                endStats[s.end].teamScore = ts;
                endStats[s.end].oppScore = os;
              }
            });

            // Per-end scores - use directly, not as cumulative
            Object.entries(endStats).forEach(([end, es]) => {
              const teamPts = es.teamScore;  // Per-end score
              const oppPts = es.oppScore;    // Per-end score
              const hadHammer = es.hammer === game.teamName;
              const isBlank = teamPts === 0 && oppPts === 0;
              
              if (hadHammer) {
                if (!isBlank) { hammerEffDenom++; if (teamPts >= 2) hammerEffNum++; }
                stealDefDenom++; if (oppPts >= 1) stealDefNum++;
              } else {
                if (oppPts >= 1) { forceEffDenom++; if (oppPts === 1) forceEffNum++; }
                stealEffDenom++; if (teamPts >= 1) stealEffNum++;
              }
            });
          });

          // Draw breakdown by turn for this competition
          const drawCwShots = filteredCompShots.filter(s => DRAW_SHOTS.includes(s.shotType) && s.turn === 'In-Turn' && s.outcome !== null);
          const drawCcwShots = filteredCompShots.filter(s => DRAW_SHOTS.includes(s.shotType) && s.turn === 'Out-Turn' && s.outcome !== null);
          const drawCwPct = drawCwShots.length > 0 ? Math.round((drawCwShots.reduce((sum, s) => sum + s.outcome, 0) / (drawCwShots.length * 4)) * 100) : null;
          const drawCcwPct = drawCcwShots.length > 0 ? Math.round((drawCcwShots.reduce((sum, s) => sum + s.outcome, 0) / (drawCcwShots.length * 4)) * 100) : null;
          
          // Takeout breakdown by turn for this competition
          const takeoutCwShots = filteredCompShots.filter(s => TAKEOUT_SHOTS.includes(s.shotType) && s.turn === 'In-Turn' && s.outcome !== null);
          const takeoutCcwShots = filteredCompShots.filter(s => TAKEOUT_SHOTS.includes(s.shotType) && s.turn === 'Out-Turn' && s.outcome !== null);
          const takeoutCwPct = takeoutCwShots.length > 0 ? Math.round((takeoutCwShots.reduce((sum, s) => sum + s.outcome, 0) / (takeoutCwShots.length * 4)) * 100) : null;
          const takeoutCcwPct = takeoutCcwShots.length > 0 ? Math.round((takeoutCcwShots.reduce((sum, s) => sum + s.outcome, 0) / (takeoutCcwShots.length * 4)) * 100) : null;

          // Miss counts for this competition
          const missShots = filteredCompShots.filter(s => s.miss || s.secondaryMiss);
          const missByTurn = { 'In-Turn': 0, 'Out-Turn': 0 };
          const missByShotType = {};
          const missByPrimary = {};
          const missBySecondary = {};
          missShots.forEach(s => {
            if (s.turn) missByTurn[s.turn] = (missByTurn[s.turn] || 0) + 1;
            if (s.shotType) missByShotType[s.shotType] = (missByShotType[s.shotType] || 0) + 1;
            if (s.miss) missByPrimary[s.miss] = (missByPrimary[s.miss] || 0) + 1;
            if (s.secondaryMiss) missBySecondary[s.secondaryMiss] = (missBySecondary[s.secondaryMiss] || 0) + 1;
          });

          return {
            name: comp.name,
            id: comp.id,
            dateCreated: comp.dateCreated,
            // Get earliest game date for sorting
            earliestGameDate: compGames.reduce((earliest, g) => {
              if (!g.gameDate) return earliest;
              const gameDate = new Date(g.gameDate);
              return !earliest || gameDate < earliest ? gameDate : earliest;
            }, null),
            gameCount: compGames.length,
            shotCount: filteredCompShots.length,
            shootingPct,
            hammerEff: hammerEffDenom > 0 ? Math.round((hammerEffNum / hammerEffDenom) * 100) : null,
            forceEff: forceEffDenom > 0 ? Math.round((forceEffNum / forceEffDenom) * 100) : null,
            stealEff: stealEffDenom > 0 ? Math.round((stealEffNum / stealEffDenom) * 100) : null,
            stealDef: stealDefDenom > 0 ? Math.round((stealDefNum / stealDefDenom) * 100) : null,
            drawCwPct,
            drawCcwPct,
            takeoutCwPct,
            takeoutCcwPct,
            missCount: missShots.length,
            missByTurn,
            missByShotType,
            missByPrimary,
            missBySecondary
          };
        }).sort((a, b) => {
          // Sort by earliest game date, falling back to dateCreated if no game dates
          const dateA = a.earliestGameDate || new Date(a.dateCreated);
          const dateB = b.earliestGameDate || new Date(b.dateCreated);
          return dateA - dateB;
        }); // Sort chronologically by game date

        // Season totals for efficiency
        let seasonHammerNum = 0, seasonHammerDenom = 0;
        let seasonForceNum = 0, seasonForceDenom = 0;
        let seasonStealNum = 0, seasonStealDenom = 0;
        let seasonStealDefNum = 0, seasonStealDefDenom = 0;

        allGames.forEach(game => {
          const gameShots = game.shots.filter(s => !s.isLSD);
          const endStats = {};
          gameShots.forEach(s => {
            if (!endStats[s.end]) {
              endStats[s.end] = { hammer: s.hammer, teamScore: 0, oppScore: 0 };
            }
            if (s.score) {
              const [ts, os] = s.score.split('-').map(Number);
              endStats[s.end].teamScore = ts;
              endStats[s.end].oppScore = os;
            }
          });

          // Per-end scores - use directly, not as cumulative
          Object.entries(endStats).forEach(([end, es]) => {
            const teamPts = es.teamScore;  // Per-end score
            const oppPts = es.oppScore;    // Per-end score
            const hadHammer = es.hammer === game.teamName;
            const isBlank = teamPts === 0 && oppPts === 0;
            
            if (hadHammer) {
              if (!isBlank) { seasonHammerDenom++; if (teamPts >= 2) seasonHammerNum++; }
              seasonStealDefDenom++; if (oppPts >= 1) seasonStealDefNum++;
            } else {
              if (oppPts >= 1) { seasonForceDenom++; if (oppPts === 1) seasonForceNum++; }
              seasonStealDenom++; if (teamPts >= 1) seasonStealNum++;
            }
          });
        });

        // Heat maps for season
        const initHeatMap = () => {
          const map = {};
          TARGET_DEPTHS.forEach(depth => {
            map[depth] = {};
            TARGET_DIRECTIONS.forEach(dir => {
              map[depth][dir] = { total: 0, sum: 0, count: 0 };
            });
          });
          return map;
        };

        const drawHeatMap = initHeatMap();
        const takeoutHeatMap = initHeatMap();

        filteredShots.forEach(shot => {
          if (!shot.targetDirection || shot.targetDirection === '---' || 
              !shot.targetDepth || shot.targetDepth === '---' ||
              shot.outcome === null) return;
          
          const isDraw = DRAW_SHOTS.includes(shot.shotType);
          const isTakeout = TAKEOUT_SHOTS.includes(shot.shotType);
          
          if (isDraw && drawHeatMap[shot.targetDepth]) {
            drawHeatMap[shot.targetDepth][shot.targetDirection].total += shot.outcome;
            drawHeatMap[shot.targetDepth][shot.targetDirection].sum += 4;
            drawHeatMap[shot.targetDepth][shot.targetDirection].count++;
          } else if (isTakeout && takeoutHeatMap[shot.targetDepth]) {
            takeoutHeatMap[shot.targetDepth][shot.targetDirection].total += shot.outcome;
            takeoutHeatMap[shot.targetDepth][shot.targetDirection].sum += 4;
            takeoutHeatMap[shot.targetDepth][shot.targetDirection].count++;
          }
        });

        // Per-player stats for the season
        const playerStats = {};
        filteredShots.forEach(shot => {
          if (!shot.name || shot.outcome === null) return;
          if (!playerStats[shot.name]) {
            playerStats[shot.name] = {
              name: shot.name,
              total: [],
              draws: { inTurn: [], outTurn: [], all: [] },
              takeouts: { inTurn: [], outTurn: [], all: [] }
            };
          }
          const p = playerStats[shot.name];
          const isDraw = DRAW_SHOTS.includes(shot.shotType);
          const isTakeout = TAKEOUT_SHOTS.includes(shot.shotType);
          
          p.total.push(shot.outcome);
          if (isDraw) {
            p.draws.all.push(shot.outcome);
            if (shot.turn === 'In-Turn') p.draws.inTurn.push(shot.outcome);
            if (shot.turn === 'Out-Turn') p.draws.outTurn.push(shot.outcome);
          }
          if (isTakeout) {
            p.takeouts.all.push(shot.outcome);
            if (shot.turn === 'In-Turn') p.takeouts.inTurn.push(shot.outcome);
            if (shot.turn === 'Out-Turn') p.takeouts.outTurn.push(shot.outcome);
          }
        });

        const calcPct = (arr) => {
          if (arr.length === 0) return { count: 0, pct: null };
          const sum = arr.reduce((a, b) => a + b, 0);
          return { count: arr.length, pct: Math.round((sum / (arr.length * 4)) * 100) };
        };

        const playerTable = Object.values(playerStats).map(p => ({
          name: p.name,
          draws: {
            inTurnCount: p.draws.inTurn.length,
            inTurnPct: calcPct(p.draws.inTurn).pct,
            outTurnCount: p.draws.outTurn.length,
            outTurnPct: calcPct(p.draws.outTurn).pct,
            totalCount: p.draws.all.length,
            totalPct: calcPct(p.draws.all).pct
          },
          takeouts: {
            inTurnCount: p.takeouts.inTurn.length,
            inTurnPct: calcPct(p.takeouts.inTurn).pct,
            outTurnCount: p.takeouts.outTurn.length,
            outTurnPct: calcPct(p.takeouts.outTurn).pct,
            totalCount: p.takeouts.all.length,
            totalPct: calcPct(p.takeouts.all).pct
          },
          total: calcPct(p.total)
        })).sort((a, b) => b.total.count - a.total.count);

        // Team row
        const allDraws = { inTurn: [], outTurn: [], all: [] };
        const allTakeouts = { inTurn: [], outTurn: [], all: [] };
        Object.values(playerStats).forEach(p => {
          allDraws.inTurn.push(...p.draws.inTurn);
          allDraws.outTurn.push(...p.draws.outTurn);
          allDraws.all.push(...p.draws.all);
          allTakeouts.inTurn.push(...p.takeouts.inTurn);
          allTakeouts.outTurn.push(...p.takeouts.outTurn);
          allTakeouts.all.push(...p.takeouts.all);
        });

        const teamRow = {
          draws: {
            inTurnCount: allDraws.inTurn.length,
            inTurnPct: calcPct(allDraws.inTurn).pct,
            outTurnCount: allDraws.outTurn.length,
            outTurnPct: calcPct(allDraws.outTurn).pct,
            totalCount: allDraws.all.length,
            totalPct: calcPct(allDraws.all).pct
          },
          takeouts: {
            inTurnCount: allTakeouts.inTurn.length,
            inTurnPct: calcPct(allTakeouts.inTurn).pct,
            outTurnCount: allTakeouts.outTurn.length,
            outTurnPct: calcPct(allTakeouts.outTurn).pct,
            totalCount: allTakeouts.all.length,
            totalPct: calcPct(allTakeouts.all).pct
          },
          total: { count: scoredShots.length, pct: overallPct }
        };

        // Miss analysis for season
        const missShots = filteredShots.filter(s => s.miss || s.secondaryMiss);
        const missCounts = {
          byTurn: {},
          byShotType: {},
          byPrimary: {},
          bySecondary: {}
        };
        missShots.forEach(s => {
          if (s.turn) missCounts.byTurn[s.turn] = (missCounts.byTurn[s.turn] || 0) + 1;
          if (s.shotType) missCounts.byShotType[s.shotType] = (missCounts.byShotType[s.shotType] || 0) + 1;
          if (s.miss) missCounts.byPrimary[s.miss] = (missCounts.byPrimary[s.miss] || 0) + 1;
          if (s.secondaryMiss) missCounts.bySecondary[s.secondaryMiss] = (missCounts.bySecondary[s.secondaryMiss] || 0) + 1;
        });

        return {
          totalGames: allGames.length,
          totalShots: filteredShots.length,
          totalCompetitions: competitionsWithGames.length,
          wins,
          losses,
          ties,
          overallPct,
          hammerEff: seasonHammerDenom > 0 ? Math.round((seasonHammerNum / seasonHammerDenom) * 100) : null,
          forceEff: seasonForceDenom > 0 ? Math.round((seasonForceNum / seasonForceDenom) * 100) : null,
          stealEff: seasonStealDenom > 0 ? Math.round((seasonStealNum / seasonStealDenom) * 100) : null,
          stealDef: seasonStealDefDenom > 0 ? Math.round((seasonStealDefNum / seasonStealDefDenom) * 100) : null,
          competitionStats,
          teamNames,
          playerNames,
          playerTable,
          teamRow,
          missShots,
          missCounts,
          drawHeatMap,
          takeoutHeatMap
        };
      }, [competitions, overviewPlayerFilter, seasonTeamFilter]);

      // Toggle game filter
      const toggleGameFilter = (gameId) => {
        setSelectedGames(prev => 
          prev.includes(gameId) 
            ? prev.filter(id => id !== gameId)
            : [...prev, gameId]
        );
      };

      const clearGameFilter = () => setSelectedGames([]);

      if (loading) {
        return (
          <div style={{ padding: '40px', textAlign: 'center' }}>
            <p>Loading competitions...</p>
          </div>
        );
      }

      return (
        <div style={{ padding: '20px', maxWidth: '1200px', margin: '0 auto' }}>
          {/* Header */}
          <div style={{ marginBottom: '24px' }}>
            <h2 style={{ 
              fontFamily: "'Bebas Neue', sans-serif", 
              fontSize: '28px', 
              color: 'var(--secondary)',
              marginBottom: '8px'
            }}>
              SEASON STATS
            </h2>
            <p style={{ color: 'var(--text-light)', fontSize: '14px' }}>
              View season trends and competition breakdowns
            </p>
          </div>

          {/* Team Filter and Storage Meter */}
          <div style={{ ...styles.card, marginBottom: '16px' }}>
            <div style={{ display: 'flex', gap: '24px', alignItems: 'flex-end', flexWrap: 'wrap' }}>
              <div style={{ flex: 1, minWidth: '200px', maxWidth: '300px' }}>
                <label style={styles.label}>Filter by Team</label>
                <select
                  style={styles.select}
                  value={seasonTeamFilter}
                  onChange={(e) => {
                    const newTeam = e.target.value;
                    setSeasonTeamFilter(newTeam);
                    setOverviewPlayerFilter('Team'); // Reset player filter when team changes
                    // Reset selected competition if it doesn't have games from the new team
                    if (newTeam !== 'All Teams' && selectedCompetition) {
                      const hasGamesFromTeam = selectedCompetition.games?.some(g => g.teamName === newTeam);
                      if (!hasGamesFromTeam) {
                        setSelectedCompetition(null);
                        setViewMode('list');
                        setSelectedGames([]);
                      }
                    }
                  }}
                >
                  <option value="All Teams">All Teams</option>
                  {seasonStats?.teamNames?.map(team => (
                    <option key={team} value={team}>{team}</option>
                  ))}
                </select>
              </div>
              {/* Storage Meter */}
              <div style={{ flex: 1, minWidth: '200px' }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '4px' }}>
                  <span style={{ fontSize: '12px', fontWeight: '600', color: 'var(--text-light)' }}>Storage Used</span>
                  <span style={{ fontSize: '12px', color: 'var(--text-light)' }}>
                    {storageUsage.quota > 0 
                      ? `${(storageUsage.used / (1024 * 1024)).toFixed(1)} MB / ${(storageUsage.quota / (1024 * 1024 * 1024)).toFixed(1)} GB`
                      : 'Calculating...'}
                  </span>
                </div>
                <div style={{ height: '8px', background: 'var(--ice)', borderRadius: '4px', overflow: 'hidden' }}>
                  <div style={{ 
                    width: storageUsage.quota > 0 ? `${Math.min((storageUsage.used / storageUsage.quota) * 100, 100)}%` : '0%', 
                    height: '100%', 
                    background: (storageUsage.used / storageUsage.quota) > 0.8 ? 'var(--error)' : 'var(--success)',
                    borderRadius: '4px',
                    transition: 'width 0.3s'
                  }} />
                </div>
                <div style={{ fontSize: '10px', color: 'var(--text-light)', marginTop: '2px' }}>
                  {storageUsage.quota > 0 
                    ? `${((storageUsage.used / storageUsage.quota) * 100).toFixed(2)}% used`
                    : ''}
                </div>
              </div>
            </div>
          </div>

          {/* Sub-tab navigation */}
          <div style={{ 
            display: 'flex', 
            gap: '8px', 
            marginBottom: '24px',
            background: 'white',
            padding: '8px',
            borderRadius: 'var(--radius)',
            boxShadow: 'var(--shadow)'
          }}>
            <button 
              style={{
                padding: '12px 24px',
                border: 'none',
                background: activeSubTab === 'competitions' ? 'var(--primary)' : 'var(--ice)',
                color: activeSubTab === 'competitions' ? 'white' : 'var(--text)',
                cursor: 'pointer',
                borderRadius: 'var(--radius-sm)',
                fontWeight: '600',
                fontSize: '14px',
                transition: 'all 0.2s'
              }}
              onClick={() => setActiveSubTab('competitions')}
            >
              Competitions
            </button>
            <button 
              style={{
                padding: '12px 24px',
                border: 'none',
                background: activeSubTab === 'overview' ? 'var(--primary)' : 'var(--ice)',
                color: activeSubTab === 'overview' ? 'white' : 'var(--text)',
                cursor: 'pointer',
                borderRadius: 'var(--radius-sm)',
                fontWeight: '600',
                fontSize: '14px',
                transition: 'all 0.2s'
              }}
              onClick={() => setActiveSubTab('overview')}
            >
              Season Overview
            </button>
          </div>

          {/* Season Overview Tab */}
          {activeSubTab === 'overview' && (
            <div>
              {!seasonStats || seasonStats.noData ? (
                <div style={styles.card}>
                  <p style={{ textAlign: 'center', color: 'var(--text-light)', padding: '40px' }}>
                    {seasonTeamFilter !== 'All Teams' 
                      ? `No archived games for ${seasonTeamFilter}. Archive games from competitions to see season stats.`
                      : 'No archived games yet. Archive games from competitions to see season stats.'}
                  </p>
                </div>
              ) : (
                <div>
                  {/* Record Section */}
                  <div style={styles.card}>
                    <h3 style={styles.cardTitle}>SEASON RECORD</h3>
                    <div style={{ display: 'flex', gap: '24px', flexWrap: 'wrap', justifyContent: 'center' }}>
                      <div style={{ textAlign: 'center' }}>
                        <div style={{ fontSize: '42px', fontWeight: '700', color: 'var(--success)' }}>{seasonStats.wins}</div>
                        <div style={{ fontSize: '14px', color: 'var(--text-light)' }}>Wins</div>
                      </div>
                      <div style={{ textAlign: 'center' }}>
                        <div style={{ fontSize: '42px', fontWeight: '700', color: 'var(--error)' }}>{seasonStats.losses}</div>
                        <div style={{ fontSize: '14px', color: 'var(--text-light)' }}>Losses</div>
                      </div>
                      {seasonStats.ties > 0 && (
                        <div style={{ textAlign: 'center' }}>
                          <div style={{ fontSize: '42px', fontWeight: '700', color: 'var(--text-light)' }}>{seasonStats.ties}</div>
                          <div style={{ fontSize: '14px', color: 'var(--text-light)' }}>Ties</div>
                        </div>
                      )}
                      <div style={{ textAlign: 'center', marginLeft: '24px', paddingLeft: '24px', borderLeft: '2px solid var(--ice)' }}>
                        <div style={{ fontSize: '42px', fontWeight: '700', color: 'var(--secondary)' }}>{seasonStats.totalGames}</div>
                        <div style={{ fontSize: '14px', color: 'var(--text-light)' }}>Games</div>
                      </div>
                      <div style={{ textAlign: 'center' }}>
                        <div style={{ fontSize: '42px', fontWeight: '700', color: 'var(--primary)' }}>{seasonStats.totalCompetitions}</div>
                        <div style={{ fontSize: '14px', color: 'var(--text-light)' }}>Competitions</div>
                      </div>
                    </div>
                  </div>

                  {/* Team Stats Summary */}
                  <div style={styles.card}>
                    <h3 style={styles.cardTitle}>TEAM SEASON STATS</h3>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(120px, 1fr))', gap: '16px' }}>
                      <div style={{ textAlign: 'center', padding: '16px', background: 'var(--ice)', borderRadius: 'var(--radius-sm)' }}>
                        <div style={{ fontSize: '28px', fontWeight: '700', color: 'var(--primary)' }}>{seasonStats.overallPct}%</div>
                        <div style={{ fontSize: '12px', color: 'var(--text-light)' }}>Shooting %</div>
                      </div>
                      <div style={{ textAlign: 'center', padding: '16px', background: 'var(--ice)', borderRadius: 'var(--radius-sm)' }}>
                        <div style={{ fontSize: '28px', fontWeight: '700', color: '#22c55e' }}>{seasonStats.hammerEff !== null ? `${seasonStats.hammerEff}%` : '-'}</div>
                        <div style={{ fontSize: '12px', color: 'var(--text-light)' }}>Hammer Eff</div>
                      </div>
                      <div style={{ textAlign: 'center', padding: '16px', background: 'var(--ice)', borderRadius: 'var(--radius-sm)' }}>
                        <div style={{ fontSize: '28px', fontWeight: '700', color: '#3b82f6' }}>{seasonStats.forceEff !== null ? `${seasonStats.forceEff}%` : '-'}</div>
                        <div style={{ fontSize: '12px', color: 'var(--text-light)' }}>Force Eff</div>
                      </div>
                      <div style={{ textAlign: 'center', padding: '16px', background: 'var(--ice)', borderRadius: 'var(--radius-sm)' }}>
                        <div style={{ fontSize: '28px', fontWeight: '700', color: '#f59e0b' }}>{seasonStats.stealEff !== null ? `${seasonStats.stealEff}%` : '-'}</div>
                        <div style={{ fontSize: '12px', color: 'var(--text-light)' }}>Steal Eff</div>
                      </div>
                      <div style={{ textAlign: 'center', padding: '16px', background: 'var(--ice)', borderRadius: 'var(--radius-sm)' }}>
                        <div style={{ fontSize: '28px', fontWeight: '700', color: '#ef4444' }}>{seasonStats.stealDef !== null ? `${seasonStats.stealDef}%` : '-'}</div>
                        <div style={{ fontSize: '12px', color: 'var(--text-light)' }}>Steal Def</div>
                      </div>
                    </div>
                  </div>

                  {/* Efficiency Trend Graph */}
                  {seasonStats.competitionStats.length >= 2 && (
                    <div style={styles.card}>
                      <h3 style={styles.cardTitle}>EFFICIENCY TRENDS BY COMPETITION</h3>
                      <div style={{ display: 'flex', gap: '12px', flexWrap: 'wrap', marginBottom: '16px' }}>
                        {[
                          { key: 'hammer', label: 'Hammer Eff', color: '#22c55e' },
                          { key: 'force', label: 'Force Eff', color: '#3b82f6' },
                          { key: 'steal', label: 'Steal Eff', color: '#f59e0b' },
                          { key: 'stealDef', label: 'Steal Def', color: '#ef4444' }
                        ].map(line => (
                          <button
                            key={line.key}
                            onClick={() => setEfficiencyLineToggles(prev => ({ ...prev, [line.key]: !prev[line.key] }))}
                            style={{
                              padding: '8px 16px',
                              borderRadius: 'var(--radius-sm)',
                              border: `2px solid ${line.color}`,
                              background: efficiencyLineToggles[line.key] ? line.color : 'white',
                              color: efficiencyLineToggles[line.key] ? 'white' : line.color,
                              cursor: 'pointer',
                              fontWeight: '600',
                              fontSize: '12px'
                            }}
                          >
                            {line.label}
                          </button>
                        ))}
                      </div>
                      <div style={{ overflowX: 'auto' }}>
                        <svg width={Math.max(600, seasonStats.competitionStats.length * 100)} height="250" style={{ display: 'block' }}>
                          {/* Grid lines */}
                          {[0, 25, 50, 75, 100].map(pct => (
                            <g key={pct}>
                              <line 
                                x1="60" 
                                y1={200 - (pct * 1.8)} 
                                x2={60 + (seasonStats.competitionStats.length - 1) * 80 + 40} 
                                y2={200 - (pct * 1.8)} 
                                stroke="#e5e7eb" 
                                strokeWidth="1"
                              />
                              <text x="55" y={200 - (pct * 1.8) + 4} textAnchor="end" fontSize="10" fill="#9ca3af">{pct}%</text>
                            </g>
                          ))}
                          {/* Lines */}
                          {[
                            { key: 'hammer', field: 'hammerEff', color: '#22c55e' },
                            { key: 'force', field: 'forceEff', color: '#3b82f6' },
                            { key: 'steal', field: 'stealEff', color: '#f59e0b' },
                            { key: 'stealDef', field: 'stealDef', color: '#ef4444' }
                          ].filter(line => efficiencyLineToggles[line.key]).map(line => {
                            const points = seasonStats.competitionStats
                              .map((c, i) => ({ x: 80 + i * 80, y: c[line.field] !== null ? 200 - (c[line.field] * 1.8) : null }))
                              .filter(p => p.y !== null);
                            if (points.length < 2) return null;
                            const pathD = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
                            return (
                              <g key={line.key}>
                                <path d={pathD} fill="none" stroke={line.color} strokeWidth="3" />
                                {points.map((p, i) => (
                                  <circle key={i} cx={p.x} cy={p.y} r="5" fill={line.color} />
                                ))}
                              </g>
                            );
                          })}
                          {/* X-axis labels */}
                          {seasonStats.competitionStats.map((c, i) => (
                            <text 
                              key={c.id} 
                              x={80 + i * 80} 
                              y="220" 
                              textAnchor="middle" 
                              fontSize="10" 
                              fill="#6b7280"
                              transform={`rotate(-20, ${80 + i * 80}, 220)`}
                            >
                              {c.name.length > 12 ? c.name.substring(0, 12) + '...' : c.name}
                            </text>
                          ))}
                        </svg>
                      </div>
                    </div>
                  )}

                  {/* Filter by Player */}
                  {seasonStats.playerNames && seasonStats.playerNames.length > 0 && (
                    <div style={styles.card}>
                      <h3 style={styles.cardTitle}>FILTER BY PLAYER</h3>
                      <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                        <button
                          onClick={() => setOverviewPlayerFilter('Team')}
                          style={{
                            padding: '10px 20px',
                            borderRadius: 'var(--radius-sm)',
                            border: 'none',
                            cursor: 'pointer',
                            fontWeight: overviewPlayerFilter === 'Team' ? '700' : '500',
                            background: overviewPlayerFilter === 'Team' ? 'var(--primary)' : 'var(--ice)',
                            color: overviewPlayerFilter === 'Team' ? 'white' : 'var(--text)',
                            fontSize: '14px'
                          }}
                        >
                          Team
                        </button>
                        {seasonStats.playerNames.map(name => (
                          <button
                            key={name}
                            onClick={() => setOverviewPlayerFilter(name)}
                            style={{
                              padding: '10px 20px',
                              borderRadius: 'var(--radius-sm)',
                              border: 'none',
                              cursor: 'pointer',
                              fontWeight: overviewPlayerFilter === name ? '700' : '500',
                              background: overviewPlayerFilter === name ? 'var(--secondary)' : 'var(--ice)',
                              color: overviewPlayerFilter === name ? 'white' : 'var(--text)',
                              fontSize: '14px'
                            }}
                          >
                            {name}
                          </button>
                        ))}
                      </div>
                      <div style={{ fontSize: '11px', color: 'var(--text-light)', marginTop: '8px' }}>
                        Filter affects shooting percentage trends, miss analysis, and heat maps below
                      </div>
                    </div>
                  )}

                  {/* Shooting Percentage Trend Graph */}
                  {seasonStats.competitionStats.length >= 2 && (
                    <div style={styles.card}>
                      <h3 style={styles.cardTitle}>SHOOTING PERCENTAGE TREND {overviewPlayerFilter !== 'Team' && `- ${overviewPlayerFilter}`}</h3>
                      <div style={{ overflowX: 'auto' }}>
                        <svg width={Math.max(600, seasonStats.competitionStats.length * 100)} height="280" style={{ display: 'block' }}>
                          {/* Grid lines */}
                          {[0, 25, 50, 75, 100].map(pct => (
                            <g key={pct}>
                              <line 
                                x1="60" 
                                y1={220 - (pct * 2)} 
                                x2={60 + (seasonStats.competitionStats.length - 1) * 80 + 40} 
                                y2={220 - (pct * 2)} 
                                stroke="#e5e7eb" 
                                strokeWidth="1"
                              />
                              <text x="55" y={220 - (pct * 2) + 4} textAnchor="end" fontSize="10" fill="#9ca3af">{pct}%</text>
                            </g>
                          ))}
                          {/* Overall shooting line */}
                          {(() => {
                            const points = seasonStats.competitionStats
                              .map((c, i) => ({ x: 80 + i * 80, y: c.shootingPct !== null ? 220 - (c.shootingPct * 2) : null, pct: c.shootingPct }))
                              .filter(p => p.y !== null);
                            if (points.length < 2) return null;
                            const pathD = points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ');
                            return (
                              <g>
                                <path d={pathD} fill="none" stroke="var(--primary)" strokeWidth="3" />
                                {points.map((p, i) => (
                                  <g key={i}>
                                    <circle cx={p.x} cy={p.y} r="6" fill="var(--primary)" />
                                    <text x={p.x} y={p.y - 10} textAnchor="middle" fontSize="10" fontWeight="600" fill="var(--primary)">{p.pct}%</text>
                                  </g>
                                ))}
                              </g>
                            );
                          })()}
                          {/* X-axis labels */}
                          {seasonStats.competitionStats.map((c, i) => (
                            <text 
                              key={c.id} 
                              x={80 + i * 80} 
                              y="250" 
                              textAnchor="middle" 
                              fontSize="10" 
                              fill="#6b7280"
                              transform={`rotate(-20, ${80 + i * 80}, 250)`}
                            >
                              {c.name.length > 12 ? c.name.substring(0, 12) + '...' : c.name}
                            </text>
                          ))}
                        </svg>
                      </div>
                    </div>
                  )}

                  {/* Draw Trend */}
                  {seasonStats.competitionStats.length >= 2 && (
                    <div style={styles.card}>
                      <h3 style={styles.cardTitle}>DRAW TREND {overviewPlayerFilter !== 'Team' && `- ${overviewPlayerFilter}`}</h3>
                      <div style={{ display: 'flex', gap: '12px', marginBottom: '8px' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                          <div style={{ width: '12px', height: '12px', background: 'var(--primary)', borderRadius: '2px' }} />
                          <span style={{ fontSize: '12px' }}>Clockwise</span>
                        </div>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                          <div style={{ width: '12px', height: '12px', background: 'var(--accent)', borderRadius: '2px' }} />
                          <span style={{ fontSize: '12px' }}>Counter Clockwise</span>
                        </div>
                      </div>
                      <div style={{ overflowX: 'auto' }}>
                        <svg width={Math.max(600, seasonStats.competitionStats.length * 100)} height="280" style={{ display: 'block' }}>
                          {[0, 25, 50, 75, 100].map(pct => (
                            <g key={pct}>
                              <line x1="60" y1={220 - (pct * 2)} x2={60 + (seasonStats.competitionStats.length - 1) * 80 + 40} y2={220 - (pct * 2)} stroke="#e5e7eb" strokeWidth="1" />
                              <text x="55" y={220 - (pct * 2) + 4} textAnchor="end" fontSize="10" fill="#9ca3af">{pct}%</text>
                            </g>
                          ))}
                          {/* Draw CW line */}
                          {(() => {
                            const points = seasonStats.competitionStats.map((c, i) => ({ x: 80 + i * 80, y: c.drawCwPct !== null ? 220 - (c.drawCwPct * 2) : null })).filter(p => p.y !== null);
                            if (points.length < 2) return null;
                            return <path d={points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ')} fill="none" stroke="var(--primary)" strokeWidth="3" />;
                          })()}
                          {seasonStats.competitionStats.map((c, i) => c.drawCwPct !== null && <circle key={`dcw-${i}`} cx={80 + i * 80} cy={220 - (c.drawCwPct * 2)} r="5" fill="var(--primary)" />)}
                          {/* Draw CCW line */}
                          {(() => {
                            const points = seasonStats.competitionStats.map((c, i) => ({ x: 80 + i * 80, y: c.drawCcwPct !== null ? 220 - (c.drawCcwPct * 2) : null })).filter(p => p.y !== null);
                            if (points.length < 2) return null;
                            return <path d={points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ')} fill="none" stroke="var(--accent)" strokeWidth="3" />;
                          })()}
                          {seasonStats.competitionStats.map((c, i) => c.drawCcwPct !== null && <circle key={`dccw-${i}`} cx={80 + i * 80} cy={220 - (c.drawCcwPct * 2)} r="5" fill="var(--accent)" />)}
                          {seasonStats.competitionStats.map((c, i) => (
                            <text key={c.id} x={80 + i * 80} y="250" textAnchor="middle" fontSize="10" fill="#6b7280" transform={`rotate(-20, ${80 + i * 80}, 250)`}>
                              {c.name.length > 12 ? c.name.substring(0, 12) + '...' : c.name}
                            </text>
                          ))}
                        </svg>
                      </div>
                    </div>
                  )}

                  {/* Takeout Trend */}
                  {seasonStats.competitionStats.length >= 2 && (
                    <div style={styles.card}>
                      <h3 style={styles.cardTitle}>TAKEOUT TREND {overviewPlayerFilter !== 'Team' && `- ${overviewPlayerFilter}`}</h3>
                      <div style={{ display: 'flex', gap: '12px', marginBottom: '8px' }}>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                          <div style={{ width: '12px', height: '12px', background: 'var(--primary)', borderRadius: '2px' }} />
                          <span style={{ fontSize: '12px' }}>Clockwise</span>
                        </div>
                        <div style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                          <div style={{ width: '12px', height: '12px', background: 'var(--accent)', borderRadius: '2px' }} />
                          <span style={{ fontSize: '12px' }}>Counter Clockwise</span>
                        </div>
                      </div>
                      <div style={{ overflowX: 'auto' }}>
                        <svg width={Math.max(600, seasonStats.competitionStats.length * 100)} height="280" style={{ display: 'block' }}>
                          {[0, 25, 50, 75, 100].map(pct => (
                            <g key={pct}>
                              <line x1="60" y1={220 - (pct * 2)} x2={60 + (seasonStats.competitionStats.length - 1) * 80 + 40} y2={220 - (pct * 2)} stroke="#e5e7eb" strokeWidth="1" />
                              <text x="55" y={220 - (pct * 2) + 4} textAnchor="end" fontSize="10" fill="#9ca3af">{pct}%</text>
                            </g>
                          ))}
                          {/* Takeout CW line */}
                          {(() => {
                            const points = seasonStats.competitionStats.map((c, i) => ({ x: 80 + i * 80, y: c.takeoutCwPct !== null ? 220 - (c.takeoutCwPct * 2) : null })).filter(p => p.y !== null);
                            if (points.length < 2) return null;
                            return <path d={points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ')} fill="none" stroke="var(--primary)" strokeWidth="3" />;
                          })()}
                          {seasonStats.competitionStats.map((c, i) => c.takeoutCwPct !== null && <circle key={`tcw-${i}`} cx={80 + i * 80} cy={220 - (c.takeoutCwPct * 2)} r="5" fill="var(--primary)" />)}
                          {/* Takeout CCW line */}
                          {(() => {
                            const points = seasonStats.competitionStats.map((c, i) => ({ x: 80 + i * 80, y: c.takeoutCcwPct !== null ? 220 - (c.takeoutCcwPct * 2) : null })).filter(p => p.y !== null);
                            if (points.length < 2) return null;
                            return <path d={points.map((p, i) => `${i === 0 ? 'M' : 'L'} ${p.x} ${p.y}`).join(' ')} fill="none" stroke="var(--accent)" strokeWidth="3" />;
                          })()}
                          {seasonStats.competitionStats.map((c, i) => c.takeoutCcwPct !== null && <circle key={`tccw-${i}`} cx={80 + i * 80} cy={220 - (c.takeoutCcwPct * 2)} r="5" fill="var(--accent)" />)}
                          {seasonStats.competitionStats.map((c, i) => (
                            <text key={c.id} x={80 + i * 80} y="250" textAnchor="middle" fontSize="10" fill="#6b7280" transform={`rotate(-20, ${80 + i * 80}, 250)`}>
                              {c.name.length > 12 ? c.name.substring(0, 12) + '...' : c.name}
                            </text>
                          ))}
                        </svg>
                      </div>
                    </div>
                  )}

                  {/* Season Heat Maps */}
                  {(() => {
                    const hasDrawData = seasonStats.drawHeatMap && Object.values(seasonStats.drawHeatMap).some(row => 
                      Object.values(row).some(cell => cell.count > 0)
                    );
                    const hasTakeoutData = seasonStats.takeoutHeatMap && Object.values(seasonStats.takeoutHeatMap).some(row => 
                      Object.values(row).some(cell => cell.count > 0)
                    );
                    
                    if (!hasDrawData && !hasTakeoutData) return null;
                    
                    const TARGET_DIRECTIONS = ['Left', 'Center', 'Right'];
                    const TARGET_DEPTHS = ['Back 12', 'Back 8', 'Back 4', 'T-Line', 'Top 4', 'Top 8', 'Top 12', 'Tight Guard', 'Mid Guard', 'High Guard'];
                    
                    const getHeatColor = (pct) => {
                      if (pct === null) return 'rgba(229, 231, 235, 0.7)';
                      if (pct >= 90) return 'rgba(34, 197, 94, 0.8)';
                      if (pct >= 83) return 'rgba(132, 204, 22, 0.8)';
                      if (pct >= 75) return 'rgba(250, 204, 21, 0.8)';
                      if (pct >= 70) return 'rgba(251, 146, 60, 0.8)';
                      return 'rgba(239, 68, 68, 0.8)';
                    };
                    
                    const cellWidth = 70;
                    const cellHeight = 45;
                    
                    const renderHeatMap = (heatMapData, title) => {
                      if (!heatMapData) return null;
                      const hasData = Object.values(heatMapData).some(row => Object.values(row).some(cell => cell.count > 0));
                      if (!hasData) return null;
                      
                      return (
                        <div style={{ flex: 1, minWidth: '280px' }}>
                          <h4 style={{ fontSize: '14px', fontWeight: '600', marginBottom: '12px', color: 'var(--secondary)', textAlign: 'center' }}>{title}</h4>
                          <div style={{ display: 'flex', justifyContent: 'center' }}>
                            <svg width={cellWidth * 3 + 70} height={cellHeight * 10 + 30}>
                              {TARGET_DIRECTIONS.map((dir, di) => (
                                <text key={dir} x={70 + di * cellWidth + cellWidth/2} y="15" textAnchor="middle" fontSize="11" fontWeight="600">{dir}</text>
                              ))}
                              {TARGET_DEPTHS.map((depth, di) => {
                                const isGuard = depth.includes('Guard');
                                return (
                                  <g key={depth}>
                                    <text x="65" y={30 + di * cellHeight + cellHeight/2 + 4} textAnchor="end" fontSize="10">{depth}</text>
                                    {TARGET_DIRECTIONS.map((dir, dri) => {
                                      const cell = heatMapData[depth]?.[dir];
                                      const pct = cell && cell.count > 0 ? Math.round((cell.total / cell.sum) * 100) : null;
                                      return (
                                        <g key={`${depth}-${dir}`}>
                                          <rect x={70 + dri * cellWidth} y={25 + di * cellHeight} width={cellWidth - 2} height={cellHeight - 2} fill={getHeatColor(pct)} rx="4" stroke={isGuard ? '#666' : 'transparent'} strokeWidth="1" strokeDasharray={isGuard ? '3,3' : ''} />
                                          {pct !== null && (
                                            <text x={70 + dri * cellWidth + cellWidth/2 - 1} y={25 + di * cellHeight + cellHeight/2 + 5} textAnchor="middle" fontSize="12" fontWeight="600" fill={pct >= 75 ? '#1a1a1a' : '#fff'}>{pct}%</text>
                                          )}
                                          {cell && cell.count > 0 && (
                                            <text x={70 + dri * cellWidth + cellWidth/2 - 1} y={25 + di * cellHeight + cellHeight/2 + 18} textAnchor="middle" fontSize="9" fill={pct >= 75 ? '#666' : 'rgba(255,255,255,0.8)'}>{cell.count}</text>
                                          )}
                                        </g>
                                      );
                                    })}
                                  </g>
                                );
                              })}
                            </svg>
                          </div>
                        </div>
                      );
                    };
                    
                    return (
                      <div style={styles.card}>
                        <h3 style={styles.cardTitle}>SEASON HEAT MAPS {overviewPlayerFilter !== 'Team' && `- ${overviewPlayerFilter}`}</h3>
                        <div style={{ display: 'flex', gap: '24px', flexWrap: 'wrap', justifyContent: 'center' }}>
                          {renderHeatMap(seasonStats.drawHeatMap, 'Draws')}
                          {renderHeatMap(seasonStats.takeoutHeatMap, 'Takeouts')}
                        </div>
                        <div style={{ display: 'flex', justifyContent: 'center', gap: '12px', marginTop: '16px', flexWrap: 'wrap' }}>
                          {[
                            { label: '90%+', color: 'rgba(34, 197, 94, 0.8)' },
                            { label: '83-89%', color: 'rgba(132, 204, 22, 0.8)' },
                            { label: '75-82%', color: 'rgba(250, 204, 21, 0.8)' },
                            { label: '70-74%', color: 'rgba(251, 146, 60, 0.8)' },
                            { label: '<70%', color: 'rgba(239, 68, 68, 0.8)' },
                            { label: 'No data', color: 'rgba(229, 231, 235, 0.7)' }
                          ].map(item => (
                            <div key={item.label} style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                              <div style={{ width: '16px', height: '16px', background: item.color, borderRadius: '3px', border: '1px solid rgba(0,0,0,0.1)' }} />
                              <span style={{ fontSize: '11px', color: 'var(--text-light)' }}>{item.label}</span>
                            </div>
                          ))}
                        </div>
                      </div>
                    );
                  })()}

                  {/* Season Miss Analysis with filters */}
                  {seasonStats.missShots.length > 0 && (
                    <div style={styles.card}>
                      <h3 style={styles.cardTitle}>SEASON MISS ANALYSIS {overviewPlayerFilter !== 'Team' && `- ${overviewPlayerFilter}`}</h3>
                      
                      {(() => {
                        const missShots = seasonStats.missShots;
                        
                        // Get unique values for filters
                        const turns = [...new Set(missShots.map(s => s.turn).filter(Boolean))];
                        const shotTypes = [...new Set(missShots.map(s => s.shotType).filter(Boolean))];
                        const primaryMisses = [...new Set(missShots.map(s => s.miss).filter(Boolean))];
                        const secondaryMisses = [...new Set(missShots.map(s => s.secondaryMiss).filter(Boolean))];
                        
                        return (
                          <div>
                            {/* Filter Controls */}
                            <div style={{ 
                              display: 'grid', 
                              gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', 
                              gap: '12px',
                              marginBottom: '20px',
                              padding: '16px',
                              background: 'var(--ice)',
                              borderRadius: 'var(--radius-sm)'
                            }}>
                              <div>
                                <label style={{ fontSize: '12px', fontWeight: '600', display: 'block', marginBottom: '4px' }}>Turn</label>
                                <select
                                  style={{ ...styles.select, width: '100%', fontSize: '13px' }}
                                  value={seasonMissFilterTurn || ''}
                                  onChange={(e) => setSeasonMissFilterTurn(e.target.value || null)}
                                >
                                  <option value="">All Turns</option>
                                  {turns.map(t => <option key={t} value={t}>{t === 'In-Turn' ? 'Clockwise' : t === 'Out-Turn' ? 'Counter Clockwise' : t}</option>)}
                                </select>
                              </div>
                              <div>
                                <label style={{ fontSize: '12px', fontWeight: '600', display: 'block', marginBottom: '4px' }}>Shot Type</label>
                                <select
                                  style={{ ...styles.select, width: '100%', fontSize: '13px' }}
                                  value={seasonMissFilterShotType || ''}
                                  onChange={(e) => setSeasonMissFilterShotType(e.target.value || null)}
                                >
                                  <option value="">All Shot Types</option>
                                  {shotTypes.map(st => <option key={st} value={st}>{st}</option>)}
                                </select>
                              </div>
                              <div>
                                <label style={{ fontSize: '12px', fontWeight: '600', display: 'block', marginBottom: '4px' }}>Primary Miss</label>
                                <select
                                  style={{ ...styles.select, width: '100%', fontSize: '13px' }}
                                  value={seasonMissFilterPrimary || ''}
                                  onChange={(e) => setSeasonMissFilterPrimary(e.target.value || null)}
                                >
                                  <option value="">All Primary</option>
                                  {primaryMisses.map(m => <option key={m} value={m}>{m}</option>)}
                                </select>
                              </div>
                              <div>
                                <label style={{ fontSize: '12px', fontWeight: '600', display: 'block', marginBottom: '4px' }}>Secondary Miss</label>
                                <select
                                  style={{ ...styles.select, width: '100%', fontSize: '13px' }}
                                  value={seasonMissFilterSecondary || ''}
                                  onChange={(e) => setSeasonMissFilterSecondary(e.target.value || null)}
                                >
                                  <option value="">All Secondary</option>
                                  {secondaryMisses.map(m => <option key={m} value={m}>{m}</option>)}
                                </select>
                              </div>
                            </div>
                            
                            {/* Filtered Results */}
                            {(() => {
                              let filtered = missShots;
                              if (seasonMissFilterTurn) filtered = filtered.filter(s => s.turn === seasonMissFilterTurn);
                              if (seasonMissFilterShotType) filtered = filtered.filter(s => s.shotType === seasonMissFilterShotType);
                              if (seasonMissFilterPrimary) filtered = filtered.filter(s => s.miss === seasonMissFilterPrimary);
                              if (seasonMissFilterSecondary) filtered = filtered.filter(s => s.secondaryMiss === seasonMissFilterSecondary);
                              
                              const showTurnBreakdown = !seasonMissFilterTurn;
                              const showShotTypeBreakdown = !seasonMissFilterShotType;
                              const showPrimaryBreakdown = !seasonMissFilterPrimary;
                              const showSecondaryBreakdown = !seasonMissFilterSecondary;
                              
                              const turnCounts = {};
                              const shotTypeCounts = {};
                              const primaryCounts = {};
                              const secondaryCounts = {};
                              
                              filtered.forEach(s => {
                                if (s.turn) turnCounts[s.turn] = (turnCounts[s.turn] || 0) + 1;
                                if (s.shotType) shotTypeCounts[s.shotType] = (shotTypeCounts[s.shotType] || 0) + 1;
                                if (s.miss) primaryCounts[s.miss] = (primaryCounts[s.miss] || 0) + 1;
                                if (s.secondaryMiss) secondaryCounts[s.secondaryMiss] = (secondaryCounts[s.secondaryMiss] || 0) + 1;
                              });
                              
                              const totalFiltered = filtered.length;
                              
                              const renderBreakdown = (title, data, color) => {
                                const entries = Object.entries(data).sort((a, b) => b[1] - a[1]);
                                const max = Math.max(...entries.map(e => e[1]));
                                return (
                                  <div>
                                    <h4 style={{ fontSize: '13px', fontWeight: '600', marginBottom: '10px', color: 'var(--secondary)' }}>{title}</h4>
                                    {entries.map(([label, count]) => {
                                      const displayLabel = label === 'In-Turn' ? 'Clockwise' : label === 'Out-Turn' ? 'Counter CW' : label;
                                      const pct = ((count / totalFiltered) * 100).toFixed(0);
                                      const barWidth = (count / max) * 100;
                                      return (
                                        <div key={label} style={{ marginBottom: '6px' }}>
                                          <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '12px', marginBottom: '2px' }}>
                                            <span>{displayLabel}</span>
                                            <span style={{ fontWeight: '600' }}>{count} ({pct}%)</span>
                                          </div>
                                          <div style={{ height: '18px', background: 'var(--ice)', borderRadius: '4px', overflow: 'hidden' }}>
                                            <div style={{ width: `${barWidth}%`, height: '100%', background: color, borderRadius: '4px' }} />
                                          </div>
                                        </div>
                                      );
                                    })}
                                  </div>
                                );
                              };
                              
                              return (
                                <div>
                                  <p style={{ fontSize: '13px', color: 'var(--text-light)', marginBottom: '16px' }}>
                                    Showing {totalFiltered} of {missShots.length} misses
                                  </p>
                                  <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '20px' }}>
                                    {showTurnBreakdown && Object.keys(turnCounts).length > 0 && renderBreakdown('By Turn', turnCounts, 'var(--primary)')}
                                    {showShotTypeBreakdown && Object.keys(shotTypeCounts).length > 0 && renderBreakdown('By Shot Type', shotTypeCounts, 'var(--accent)')}
                                    {showPrimaryBreakdown && Object.keys(primaryCounts).length > 0 && renderBreakdown('By Primary Miss', primaryCounts, 'var(--secondary)')}
                                    {showSecondaryBreakdown && Object.keys(secondaryCounts).length > 0 && renderBreakdown('By Secondary Miss', secondaryCounts, 'var(--warning)')}
                                  </div>
                                </div>
                              );
                            })()}
                          </div>
                        );
                      })()}
                    </div>
                  )}

                  {/* Miss Count Trend by Competition - filtered by same filters */}
                  {seasonStats.competitionStats.length >= 2 && seasonStats.missShots.length > 0 && (
                    <div style={styles.card}>
                      <h3 style={styles.cardTitle}>MISS COUNT TREND {overviewPlayerFilter !== 'Team' && `- ${overviewPlayerFilter}`}</h3>
                      <p style={{ fontSize: '12px', color: 'var(--text-light)', marginBottom: '12px' }}>
                        {(seasonMissFilterTurn || seasonMissFilterShotType || seasonMissFilterPrimary || seasonMissFilterSecondary) 
                          ? 'Filtered by miss analysis filters above'
                          : 'All misses by competition'}
                      </p>
                      <div style={{ overflowX: 'auto' }}>
                        {(() => {
                          // Calculate filtered miss counts per competition
                          const filteredMissCounts = seasonStats.competitionStats.map(c => {
                            let count = c.missCount;
                            // Apply filters if any are set
                            if (seasonMissFilterTurn) {
                              count = c.missByTurn[seasonMissFilterTurn] || 0;
                            }
                            if (seasonMissFilterShotType) {
                              count = c.missByShotType[seasonMissFilterShotType] || 0;
                            }
                            if (seasonMissFilterPrimary) {
                              count = c.missByPrimary[seasonMissFilterPrimary] || 0;
                            }
                            if (seasonMissFilterSecondary) {
                              count = c.missBySecondary?.[seasonMissFilterSecondary] || 0;
                            }
                            return count;
                          });
                          
                          const maxMiss = Math.max(...filteredMissCounts, 1);
                          
                          return (
                            <svg width={Math.max(600, seasonStats.competitionStats.length * 100)} height="280" style={{ display: 'block' }}>
                              {[0, Math.round(maxMiss/4), Math.round(maxMiss/2), Math.round(maxMiss*3/4), maxMiss].map((val, i) => (
                                <g key={i}>
                                  <line x1="60" y1={220 - (val/maxMiss * 180)} x2={60 + (seasonStats.competitionStats.length - 1) * 80 + 40} y2={220 - (val/maxMiss * 180)} stroke="#e5e7eb" strokeWidth="1" />
                                  <text x="55" y={220 - (val/maxMiss * 180) + 4} textAnchor="end" fontSize="10" fill="#9ca3af">{val}</text>
                                </g>
                              ))}
                              {seasonStats.competitionStats.map((c, i) => (
                                <rect key={c.id} x={60 + i * 80} y={220 - (filteredMissCounts[i]/maxMiss * 180)} width="40" height={filteredMissCounts[i]/maxMiss * 180} fill="var(--error)" rx="4" />
                              ))}
                              {seasonStats.competitionStats.map((c, i) => (
                                <text key={`count-${c.id}`} x={80 + i * 80} y={215 - (filteredMissCounts[i]/maxMiss * 180)} textAnchor="middle" fontSize="10" fontWeight="600" fill="var(--error)">{filteredMissCounts[i]}</text>
                              ))}
                              {seasonStats.competitionStats.map((c, i) => (
                                <text key={`label-${c.id}`} x={80 + i * 80} y="250" textAnchor="middle" fontSize="10" fill="#6b7280" transform={`rotate(-20, ${80 + i * 80}, 250)`}>
                                  {c.name.length > 12 ? c.name.substring(0, 12) + '...' : c.name}
                                </text>
                              ))}
                            </svg>
                          );
                        })()}
                      </div>
                    </div>
                  )}
                </div>
              )}
            </div>
          )}

          {/* Competitions Tab */}
          {activeSubTab === 'competitions' && (
            <div>
          {/* Competition Selector */}
          <div style={styles.card}>
            <div style={{ display: 'flex', gap: '12px', alignItems: 'flex-end', flexWrap: 'wrap' }}>
              <div style={{ flex: 1, minWidth: '200px' }}>
                <label style={styles.label}>Competition</label>
                <select
                  style={styles.select}
                  value={selectedCompetition?.id || ''}
                  onChange={(e) => {
                    const comp = competitions.find(c => c.id === e.target.value);
                    setSelectedCompetition(comp || null);
                    setViewMode('list');
                    setSelectedGames([]);
                    if (comp) Storage.set('lastCompetitionId', comp.id);
                  }}
                >
                  <option value="">Select Competition...</option>
                  {competitions
                    .filter(c => {
                      // If no team filter or "All Teams", show all competitions
                      if (seasonTeamFilter === 'All Teams') return true;
                      // Only show competitions that have games from the selected team
                      return c.games && c.games.some(g => g.teamName === seasonTeamFilter);
                    })
                    .map(c => {
                      // Count games for this team in this competition
                      const gameCount = seasonTeamFilter === 'All Teams' 
                        ? c.games.length 
                        : c.games.filter(g => g.teamName === seasonTeamFilter).length;
                      return (
                        <option key={c.id} value={c.id}>
                          {c.name} ({gameCount} game{gameCount !== 1 ? 's' : ''})
                        </option>
                      );
                    })}
                </select>
              </div>
              <button
                onClick={() => setShowNewCompModal(true)}
                style={{ ...styles.button, ...styles.buttonPrimary }}
              >
                + New Competition
              </button>
              {selectedCompetition && (
                <button
                  onClick={() => {
                    setDeleteType('competition');
                    setShowDeleteConfirm(selectedCompetition.id);
                  }}
                  style={{ ...styles.button, background: 'var(--error)', color: 'white' }}
                >
                  üóëÔ∏è Delete
                </button>
              )}
            </div>
          </div>

          {/* Main Content */}
          {selectedCompetition && (
            <>
              {/* View Mode Tabs */}
              <div style={{ display: 'flex', gap: '8px', marginBottom: '20px' }}>
                <button
                  onClick={() => { setViewMode('list'); setSelectedGames([]); }}
                  style={{
                    ...styles.button,
                    background: viewMode === 'list' ? 'var(--secondary)' : 'var(--ice)',
                    color: viewMode === 'list' ? 'white' : 'var(--text)'
                  }}
                >
                  üìã Game List
                </button>
                <button
                  onClick={() => setViewMode('stats')}
                  style={{
                    ...styles.button,
                    background: viewMode === 'stats' ? 'var(--secondary)' : 'var(--ice)',
                    color: viewMode === 'stats' ? 'white' : 'var(--text)'
                  }}
                  disabled={selectedCompetition.games.length === 0}
                >
                  üìä Competition Stats
                </button>
              </div>

              {/* Game List View */}
              {viewMode === 'list' && (
                <div style={styles.card}>
                  <h3 style={{ ...styles.cardTitle, marginBottom: '16px' }}>
                    ARCHIVED GAMES ({selectedCompetition.games.length})
                  </h3>
                  
                  {selectedCompetition.games.length === 0 ? (
                    <p style={{ textAlign: 'center', color: 'var(--text-light)', padding: '40px' }}>
                      No games archived yet. Games will appear here when you archive them from Game Stats.
                    </p>
                  ) : (
                    <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                      {selectedCompetition.games
                        .sort((a, b) => new Date(b.gameDate) - new Date(a.gameDate))
                        .map(game => {
                          const { result, color } = getGameResult(game);
                          return (
                            <div 
                              key={game.id}
                              style={{
                                display: 'flex',
                                alignItems: 'center',
                                justifyContent: 'space-between',
                                padding: '16px',
                                background: 'var(--ice)',
                                borderRadius: 'var(--radius-sm)',
                                flexWrap: 'wrap',
                                gap: '12px'
                              }}
                            >
                              <div style={{ display: 'flex', alignItems: 'center', gap: '16px' }}>
                                <span style={{ 
                                  fontWeight: '700', 
                                  fontSize: '18px',
                                  color: color,
                                  width: '24px'
                                }}>
                                  {result}
                                </span>
                                <div>
                                  <div style={{ fontWeight: '600' }}>
                                    vs {game.opponent}
                                  </div>
                                  <div style={{ fontSize: '13px', color: 'var(--text-light)' }}>
                                    {formatDate(game.gameDate)} ‚Ä¢ {game.compRound} ‚Ä¢ {game.finalScore}
                                  </div>
                                </div>
                              </div>
                              <div style={{ display: 'flex', gap: '8px' }}>
                                <button
                                  onClick={() => setShowExportModal(game)}
                                  style={{ ...styles.button, ...styles.buttonSecondary, padding: '8px 16px' }}
                                >
                                  üì§ Export
                                </button>
                                <button
                                  onClick={() => {
                                    setDeleteType('game');
                                    setShowDeleteConfirm(game.id);
                                  }}
                                  style={{ ...styles.button, background: '#d1d5db', color: 'var(--text)', padding: '8px 16px' }}
                                >
                                  üóëÔ∏è
                                </button>
                              </div>
                            </div>
                          );
                        })}
                    </div>
                  )}
                  
                  {/* Backup/Import Buttons */}
                  <div style={{ display: 'flex', gap: '12px', justifyContent: 'center', marginTop: '20px', flexWrap: 'wrap' }}>
                    <button
                      onClick={exportCompetitionBackup}
                      style={{ ...styles.button, background: 'var(--accent)', color: 'white' }}
                    >
                      üíæ Backup Competition
                    </button>
                    <label style={{ 
                      ...styles.button, 
                      background: 'var(--ice)', 
                      color: 'var(--text)',
                      cursor: 'pointer',
                      display: 'inline-flex',
                      alignItems: 'center'
                    }}>
                      üì• Import Backup
                      <input 
                        type="file" 
                        accept=".json" 
                        onChange={importCompetitionBackup}
                        style={{ display: 'none' }}
                      />
                    </label>
                  </div>
                </div>
              )}

              {/* Stats View */}
              {viewMode === 'stats' && cumulativeStats && (
                <div>
                  {/* Competition Summary Header */}
                  <div style={{ ...styles.card, textAlign: 'center', marginBottom: '20px' }}>
                    <h3 style={{ margin: '0 0 8px 0', color: 'var(--secondary)' }}>
                      {selectedCompetition.name}
                    </h3>
                    <p style={{ color: 'var(--text-light)', margin: 0 }}>
                      {cumulativeStats.teamName} ‚Ä¢ {cumulativeStats.totalGames} Games ‚Ä¢ {cumulativeStats.totalShots} Shots
                    </p>
                  </div>

                  {/* Team Competition Stats */}
                  <div style={styles.card}>
                    <h3 style={styles.cardTitle}>TEAM COMPETITION STATS</h3>
                    <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(120px, 1fr))', gap: '16px' }}>
                      <div style={{ textAlign: 'center', padding: '16px', background: 'var(--ice)', borderRadius: 'var(--radius-sm)' }}>
                        <div style={{ fontSize: '28px', fontWeight: '700', color: 'var(--primary)' }}>{cumulativeStats.overallPct}%</div>
                        <div style={{ fontSize: '12px', color: 'var(--text-light)' }}>Shooting %</div>
                      </div>
                      <div style={{ textAlign: 'center', padding: '16px', background: 'var(--ice)', borderRadius: 'var(--radius-sm)' }}>
                        <div style={{ fontSize: '28px', fontWeight: '700', color: '#22c55e' }}>{cumulativeStats.hammerEff !== null ? `${cumulativeStats.hammerEff}%` : '-'}</div>
                        <div style={{ fontSize: '12px', color: 'var(--text-light)' }}>Hammer Eff</div>
                      </div>
                      <div style={{ textAlign: 'center', padding: '16px', background: 'var(--ice)', borderRadius: 'var(--radius-sm)' }}>
                        <div style={{ fontSize: '28px', fontWeight: '700', color: '#3b82f6' }}>{cumulativeStats.forceEff !== null ? `${cumulativeStats.forceEff}%` : '-'}</div>
                        <div style={{ fontSize: '12px', color: 'var(--text-light)' }}>Force Eff</div>
                      </div>
                      <div style={{ textAlign: 'center', padding: '16px', background: 'var(--ice)', borderRadius: 'var(--radius-sm)' }}>
                        <div style={{ fontSize: '28px', fontWeight: '700', color: '#f59e0b' }}>{cumulativeStats.stealEff !== null ? `${cumulativeStats.stealEff}%` : '-'}</div>
                        <div style={{ fontSize: '12px', color: 'var(--text-light)' }}>Steal Eff</div>
                      </div>
                      <div style={{ textAlign: 'center', padding: '16px', background: 'var(--ice)', borderRadius: 'var(--radius-sm)' }}>
                        <div style={{ fontSize: '28px', fontWeight: '700', color: '#ef4444' }}>{cumulativeStats.stealDef !== null ? `${cumulativeStats.stealDef}%` : '-'}</div>
                        <div style={{ fontSize: '12px', color: 'var(--text-light)' }}>Steal Def</div>
                      </div>
                    </div>
                  </div>

                  {/* Filter by Player - moved above Shooting Percentage */}
                  {cumulativeStats.playerNames && cumulativeStats.playerNames.length > 0 && (
                    <div style={styles.card}>
                      <h3 style={styles.cardTitle}>FILTER BY PLAYER</h3>
                      <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                        <button
                          onClick={() => setPlayerFilter('Team')}
                          style={{
                            padding: '10px 20px',
                            borderRadius: 'var(--radius-sm)',
                            border: 'none',
                            cursor: 'pointer',
                            fontWeight: playerFilter === 'Team' ? '700' : '500',
                            background: playerFilter === 'Team' ? 'var(--primary)' : 'var(--ice)',
                            color: playerFilter === 'Team' ? 'white' : 'var(--text)',
                            fontSize: '14px'
                          }}
                        >
                          Team
                        </button>
                        {cumulativeStats.playerNames.map(name => (
                          <button
                            key={name}
                            onClick={() => setPlayerFilter(name)}
                            style={{
                              padding: '10px 20px',
                              borderRadius: 'var(--radius-sm)',
                              border: 'none',
                              cursor: 'pointer',
                              fontWeight: playerFilter === name ? '700' : '500',
                              background: playerFilter === name ? 'var(--secondary)' : 'var(--ice)',
                              color: playerFilter === name ? 'white' : 'var(--text)',
                              fontSize: '14px'
                            }}
                          >
                            {name}
                          </button>
                        ))}
                      </div>
                      <div style={{ fontSize: '11px', color: 'var(--text-light)', marginTop: '8px' }}>
                        Filter affects Shooting Percentage, Miss Analysis, and Heat Maps
                      </div>
                    </div>
                  )}

                  {/* Shooting Percentage with Game Filters */}
                  <div style={styles.card}>
                    <h3 style={styles.cardTitle}>SHOOTING PERCENTAGE {playerFilter !== 'Team' && `- ${playerFilter}`}</h3>
                    <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap', alignItems: 'center' }}>
                      <button
                        onClick={clearGameFilter}
                        style={{
                          ...styles.button,
                          background: selectedGames.length === 0 ? 'var(--primary)' : 'var(--ice)',
                          color: selectedGames.length === 0 ? 'white' : 'var(--text)',
                          padding: '12px 20px'
                        }}
                      >
                        <div style={{ fontSize: '12px', opacity: 0.8 }}>Overall</div>
                        <div style={{ fontSize: '20px', fontWeight: '700' }}>{cumulativeStats.overallPct}%</div>
                      </button>
                      {cumulativeStats.gamePercentages.map(g => (
                        <button
                          key={g.id}
                          onClick={() => toggleGameFilter(g.id)}
                          style={{
                            ...styles.button,
                            background: selectedGames.includes(g.id) ? 'var(--secondary)' : 'var(--ice)',
                            color: selectedGames.includes(g.id) ? 'white' : 'var(--text)',
                            padding: '12px 16px',
                            textAlign: 'center'
                          }}
                        >
                          <div style={{ fontSize: '11px', opacity: 0.8 }}>{g.opponent}</div>
                          <div style={{ fontSize: '18px', fontWeight: '700' }}>{g.pct}%</div>
                        </button>
                      ))}
                    </div>
                    <div style={{ fontSize: '11px', color: 'var(--text-light)', marginTop: '8px' }}>
                      Click games to filter stats ‚Ä¢ {selectedGames.length > 0 ? `${selectedGames.length} game(s) selected` : 'Showing all games'}
                    </div>
                  </div>

                  {/* Shot Success Analysis */}
                  <div style={styles.card}>
                    <h3 style={styles.cardTitle}>SHOT SUCCESS ANALYSIS</h3>
                    <div style={{ overflowX: 'auto' }}>
                      <table style={{ ...styles.table, fontSize: '13px' }}>
                        <thead>
                          <tr>
                            <th style={styles.th}>Player</th>
                            <th style={styles.th}>IT</th>
                            <th style={styles.th}>OT</th>
                            <th style={styles.th}>Draws</th>
                            <th style={styles.th}>IT</th>
                            <th style={styles.th}>OT</th>
                            <th style={styles.th}>T-Outs</th>
                            <th style={styles.th}>Competition</th>
                          </tr>
                        </thead>
                        <tbody>
                          {cumulativeStats.playerTable.map((p, idx) => (
                            <tr key={p.name} style={{ background: idx % 2 === 0 ? 'white' : 'var(--ice)' }}>
                              <td style={{ ...styles.td, fontWeight: '600' }}>{p.name}</td>
                              <td style={styles.td}>{p.draws.inTurnCount > 0 ? `(${p.draws.inTurnCount}) ${p.draws.inTurnPct}%` : '-'}</td>
                              <td style={styles.td}>{p.draws.outTurnCount > 0 ? `(${p.draws.outTurnCount}) ${p.draws.outTurnPct}%` : '-'}</td>
                              <td style={styles.td}>{p.draws.totalCount > 0 ? `(${p.draws.totalCount}) ${p.draws.totalPct}%` : '-'}</td>
                              <td style={styles.td}>{p.takeouts.inTurnCount > 0 ? `(${p.takeouts.inTurnCount}) ${p.takeouts.inTurnPct}%` : '-'}</td>
                              <td style={styles.td}>{p.takeouts.outTurnCount > 0 ? `(${p.takeouts.outTurnCount}) ${p.takeouts.outTurnPct}%` : '-'}</td>
                              <td style={styles.td}>{p.takeouts.totalCount > 0 ? `(${p.takeouts.totalCount}) ${p.takeouts.totalPct}%` : '-'}</td>
                              <td style={{ ...styles.td, fontWeight: '600' }}>{p.total.count > 0 ? `(${p.total.count}) ${p.total.pct}%` : '-'}</td>
                            </tr>
                          ))}
                          <tr style={{ background: 'var(--secondary)', color: 'white' }}>
                            <td style={{ ...styles.td, fontWeight: '700' }}>Team Total</td>
                            <td style={styles.td}>{cumulativeStats.teamRow.draws.inTurnCount > 0 ? `(${cumulativeStats.teamRow.draws.inTurnCount}) ${cumulativeStats.teamRow.draws.inTurnPct}%` : '-'}</td>
                            <td style={styles.td}>{cumulativeStats.teamRow.draws.outTurnCount > 0 ? `(${cumulativeStats.teamRow.draws.outTurnCount}) ${cumulativeStats.teamRow.draws.outTurnPct}%` : '-'}</td>
                            <td style={styles.td}>{cumulativeStats.teamRow.draws.totalCount > 0 ? `(${cumulativeStats.teamRow.draws.totalCount}) ${cumulativeStats.teamRow.draws.totalPct}%` : '-'}</td>
                            <td style={styles.td}>{cumulativeStats.teamRow.takeouts.inTurnCount > 0 ? `(${cumulativeStats.teamRow.takeouts.inTurnCount}) ${cumulativeStats.teamRow.takeouts.inTurnPct}%` : '-'}</td>
                            <td style={styles.td}>{cumulativeStats.teamRow.takeouts.outTurnCount > 0 ? `(${cumulativeStats.teamRow.takeouts.outTurnCount}) ${cumulativeStats.teamRow.takeouts.outTurnPct}%` : '-'}</td>
                            <td style={styles.td}>{cumulativeStats.teamRow.takeouts.totalCount > 0 ? `(${cumulativeStats.teamRow.takeouts.totalCount}) ${cumulativeStats.teamRow.takeouts.totalPct}%` : '-'}</td>
                            <td style={{ ...styles.td, fontWeight: '700' }}>{`(${cumulativeStats.teamRow.total.count}) ${cumulativeStats.teamRow.total.pct}%`}</td>
                          </tr>
                        </tbody>
                      </table>
                    </div>
                  </div>

                  {/* Heat Maps - only show if advanced stats were collected */}
                  {(() => {
                    // Check if there's any heat map data
                    const hasDrawData = cumulativeStats.drawHeatMap && Object.values(cumulativeStats.drawHeatMap).some(row => 
                      Object.values(row).some(cell => cell.count > 0)
                    );
                    const hasTakeoutData = cumulativeStats.takeoutHeatMap && Object.values(cumulativeStats.takeoutHeatMap).some(row => 
                      Object.values(row).some(cell => cell.count > 0)
                    );
                    
                    if (!hasDrawData && !hasTakeoutData) return null;
                    
                    return (
                  <div style={styles.card}>
                    <h3 style={styles.cardTitle}>TARGET HEAT MAPS</h3>
                    <p style={{ fontSize: '12px', color: 'var(--text-light)', marginBottom: '16px' }}>
                      Shooting percentage by target location {selectedGames.length > 0 ? `(${selectedGames.length} game${selectedGames.length > 1 ? 's' : ''} selected)` : '(All Games)'}
                    </p>
                    {(() => {
                      const TARGET_DIRECTIONS = ['Left', 'Center', 'Right'];
                      const TARGET_DEPTHS = ['Back 12', 'Back 8', 'Back 4', 'T-Line', 'Top 4', 'Top 8', 'Top 12', 'Tight Guard', 'Mid Guard', 'High Guard'];
                      
                      const getHeatColor = (pct) => {
                        if (pct === null) return 'rgba(229, 231, 235, 0.7)';
                        if (pct >= 90) return 'rgba(34, 197, 94, 0.8)';
                        if (pct >= 83) return 'rgba(132, 204, 22, 0.8)';
                        if (pct >= 75) return 'rgba(250, 204, 21, 0.8)';
                        if (pct >= 70) return 'rgba(251, 146, 60, 0.8)';
                        return 'rgba(239, 68, 68, 0.8)';
                      };
                      
                      const cellWidth = 70;
                      const cellHeight = 45;
                      const labelWidth = 60;
                      const gridWidth = cellWidth * 3;
                      const gridHeight = cellHeight * 8;
                      
                      const renderHeatMap = (heatMapData, title) => {
                        if (!heatMapData) return null;
                        const hasData = Object.values(heatMapData).some(row => Object.values(row).some(cell => cell.count > 0));
                        if (!hasData) return (
                          <div style={{ flex: 1, minWidth: '280px' }}>
                            <h4 style={{ fontSize: '14px', fontWeight: '600', marginBottom: '12px', color: 'var(--secondary)', textAlign: 'center' }}>{title}</h4>
                            <p style={{ textAlign: 'center', color: 'var(--text-light)', padding: '20px' }}>No data available</p>
                          </div>
                        );
                        
                        // Calculate pct for each cell
                        const processedData = {};
                        TARGET_DEPTHS.forEach(depth => {
                          processedData[depth] = {};
                          TARGET_DIRECTIONS.forEach(dir => {
                            const cell = heatMapData[depth]?.[dir];
                            if (cell && cell.count > 0) {
                              processedData[depth][dir] = {
                                count: cell.count,
                                pct: Math.round((cell.total / cell.sum) * 100)
                              };
                            } else {
                              processedData[depth][dir] = { count: 0, pct: null };
                            }
                          });
                        });
                        
                        return (
                          <div style={{ flex: 1, minWidth: '280px' }}>
                            <h4 style={{ fontSize: '14px', fontWeight: '600', marginBottom: '12px', color: 'var(--secondary)', textAlign: 'center' }}>{title}</h4>
                            <div style={{ display: 'flex', justifyContent: 'center' }}>
                              <div style={{ position: 'relative' }}>
                                <div style={{ display: 'flex', marginLeft: labelWidth }}>
                                  {TARGET_DIRECTIONS.map(dir => (
                                    <div key={dir} style={{ width: cellWidth, textAlign: 'center', fontWeight: '600', fontSize: '11px', padding: '4px 0', color: 'var(--secondary)' }}>{dir}</div>
                                  ))}
                                </div>
                                <div style={{ display: 'flex' }}>
                                  <div style={{ width: labelWidth }}>
                                    {TARGET_DEPTHS.map(depth => (
                                      <div key={depth} style={{ height: cellHeight, display: 'flex', alignItems: 'center', justifyContent: 'flex-end', paddingRight: '6px', fontWeight: '500', fontSize: '10px', color: 'var(--text-light)' }}>{depth}</div>
                                    ))}
                                  </div>
                                  <div style={{ position: 'relative', width: gridWidth, height: gridHeight }}>
                                    <svg style={{ position: 'absolute', top: 0, left: 0, width: gridWidth, height: gridHeight, pointerEvents: 'none' }} viewBox={`0 0 ${gridWidth} ${gridHeight}`} preserveAspectRatio="none">
                                      {(() => {
                                        const tLineRowIndex = 3;
                                        const centerX = gridWidth / 2;
                                        const centerY = (tLineRowIndex * cellHeight) + (cellHeight / 2);
                                        const maxRadius = cellHeight * 3.2;
                                        const ring8 = maxRadius * (8/12);
                                        const ring4 = maxRadius * (4/12);
                                        const button = maxRadius * (1/12);
                                        return (
                                          <>
                                            <circle cx={centerX} cy={centerY} r={maxRadius} fill="rgba(59, 130, 246, 0.15)" stroke="rgba(59, 130, 246, 0.3)" strokeWidth="2"/>
                                            <circle cx={centerX} cy={centerY} r={ring8} fill="rgba(255, 255, 255, 0.4)" stroke="rgba(200, 200, 200, 0.5)" strokeWidth="2"/>
                                            <circle cx={centerX} cy={centerY} r={ring4} fill="rgba(239, 68, 68, 0.15)" stroke="rgba(239, 68, 68, 0.3)" strokeWidth="2"/>
                                            <circle cx={centerX} cy={centerY} r={button} fill="rgba(255, 255, 255, 0.6)" stroke="rgba(100, 100, 100, 0.4)" strokeWidth="1"/>
                                            <line x1={0} y1={centerY} x2={gridWidth} y2={centerY} stroke="rgba(100, 100, 100, 0.3)" strokeWidth="2"/>
                                            <line x1={centerX} y1={0} x2={centerX} y2={gridHeight - cellHeight} stroke="rgba(100, 100, 100, 0.3)" strokeWidth="2"/>
                                          </>
                                        );
                                      })()}
                                    </svg>
                                    <div style={{ position: 'relative', zIndex: 1 }}>
                                      {TARGET_DEPTHS.map((depth, rowIdx) => (
                                        <div key={depth} style={{ display: 'flex' }}>
                                          {TARGET_DIRECTIONS.map(dir => {
                                            const cell = processedData[depth][dir];
                                            return (
                                              <div key={dir} style={{ width: cellWidth, height: cellHeight, display: 'flex', flexDirection: 'column', alignItems: 'center', justifyContent: 'center', background: getHeatColor(cell.pct), border: '1px solid rgba(255,255,255,0.5)' }}>
                                                {cell.count > 0 ? (
                                                  <>
                                                    <div style={{ fontWeight: '700', fontSize: '14px', color: cell.pct >= 75 ? 'var(--secondary)' : 'white', textShadow: cell.pct < 75 ? '0 1px 2px rgba(0,0,0,0.3)' : 'none' }}>{cell.pct}%</div>
                                                    <div style={{ fontSize: '9px', color: cell.pct >= 75 ? 'var(--text-light)' : 'rgba(255,255,255,0.9)' }}>({cell.count})</div>
                                                  </>
                                                ) : (
                                                  <div style={{ fontSize: '10px', color: 'var(--text-light)' }}>-</div>
                                                )}
                                              </div>
                                            );
                                          })}
                                        </div>
                                      ))}
                                    </div>
                                  </div>
                                </div>
                              </div>
                            </div>
                          </div>
                        );
                      };
                      
                      return (
                        <div style={{ display: 'flex', gap: '24px', flexWrap: 'wrap', justifyContent: 'center' }}>
                          {renderHeatMap(cumulativeStats.drawHeatMap, 'DRAWS')}
                          {renderHeatMap(cumulativeStats.takeoutHeatMap, 'TAKEOUTS')}
                        </div>
                      );
                    })()}
                    <div style={{ display: 'flex', justifyContent: 'center', gap: '12px', marginTop: '16px', flexWrap: 'wrap' }}>
                      {[
                        { label: '90%+', color: 'rgba(34, 197, 94, 0.8)' },
                        { label: '83-89%', color: 'rgba(132, 204, 22, 0.8)' },
                        { label: '75-82%', color: 'rgba(250, 204, 21, 0.8)' },
                        { label: '70-74%', color: 'rgba(251, 146, 60, 0.8)' },
                        { label: '<70%', color: 'rgba(239, 68, 68, 0.8)' },
                        { label: 'No data', color: 'rgba(229, 231, 235, 0.7)' }
                      ].map(item => (
                        <div key={item.label} style={{ display: 'flex', alignItems: 'center', gap: '4px' }}>
                          <div style={{ width: '16px', height: '16px', background: item.color, borderRadius: '3px', border: '1px solid rgba(0,0,0,0.1)' }} />
                          <span style={{ fontSize: '11px', color: 'var(--text-light)' }}>{item.label}</span>
                        </div>
                      ))}
                    </div>
                  </div>
                    );
                  })()}

                  {/* Miss Analysis */}
                  {cumulativeStats.missShots.length > 0 && (
                    <div style={styles.card}>
                      <h3 style={styles.cardTitle}>MISS ANALYSIS {playerFilter !== 'Team' && `- ${playerFilter}`}</h3>
                      
                      {(() => {
                        const missShots = cumulativeStats.missShots;
                        
                        // Get unique values for filters
                        const turns = [...new Set(missShots.map(s => s.turn).filter(Boolean))];
                        const shotTypes = [...new Set(missShots.map(s => s.shotType).filter(Boolean))];
                        const primaryMisses = [...new Set(missShots.map(s => s.miss).filter(Boolean))];
                        const secondaryMisses = [...new Set(missShots.map(s => s.secondaryMiss).filter(Boolean))];
                        
                        return (
                          <div>
                            {/* Filter Controls */}
                            <div style={{ 
                              display: 'grid', 
                              gridTemplateColumns: 'repeat(auto-fit, minmax(150px, 1fr))', 
                              gap: '12px',
                              marginBottom: '20px',
                              padding: '16px',
                              background: 'var(--ice)',
                              borderRadius: 'var(--radius-sm)'
                            }}>
                              <div>
                                <label style={{ fontSize: '12px', fontWeight: '600', display: 'block', marginBottom: '4px' }}>Turn</label>
                                <select
                                  style={{ ...styles.select, width: '100%', fontSize: '13px' }}
                                  value={missFilterTurn || ''}
                                  onChange={(e) => setMissFilterTurn(e.target.value || null)}
                                >
                                  <option value="">All Turns</option>
                                  {turns.map(t => <option key={t} value={t}>{t === 'In-Turn' ? 'Clockwise' : t === 'Out-Turn' ? 'Counter Clockwise' : t}</option>)}
                                </select>
                              </div>
                              <div>
                                <label style={{ fontSize: '12px', fontWeight: '600', display: 'block', marginBottom: '4px' }}>Shot Type</label>
                                <select
                                  style={{ ...styles.select, width: '100%', fontSize: '13px' }}
                                  value={missFilterShotType || ''}
                                  onChange={(e) => setMissFilterShotType(e.target.value || null)}
                                >
                                  <option value="">All Shot Types</option>
                                  {shotTypes.map(st => <option key={st} value={st}>{st}</option>)}
                                </select>
                              </div>
                              <div>
                                <label style={{ fontSize: '12px', fontWeight: '600', display: 'block', marginBottom: '4px' }}>Primary Miss</label>
                                <select
                                  style={{ ...styles.select, width: '100%', fontSize: '13px' }}
                                  value={missFilterPrimary || ''}
                                  onChange={(e) => setMissFilterPrimary(e.target.value || null)}
                                >
                                  <option value="">All Primary</option>
                                  {primaryMisses.map(m => <option key={m} value={m}>{m}</option>)}
                                </select>
                              </div>
                              <div>
                                <label style={{ fontSize: '12px', fontWeight: '600', display: 'block', marginBottom: '4px' }}>Secondary Miss</label>
                                <select
                                  style={{ ...styles.select, width: '100%', fontSize: '13px' }}
                                  value={missFilterSecondary || ''}
                                  onChange={(e) => setMissFilterSecondary(e.target.value || null)}
                                >
                                  <option value="">All Secondary</option>
                                  {secondaryMisses.map(m => <option key={m} value={m}>{m}</option>)}
                                </select>
                              </div>
                            </div>
                            
                            {/* Filtered Results */}
                            {(() => {
                              let filtered = missShots;
                              if (missFilterTurn) filtered = filtered.filter(s => s.turn === missFilterTurn);
                              if (missFilterShotType) filtered = filtered.filter(s => s.shotType === missFilterShotType);
                              if (missFilterPrimary) filtered = filtered.filter(s => s.miss === missFilterPrimary);
                              if (missFilterSecondary) filtered = filtered.filter(s => s.secondaryMiss === missFilterSecondary);
                              
                              const showTurnBreakdown = !missFilterTurn;
                              const showShotTypeBreakdown = !missFilterShotType;
                              const showPrimaryBreakdown = !missFilterPrimary;
                              const showSecondaryBreakdown = !missFilterSecondary;
                              
                              const turnCounts = {};
                              const shotTypeCounts = {};
                              const primaryCounts = {};
                              const secondaryCounts = {};
                              
                              filtered.forEach(s => {
                                if (s.turn) turnCounts[s.turn] = (turnCounts[s.turn] || 0) + 1;
                                if (s.shotType) shotTypeCounts[s.shotType] = (shotTypeCounts[s.shotType] || 0) + 1;
                                if (s.miss) primaryCounts[s.miss] = (primaryCounts[s.miss] || 0) + 1;
                                if (s.secondaryMiss) secondaryCounts[s.secondaryMiss] = (secondaryCounts[s.secondaryMiss] || 0) + 1;
                              });
                              
                              const totalFiltered = filtered.length;
                              
                              const renderBreakdown = (title, data, color) => {
                                const entries = Object.entries(data).sort((a, b) => b[1] - a[1]);
                                const max = Math.max(...entries.map(e => e[1]));
                                return (
                                  <div>
                                    <h4 style={{ fontSize: '13px', fontWeight: '600', marginBottom: '10px', color: 'var(--secondary)' }}>{title}</h4>
                                    {entries.map(([label, count]) => {
                                      const displayLabel = label === 'In-Turn' ? 'Clockwise' : label === 'Out-Turn' ? 'Counter CW' : label;
                                      const pct = ((count / totalFiltered) * 100).toFixed(0);
                                      const barWidth = (count / max) * 100;
                                      return (
                                        <div key={label} style={{ marginBottom: '6px' }}>
                                          <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '12px', marginBottom: '2px' }}>
                                            <span>{displayLabel}</span>
                                            <span style={{ fontWeight: '600' }}>{count} ({pct}%)</span>
                                          </div>
                                          <div style={{ height: '18px', background: 'var(--ice)', borderRadius: '4px', overflow: 'hidden' }}>
                                            <div style={{ width: `${barWidth}%`, height: '100%', background: color, borderRadius: '4px' }} />
                                          </div>
                                        </div>
                                      );
                                    })}
                                  </div>
                                );
                              };
                              
                              return (
                                <div>
                                  <p style={{ fontSize: '13px', color: 'var(--text-light)', marginBottom: '16px' }}>
                                    Showing {totalFiltered} of {missShots.length} misses
                                  </p>
                                  <div style={{ display: 'grid', gridTemplateColumns: 'repeat(auto-fit, minmax(200px, 1fr))', gap: '20px' }}>
                                    {showTurnBreakdown && Object.keys(turnCounts).length > 0 && renderBreakdown('By Turn', turnCounts, 'var(--primary)')}
                                    {showShotTypeBreakdown && Object.keys(shotTypeCounts).length > 0 && renderBreakdown('By Shot Type', shotTypeCounts, 'var(--accent)')}
                                    {showPrimaryBreakdown && Object.keys(primaryCounts).length > 0 && renderBreakdown('By Primary Miss', primaryCounts, 'var(--secondary)')}
                                    {showSecondaryBreakdown && Object.keys(secondaryCounts).length > 0 && renderBreakdown('By Secondary Miss', secondaryCounts, 'var(--warning)')}
                                  </div>
                                </div>
                              );
                            })()}
                          </div>
                        );
                      })()}
                    </div>
                  )}

                  {/* Export Buttons */}
                  <div style={{ display: 'flex', gap: '12px', justifyContent: 'center', marginTop: '24px', flexWrap: 'wrap' }}>
                    <button
                      onClick={exportCompetitionSummaryPDF}
                      style={{ ...styles.button, ...styles.buttonSecondary, padding: '16px 32px', fontSize: '16px' }}
                    >
                      üìÑ Export Competition Summary PDF
                    </button>
                    <button
                      onClick={exportCompetitionBackup}
                      style={{ ...styles.button, background: 'var(--accent)', color: 'white', padding: '16px 32px', fontSize: '16px' }}
                    >
                      üíæ Backup Competition
                    </button>
                    <label style={{ 
                      ...styles.button, 
                      background: 'var(--ice)', 
                      color: 'var(--text)', 
                      padding: '16px 32px', 
                      fontSize: '16px',
                      cursor: 'pointer',
                      display: 'inline-flex',
                      alignItems: 'center'
                    }}>
                      üì• Import Backup
                      <input 
                        type="file" 
                        accept=".json" 
                        onChange={importCompetitionBackup}
                        style={{ display: 'none' }}
                      />
                    </label>
                  </div>
                </div>
              )}
            </>
          )}

          {/* New Competition Modal */}
          {showNewCompModal && (
            <div style={{
              position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
              background: 'rgba(0,0,0,0.5)', display: 'flex',
              alignItems: 'center', justifyContent: 'center', zIndex: 1000
            }}>
              <div style={{
                background: 'white', padding: '32px', borderRadius: 'var(--radius)',
                maxWidth: '400px', width: '90%'
              }}>
                <h3 style={{ marginTop: 0 }}>Create New Competition</h3>
                <div style={styles.formGroup}>
                  <label style={styles.label}>Competition Name</label>
                  <input
                    style={styles.input}
                    value={newCompName}
                    onChange={(e) => setNewCompName(e.target.value)}
                    placeholder="e.g., 2025 US Nationals"
                    autoFocus
                  />
                </div>
                <div style={{ display: 'flex', gap: '12px', marginTop: '24px' }}>
                  <button
                    onClick={() => { setShowNewCompModal(false); setNewCompName(''); }}
                    style={{ ...styles.button, background: '#d1d5db', color: 'var(--text)', flex: 1 }}
                  >
                    Cancel
                  </button>
                  <button
                    onClick={handleCreateCompetition}
                    style={{ ...styles.button, ...styles.buttonPrimary, flex: 1 }}
                  >
                    Create
                  </button>
                </div>
              </div>
            </div>
          )}

          {/* Delete Confirmation Modal */}
          {showDeleteConfirm && (
            <div style={{
              position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
              background: 'rgba(0,0,0,0.5)', display: 'flex',
              alignItems: 'center', justifyContent: 'center', zIndex: 1000
            }}>
              <div style={{
                background: 'white', padding: '32px', borderRadius: 'var(--radius)',
                maxWidth: '400px', width: '90%'
              }}>
                <h3 style={{ marginTop: 0, color: 'var(--error)' }}>
                  üóëÔ∏è Delete {deleteType === 'competition' ? 'Competition' : 'Game'}?
                </h3>
                <p style={{ color: 'var(--text-light)' }}>
                  {deleteType === 'competition' 
                    ? 'This will permanently delete this competition and all its archived games.'
                    : 'This will permanently delete this archived game.'}
                  <br /><br />
                  <strong>Make sure you have exported any data you want to keep!</strong>
                </p>
                <div style={{ display: 'flex', gap: '12px', marginTop: '24px' }}>
                  <button
                    onClick={() => { setShowDeleteConfirm(null); setDeleteType(null); }}
                    style={{ ...styles.button, background: '#d1d5db', color: 'var(--text)', flex: 1 }}
                  >
                    Cancel
                  </button>
                  <button
                    onClick={() => deleteType === 'competition' 
                      ? handleDeleteCompetition(showDeleteConfirm)
                      : handleDeleteGame(showDeleteConfirm)
                    }
                    style={{ ...styles.button, background: '#ef4444', color: '#ffffff', flex: 1 }}
                  >
                    Delete
                  </button>
                </div>
              </div>
            </div>
          )}
            </div>
          )}

          {/* Export Game Modal */}
          {showExportModal && (
            <div style={{
              position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
              background: 'rgba(0,0,0,0.5)', display: 'flex',
              alignItems: 'center', justifyContent: 'center', zIndex: 1000
            }}>
              <div style={{
                background: 'white', padding: '32px', borderRadius: 'var(--radius)',
                maxWidth: '400px', width: '90%'
              }}>
                <h3 style={{ marginTop: 0, color: 'var(--secondary)' }}>üìä Export: vs {showExportModal.opponent}</h3>
                <p style={{ 
                  color: 'var(--warning)', 
                  background: 'rgba(245, 158, 11, 0.1)', 
                  padding: '12px', 
                  borderRadius: 'var(--radius-sm)',
                  fontSize: '13px',
                  marginBottom: '20px'
                }}>
                  ‚ö†Ô∏è This game is archived and cannot be edited.
                </p>
                <div style={{ display: 'flex', flexDirection: 'column', gap: '12px' }}>
                  <button
                    onClick={() => {
                      exportArchivedGameCSV(showExportModal);
                    }}
                    style={{ 
                      ...styles.button, 
                      ...styles.buttonSecondary, 
                      width: '100%',
                      padding: '16px',
                      textAlign: 'left',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'flex-start'
                    }}
                  >
                    <span style={{ fontWeight: '600' }}>üìã Shot-by-Shot Data</span>
                    <span style={{ fontSize: '12px', color: 'var(--text-light)', marginTop: '4px' }}>
                      Individual shot details with outcomes, misses, etc.
                    </span>
                  </button>
                  <button
                    onClick={() => {
                      exportArchivedTeamStatsCSV(showExportModal);
                    }}
                    style={{ 
                      ...styles.button, 
                      ...styles.buttonSecondary, 
                      width: '100%',
                      padding: '16px',
                      textAlign: 'left',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'flex-start'
                    }}
                  >
                    <span style={{ fontWeight: '600' }}>üìà Team Stats Summary</span>
                    <span style={{ fontSize: '12px', color: 'var(--text-light)', marginTop: '4px' }}>
                      Player percentages by turn/shot type, efficiency stats
                    </span>
                  </button>
                  <button
                    onClick={() => {
                      exportArchivedGameCSV(showExportModal);
                      exportArchivedTeamStatsCSV(showExportModal);
                    }}
                    style={{ 
                      ...styles.button, 
                      background: 'var(--accent)', 
                      color: 'white',
                      width: '100%',
                      padding: '16px',
                      textAlign: 'left',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'flex-start'
                    }}
                  >
                    <span style={{ fontWeight: '600' }}>üìä Export Both CSVs</span>
                    <span style={{ fontSize: '12px', opacity: 0.9, marginTop: '4px' }}>
                      Download both CSV files at once
                    </span>
                  </button>
                  <button
                    onClick={() => exportArchivedGamePDF(showExportModal)}
                    style={{ 
                      ...styles.button, 
                      ...styles.buttonSecondary, 
                      width: '100%',
                      padding: '16px',
                      textAlign: 'left',
                      display: 'flex',
                      flexDirection: 'column',
                      alignItems: 'flex-start'
                    }}
                  >
                    <span style={{ fontWeight: '600' }}>üìÑ Export PDF</span>
                    <span style={{ fontSize: '12px', color: 'var(--text-light)', marginTop: '4px' }}>
                      Game summary with shooting percentages
                    </span>
                  </button>
                </div>
                <button
                  onClick={() => setShowExportModal(null)}
                  style={{ ...styles.button, background: '#d1d5db', color: 'var(--text)', width: '100%', marginTop: '16px' }}
                >
                  Close
                </button>
              </div>
            </div>
          )}
        </div>
      );
    }

    // ============================================
    // MAIN APP COMPONENT
    // ============================================
    
    function App() {
      const [state, dispatch] = useReducer(gameReducer, initialGameState);
      const [notification, setNotification] = useState(null);
      const [appMode, setAppMode] = useState('home'); // 'home', 'rockbook', 'gamestats', 'history'
      const [isReady, setIsReady] = useState(false);

      // Trigger loading animation completion on mount
      useEffect(() => {
        // Trigger the push-through animation
        if (window.triggerLoadingComplete) {
          window.triggerLoadingComplete();
        }
        // Wait for animation to complete before showing app
        const timer = setTimeout(() => {
          setIsReady(true);
        }, 1400);
        return () => clearTimeout(timer);
      }, []);

      // Load saved state on mount
      useEffect(() => {
        const saved = Storage.load('curlingGame');
        if (saved) {
          dispatch({ type: 'LOAD_STATE', payload: saved });
          // If there's saved game data, go directly to game stats
          if (saved.shots && saved.shots.length > 0) {
            setAppMode('gamestats');
          }
        }
      }, []);

      // Save state on changes
      useEffect(() => {
        if (state.shots.length > 0 || state.teamName) {
          Storage.save('curlingGame', state);
        }
      }, [state]);

      const notify = useCallback((message, type = 'info') => {
        setNotification({ message, type });
      }, []);

      const handleStartGame = () => {
        dispatch({ type: 'START_GAME' });
        notify("Game started! Begin tracking shots.", "success");
      };

      const handleSelectMode = (mode) => {
        setAppMode(mode);
      };

      const handleBackToHome = () => {
        setAppMode('home');
      };

      const gameStarted = state.shots.length > 0 || state.activeTab === 'tracking';

      // Don't render until loading animation is complete
      if (!isReady) {
        return null;
      }

      // Home page view
      if (appMode === 'home') {
        return (
          <div style={styles.app}>
            <header style={styles.header}>
              <div style={styles.headerContent}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                  <img 
                    src="usa_curling_logo.png" 
                    alt="USA Curling" 
                    style={{ height: '40px' }}
                    onError={(e) => e.target.style.display = 'none'}
                  />
                  <h1 style={styles.logo}>USA CURLING</h1>
                </div>
              </div>
            </header>
            <main style={styles.main}>
              <HomePage onSelectMode={handleSelectMode} />
            </main>
            {notification && (
              <Notification
                message={notification.message}
                type={notification.type}
                onClose={() => setNotification(null)}
              />
            )}
          </div>
        );
      }

      // Rock Book view
      if (appMode === 'rockbook') {
        return (
          <div style={styles.app}>
            <header style={styles.header}>
              <div style={styles.headerContent}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                  <button
                    onClick={handleBackToHome}
                    style={{
                      background: 'rgba(255,255,255,0.2)',
                      border: 'none',
                      borderRadius: 'var(--radius-sm)',
                      padding: '8px 12px',
                      cursor: 'pointer',
                      fontSize: '18px',
                      display: 'flex',
                      alignItems: 'center',
                      color: 'white'
                    }}
                    title="Back to Home"
                  >
                    üè†
                  </button>
                  <img 
                    src="usa_curling_logo.png" 
                    alt="USA Curling" 
                    style={{ height: '40px' }}
                    onError={(e) => e.target.style.display = 'none'}
                  />
                  <h1 style={styles.logo}>USA CURLING</h1>
                </div>
              </div>
            </header>
            <main style={styles.main}>
              <RockBook onBack={handleBackToHome} onNotify={notify} />
            </main>
            {notification && (
              <Notification
                message={notification.message}
                type={notification.type}
                onClose={() => setNotification(null)}
              />
            )}
          </div>
        );
      }

      // History view
      if (appMode === 'history') {
        return (
          <div style={styles.app}>
            <header style={styles.header}>
              <div style={styles.headerContent}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
                  <button
                    onClick={handleBackToHome}
                    style={{
                      background: 'rgba(255,255,255,0.2)',
                      border: 'none',
                      borderRadius: 'var(--radius-sm)',
                      padding: '8px 12px',
                      cursor: 'pointer',
                      fontSize: '18px',
                      display: 'flex',
                      alignItems: 'center',
                      color: 'white'
                    }}
                    title="Back to Home"
                  >
                    üè†
                  </button>
                  <img 
                    src="usa_curling_logo.png" 
                    alt="USA Curling" 
                    style={{ height: '40px' }}
                    onError={(e) => e.target.style.display = 'none'}
                  />
                  <h1 style={styles.logo}>USA CURLING</h1>
                </div>
              </div>
            </header>
            <main style={styles.main}>
              <History onBack={handleBackToHome} onNotify={notify} />
            </main>
            {notification && (
              <Notification
                message={notification.message}
                type={notification.type}
                onClose={() => setNotification(null)}
              />
            )}
          </div>
        );
      }

      // Game Stats view (original app)
      return (
        <div style={styles.app}>
          <Header 
            activeTab={state.activeTab}
            onTabChange={(tab) => dispatch({ type: 'SET_TAB', payload: tab })}
            gameStarted={gameStarted}
            gameEnded={state.gameEnded}
            onHome={handleBackToHome}
          />
          
          <main style={styles.main}>
            {state.activeTab === 'setup' && (
              <SetupPanel 
                state={state} 
                dispatch={dispatch}
                onStartGame={handleStartGame}
                onNotify={notify}
              />
            )}
            
            {state.activeTab === 'tracking' && (
              <TrackingPanel 
                state={state} 
                dispatch={dispatch}
                onNotify={notify}
              />
            )}
            
            {state.activeTab === 'analytics' && (
              <AnalyticsPanel 
                state={state} 
                dispatch={dispatch}
                onNotify={notify}
              />
            )}

            {state.activeTab === 'editor' && (
              <EditorPanel 
                state={state} 
                dispatch={dispatch}
                onNotify={notify}
              />
            )}
          </main>

          {notification && (
            <Notification
              message={notification.message}
              type={notification.type}
              onClose={() => setNotification(null)}
            />
          )}
        </div>
      );
    }

    // ============================================
    // RENDER
    // ============================================
    
    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
